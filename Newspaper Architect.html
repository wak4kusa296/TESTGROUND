<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SVG Newspaper Tool Core</title>
<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚©ãƒ³ãƒˆã‚’è¿½åŠ  -->
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block" rel="stylesheet">

<style>
    :root {
        --ui-bg: #f5f5f5;
        --panel-bg: #ffffff;
        --border-col: #ddd;
        --primary: #2196f3;
        --text: #333;
    }
    body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
        font-family: "Noto Sans JP", sans-serif;
        background: var(--ui-bg);
        color: var(--text);
        user-select: none; /* UIæ“ä½œä¸­ã®é¸æŠé˜²æ­¢ */
    }

    /* å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼ˆãƒ„ãƒ¼ãƒ«ï¼‰ */
    .toolbar {
        width: 60px;
        background: var(--panel-bg);
        border-right: 1px solid var(--border-col);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
        z-index: 100;
    }
    .tool-btn {
        width: 40px; height: 40px;
        margin-bottom: 10px;
        border: 1px solid var(--border-col);
        background: #fff;
        cursor: pointer;
        border-radius: 4px;
        display: flex; justify-content: center; align-items: center;
        font-size: 20px;
        transition: 0.2s;
    }
    .tool-btn:hover { background: #eee; }
    .tool-btn.active { background: var(--primary); color: #fff; border-color: var(--primary); }

    /* ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ï¼ˆãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆï¼‰ */
    .viewport {
        flex: 1;
        position: relative;
        overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã§ã¯ãªãJSã§åˆ¶å¾¡ */
        background: #e0e0e0;
        /* ãƒ‰ãƒƒãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³èƒŒæ™¯ */
        background-image: radial-gradient(#ccc 1px, transparent 1px);
        background-size: 20px 20px;
        cursor: default;
    }
    /* ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æŠ¼ä¸‹æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ« */
    .viewport.hand-mode { cursor: grab; }
    .viewport.hand-mode:active { cursor: grabbing; }

    /* SVGç”¨ç´™ã‚³ãƒ³ãƒ†ãƒŠï¼ˆå¤‰å½¢ç”¨ï¼‰ */
    #canvas-container {
        transform-origin: 0 0;
        position: absolute;
        top: 0; left: 0;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }

    /* SVGç”¨ç´™ */
    #main-svg {
        background: transparent; /* èƒŒæ™¯è‰²ã¯SVGå†…ã®rectã§ç®¡ç† */
        display: block; 
        transition: width 0.3s, height 0.3s;
        /* ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å“è³ªã‚’æœ€é«˜ã«è¨­å®š */
        shape-rendering: geometricPrecision;
        text-rendering: geometricPrecision;
    }

    /* å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼‰ */
    .properties {
        width: 280px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border-col);
        padding: 15px;
        box-sizing: border-box;
        overflow-y: auto;
        z-index: 100;
    }
    .prop-group { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
    .prop-group:last-child { border-bottom: none; }
    .prop-label { font-size: 12px; font-weight: bold; margin-bottom: 5px; display: block; color: #555; }
    .prop-row { display: flex; gap: 5px; margin-bottom: 8px; align-items: center; }
    
    .prop-input, .prop-select, .prop-textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 6px;
        border: 1px solid var(--border-col);
        margin-bottom: 8px;
        font-size: 14px;
        font-family: inherit;
    }
    .prop-textarea { resize: vertical; min-height: 100px; }
    
    .btn-primary {
        width: 100%; padding: 8px;
        background: var(--primary); color: white;
        border: none; border-radius: 4px; cursor: pointer;
    }
    .btn-primary:hover { opacity: 0.9; }

    .btn-secondary {
        flex: 1; padding: 6px;
        background: #f0f0f0; color: #333;
        border: 1px solid var(--border-col);
        border-radius: 4px; cursor: pointer;
        font-size: 12px;
        text-align: center;
    }
    .btn-secondary:hover { background: #e0e0e0; }

    /* SVGå†…ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .selection-rect {
        fill: none;
        stroke: var(--primary);
        stroke-width: 2px;
        stroke-dasharray: 4 2;
        pointer-events: none; 
        vector-effect: non-scaling-stroke;
    }
    .resize-handle {
        fill: white;
        stroke: var(--primary);
        stroke-width: 1.5px;
        cursor: pointer;
        vector-effect: non-scaling-stroke;
        r: 5px; /* åŠå¾„ */
    }
    .resize-handle:hover {
        fill: var(--primary);
    }
    /* å„æ–¹å‘ã®ã‚«ãƒ¼ã‚½ãƒ« */
    .cursor-nw { cursor: nw-resize; }
    .cursor-ne { cursor: ne-resize; }
    .cursor-sw { cursor: sw-resize; }
    .cursor-se { cursor: se-resize; }

    .margin-guide {
        fill: none;
        stroke: #00bcd4; /* ã‚·ã‚¢ãƒ³ */
        stroke-width: 1px;
        stroke-dasharray: 5 5;
        pointer-events: none;
        vector-effect: non-scaling-stroke;
    }
    
    /* SVGå†…ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ« */
    text {
        user-select: none;
    }
    
    /* ãƒã‚¹ç›®(ã‚°ãƒªãƒƒãƒ‰)ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .grid-line {
        stroke: #b3e5fc; /* è–„ã„é’ */
        stroke-width: 0.5px;
        fill: none;
        pointer-events: none;
        vector-effect: non-scaling-stroke;
    }
    .grid-rect {
        stroke: #b3e5fc;
        stroke-width: 0.5px;
        fill: none;
        pointer-events: none;
        vector-effect: non-scaling-stroke; 
    }
    .grid-dan-border {
        stroke: #81d4fa; /* æ¿ƒã„ã‚ã®é’ */
        stroke-width: 1px;
        fill: none;
        pointer-events: none;
        vector-effect: non-scaling-stroke;
    }
</style>
</head>
<body>

<!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
<div class="toolbar">
    <button class="tool-btn active" id="btn-select" title="é¸æŠ (V)">ğŸ‘†</button>
    <button class="tool-btn" id="btn-text" title="è¨˜äº‹ (T)">T</button>
    <button class="tool-btn" id="btn-rect" title="çŸ©å½¢ (R)">â¬œ</button>
    <div style="flex:1"></div>
    <div style="font-size:10px; color:#666; margin-bottom:5px;">Fit</div>
    <button class="tool-btn" onclick="fitView()" title="å…¨ä½“è¡¨ç¤º (Ctrl+0)" style="font-size:14px;">ğŸ”</button>
</div>

<!-- ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ -->
<div class="viewport" id="viewport">
    <div id="canvas-container">
        <!-- SVGã‚­ãƒ£ãƒ³ãƒã‚¹ -->
        <svg id="main-svg" width="297" height="420" viewBox="0 0 297 420" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <!-- SVGå†…éƒ¨ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾© -->
                <style id="svg-style">
                    .ink-fill { fill: #333333; }
                    .ink-stroke { stroke: #333333; }
                </style>
            </defs>
            <!-- èƒŒæ™¯è‰²ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
            <rect id="paper-bg" x="0" y="0" width="100%" height="100%" fill="#ffffff"></rect>
            
            <!-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
            <g id="layer-paper-grid"></g> <!-- å…¨ä½“ã®åŸç¨¿ç”¨ç´™ã‚°ãƒªãƒƒãƒ‰ -->
            <g id="layer-grid"></g>   <!-- å€‹åˆ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚°ãƒªãƒƒãƒ‰ -->
            <g id="layer-content"></g> <!-- ãƒ†ã‚­ã‚¹ãƒˆã€å›³å½¢ -->
            <g id="layer-ui"></g>      <!-- é¸æŠæ ã€ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ -->
        </svg>
    </div>
</div>

<!-- ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ« -->
<div class="properties">
    <!-- ä½•ã‚‚é¸æŠã—ã¦ã„ãªã„æ™‚ï¼šå…¨ä½“è¨­å®š -->
    <div class="prop-group" id="prop-panel-none">
        
        <!-- ç”¨ç´™ã‚µã‚¤ã‚º -->
        <div class="prop-label">ç”¨ç´™ã‚µã‚¤ã‚º (mm)</div>
        <div class="prop-row">
            <input type="number" id="inp-canvas-w" class="prop-input" value="297" onchange="updateCanvasSize()" title="å¹… (mm)">
            <span style="font-size:12px;">Ã—</span>
            <input type="number" id="inp-canvas-h" class="prop-input" value="420" onchange="updateCanvasSize()" title="é«˜ã• (mm)">
        </div>
        <div class="prop-row">
            <button class="btn-secondary" onclick="setCanvasPreset(210, 297)">A4</button>
            <button class="btn-secondary" onclick="setCanvasPreset(297, 420)">A3</button>
            <button class="btn-secondary" onclick="setCanvasPreset(257, 364)">B4</button>
            <button class="btn-secondary" onclick="swapCanvasSize()" title="ç¸¦æ¨ªå…¥æ›¿">âŸ³</button>
        </div>

        <!-- è‰²è¨­å®š -->
        <div class="prop-label" style="margin-top:15px;">ã‚«ãƒ©ãƒ¼è¨­å®š</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">ç´™ã®è‰²</span>
            <input type="color" id="inp-paper-color" value="#ffffff" onchange="updateColors()" style="height:24px; cursor:pointer;">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">ã‚¤ãƒ³ã‚¯ã®è‰²</span>
            <input type="color" id="inp-ink-color" value="#333333" onchange="updateColors()" style="height:24px; cursor:pointer;">
        </div>

        <!-- ãƒãƒ¼ã‚¸ãƒ³ -->
        <div class="prop-label" style="margin-top:15px;">ãƒãƒ¼ã‚¸ãƒ³ (mm)</div>
        <div class="prop-row">
            <span style="font-size:11px; width:15px;">ä¸Š</span>
            <input type="number" id="inp-margin-t" class="prop-input" value="20" onchange="updateMargins()">
            <span style="font-size:11px; width:15px;">ä¸‹</span>
            <input type="number" id="inp-margin-b" class="prop-input" value="20" onchange="updateMargins()">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; width:15px;">å·¦</span>
            <input type="number" id="inp-margin-l" class="prop-input" value="20" onchange="updateMargins()">
            <span style="font-size:11px; width:15px;">å³</span>
            <input type="number" id="inp-margin-r" class="prop-input" value="20" onchange="updateMargins()">
        </div>

        <!-- ç´™é¢å‰²ã‚Šä»˜ã‘ -->
        <div class="prop-label" style="margin-top:15px; color:#2196f3;">ç´™é¢å‰²ä»˜ (è‡ªå‹•ã‚°ãƒªãƒƒãƒ‰)</div>
        <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee;">
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">ç¸¦ã®æ®µæ•°</span>
                <input type="number" id="inp-layout-dan" class="prop-input" style="flex:0.6" value="6" min="1" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">1æ®µã®æ–‡å­—æ•°(ç¸¦)</span>
                <input type="number" id="inp-layout-chars" class="prop-input" style="flex:0.6" value="11" min="1" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">å…¨ä½“ã®è¡Œæ•°(æ¨ª)</span>
                <input type="number" id="inp-layout-lines" class="prop-input" style="flex:0.6" value="25" min="1" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center;">
                    <input type="checkbox" id="inp-layout-show" checked onchange="updateGridSettings()" style="margin-right:5px;"> ã‚°ãƒªãƒƒãƒ‰ã‚’è¡¨ç¤º
                </label>
            </div>
            <div id="grid-info" style="font-size:10px; color:#666; margin-top:5px;"></div>
            <p style="font-size:10px; color:#2196f3; margin-top:5px;">â€»æ®µé–“ã«1ãƒã‚¹åˆ†ã®ç©ºããŒå…¥ã‚Šã¾ã™</p>
        </div>

        <div class="prop-label" style="margin-top:20px;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</div>
        <button class="btn-primary" onclick="exportCanvas()">ç”»åƒã¨ã—ã¦æ›¸ãå‡ºã—</button>
        <p style="font-size:11px; color:#666; margin-top:5px;">â€»ã‚°ãƒªãƒƒãƒ‰ã¨ã‚¬ã‚¤ãƒ‰ç·šã¯éè¡¨ç¤ºã«ãªã‚Šã¾ã™</p>
    </div>

    <!-- ãƒ†ã‚­ã‚¹ãƒˆé¸æŠæ™‚ -->
    <div class="prop-group" id="prop-panel-text" style="display:none;">
        <div class="prop-label">è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹ç·¨é›†</div>
        <textarea id="inp-text" class="prop-textarea" oninput="updateSelectedText()"></textarea>
        
        <div class="prop-label">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
        <select id="inp-fontfamily" class="prop-select" onchange="updateSelectedStyle()">
            <option value='"BIZ UDMincho", serif'>BIZ UDæ˜æœ (æ¨™æº–)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
            <option value='"Yuji Syuku", serif'>ä½‘å­— å®¿ (ç­†æ–‡å­—)</option>
        </select>

        <div class="prop-row">
            <div style="flex:1">
                <span class="prop-label">ã‚µã‚¤ã‚º(px)</span>
                <input type="number" id="inp-fontsize" class="prop-input" oninput="updateSelectedStyle()">
            </div>
            <div style="flex:1">
                <span class="prop-label">è¡Œé–“(em)</span>
                <input type="number" id="inp-lineheight" class="prop-input" step="0.1" oninput="updateSelectedStyle()">
            </div>
        </div>
        
        <div class="prop-label">æ›¸å­—æ–¹å‘</div>
        <select id="inp-writingmode" class="prop-select" onchange="updateSelectedStyle()">
            <option value="vertical-rl">ç¸¦æ›¸ã</option>
            <option value="horizontal-tb">æ¨ªæ›¸ã</option>
        </select>

        <div class="prop-label" style="margin-top:10px;">è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³</div>
        <label style="display:flex; align-items:center; font-size:14px; cursor:pointer;">
            <input type="checkbox" id="inp-showgrid" onchange="updateSelectedStyle()" style="margin-right:5px;"> å€‹åˆ¥ãƒã‚¹ç›®
        </label>
        
        <button class="btn-primary" style="background:#e53935; margin-top:20px;" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>
</div>

<script>
    // --- å®šæ•° ---
    const PX_PER_MM = 2.834645; // 72dpi ã«ãŠã‘ã‚‹ 1mm ã®ãƒ”ã‚¯ã‚»ãƒ«æ•°
    const CHAR_SCALE_RATIO = 0.85; // æ–‡å­—å¤‰å½¢ç‡ï¼ˆç¸¦85%ï¼‰

    // --- çŠ¶æ…‹ç®¡ç† ---
    const STATE = {
        mode: 'select', 
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹è¨­å®š (A3ç¸¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 297x420)
        canvas: {
            width: 297, 
            height: 420, 
            margin: { top: 20, bottom: 20, left: 20, right: 20 },
            colors: { paper: '#ffffff', ink: '#333333' }
        },

        // ã‚°ãƒªãƒƒãƒ‰è¨­å®š (6æ®µ, 11æ–‡å­—, 25è¡Œ)
        grid: {
            show: true,
            dan: 6,
            charsPerDan: 11,
            totalLines: 25,
            
            // è¨ˆç®—çµæœä¿æŒç”¨
            computed: {
                charSizeW: 0, 
                charSizeH: 0,
                lineGap: 0,
                danHeight: 0,
                danPitch: 0 // æ®µã®é–‹å§‹ä½ç½®ç”¨
            }
        },

        // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆåˆ¶å¾¡ç”¨
        view: { x: 0, y: 0, scale: 1.0 },
        isSpacePressed: false,
        isPanning: false,
        panStart: { x: 0, y: 0 },
        
        selectedId: null,
        isDragging: false,
        isResizing: false,
        resizeDir: null, // nw, ne, sw, se
        dragStart: { x: 0, y: 0 },
        elemStart: { x: 0, y: 0 },
        elements: [] 
    };

    const SVG_NS = "http://www.w3.org/2000/svg";
    const mainSvg = document.getElementById('main-svg');
    const canvasContainer = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const layerPaperGrid = document.getElementById('layer-paper-grid');
    const layerContent = document.getElementById('layer-content');
    const layerUi = document.getElementById('layer-ui');
    const layerGrid = document.getElementById('layer-grid');
    const paperBg = document.getElementById('paper-bg');
    const svgStyle = document.getElementById('svg-style');

    // --- ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆ ---
    document.getElementById('btn-select').onclick = () => setMode('select');
    document.getElementById('btn-text').onclick = () => createTextObject(); 
    document.getElementById('btn-rect').onclick = () => createRectObject();

    function setMode(mode) {
        STATE.mode = mode;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if(mode === 'select') document.getElementById('btn-select').classList.add('active');
        if(mode !== 'select') setTimeout(() => setMode('select'), 200); 
    }

    // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆé–¢æ•° (ã‚¨ãƒ©ãƒ¼å›é¿ã®ãŸã‚æ‰‹å‰ã«å®šç¾©) ---
    function createID() { return 'el_' + Math.random().toString(36).substr(2, 9); }

    function createTextObject() {
        const vw = viewport.clientWidth; const vh = viewport.clientHeight;
        const svgX = (vw/2 - STATE.view.x) / STATE.view.scale;
        const svgY = (vh/2 - STATE.view.y) / STATE.view.scale;
        
        const cGrid = STATE.grid.computed;
        const initFontSize = cGrid.charSizeW > 0 ? cGrid.charSizeW : 24;
        const initLineHeight = cGrid.charSizeW > 0 ? (cGrid.lineGap / cGrid.charSizeW) + 1 : 1.5;

        const id = createID();
        const data = {
            id: id, type: 'text',
            x: Math.round(svgX - 100), y: Math.round(svgY - 150),
            width: 200, height: 300,
            text: "ã“ã“ã«è¨˜äº‹ã‚’å…¥åŠ›\nèƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰ã«\nãƒ”ãƒƒã‚¿ãƒªåˆã„ã¾ã™",
            fontSize: initFontSize, 
            lineHeight: initLineHeight,
            writingMode: 'vertical-rl',
            fontFamily: '"BIZ UDMincho", serif',
            charScale: 85, 
            showGrid: false 
        };
        STATE.elements.push(data);
        renderElement(data);
        selectElement(id);
        setMode('select');
    }

    function createRectObject() {
        const vw = viewport.clientWidth; const vh = viewport.clientHeight;
        const svgX = (vw/2 - STATE.view.x) / STATE.view.scale;
        const svgY = (vh/2 - STATE.view.y) / STATE.view.scale;
        const id = createID();
        const data = {
            id: id, type: 'rect',
            x: Math.round(svgX - 50), y: Math.round(svgY - 50),
            width: 100, height: 100,
            fill: 'none', stroke: STATE.canvas.colors.ink 
        };
        STATE.elements.push(data);
        renderElement(data);
        selectElement(id);
        setMode('select');
    }

    // --- ç”¨ç´™ã‚µã‚¤ã‚º & ãƒãƒ¼ã‚¸ãƒ³åˆ¶å¾¡ ---
    function updateCanvasSize() {
        const w_mm = parseFloat(document.getElementById('inp-canvas-w').value);
        const h_mm = parseFloat(document.getElementById('inp-canvas-h').value);
        if (isNaN(w_mm) || isNaN(h_mm)) return;

        STATE.canvas.width = w_mm;
        STATE.canvas.height = h_mm;

        const w_px = Math.round(w_mm * PX_PER_MM);
        const h_px = Math.round(h_mm * PX_PER_MM);

        mainSvg.setAttribute('width', w_px);
        mainSvg.setAttribute('height', h_px);
        mainSvg.setAttribute('viewBox', `0 0 ${w_px} ${h_px}`);
        
        updateMargins();
    }

    function updateMargins() {
        STATE.canvas.margin.top = parseFloat(document.getElementById('inp-margin-t').value) || 0;
        STATE.canvas.margin.bottom = parseFloat(document.getElementById('inp-margin-b').value) || 0;
        STATE.canvas.margin.left = parseFloat(document.getElementById('inp-margin-l').value) || 0;
        STATE.canvas.margin.right = parseFloat(document.getElementById('inp-margin-r').value) || 0;

        renderMarginGuide();
        updateGridSettings(); 
    }

    function updateColors() {
        const paperC = document.getElementById('inp-paper-color').value;
        const inkC = document.getElementById('inp-ink-color').value;
        
        STATE.canvas.colors.paper = paperC;
        STATE.canvas.colors.ink = inkC;

        paperBg.setAttribute('fill', paperC);

        svgStyle.textContent = `
            .ink-fill { fill: ${inkC}; }
            .ink-stroke { stroke: ${inkC}; }
            text { fill: ${inkC}; }
        `;
    }

    function updateGridSettings() {
        STATE.grid.show = document.getElementById('inp-layout-show').checked;
        STATE.grid.dan = parseInt(document.getElementById('inp-layout-dan').value) || 1;
        STATE.grid.charsPerDan = parseInt(document.getElementById('inp-layout-chars').value) || 1;
        STATE.grid.totalLines = parseInt(document.getElementById('inp-layout-lines').value) || 1;

        renderPaperGrid();
        
        // æ—¢å­˜ã®ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æ–°ã—ã„ã‚°ãƒªãƒƒãƒ‰è¨­å®šã«åŒæœŸã•ã›ã‚‹
        syncAllTextElements();
    }

    function renderMarginGuide() {
        const oldGuide = document.getElementById('margin-guide-rect');
        if (oldGuide) oldGuide.remove();

        const w_px = STATE.canvas.width * PX_PER_MM;
        const h_px = STATE.canvas.height * PX_PER_MM;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const mb = STATE.canvas.margin.bottom * PX_PER_MM;
        const ml = STATE.canvas.margin.left * PX_PER_MM;
        const mr = STATE.canvas.margin.right * PX_PER_MM;

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.id = 'margin-guide-rect';
        rect.setAttribute('x', ml);
        rect.setAttribute('y', mt);
        rect.setAttribute('width', Math.max(0, w_px - ml - mr));
        rect.setAttribute('height', Math.max(0, h_px - mt - mb));
        rect.setAttribute('class', 'margin-guide');
        
        layerUi.appendChild(rect);
    }

    // --- å…¨ä½“ã‚°ãƒªãƒƒãƒ‰æç”» & è¨ˆç®— ---
    function renderPaperGrid() {
        layerPaperGrid.innerHTML = ''; 
        
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const mb = STATE.canvas.margin.bottom * PX_PER_MM;
        const ml = STATE.canvas.margin.left * PX_PER_MM;
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        
        const w_px = STATE.canvas.width * PX_PER_MM;
        const h_px = STATE.canvas.height * PX_PER_MM;
        
        const validW = w_px - ml - mr;
        const validH = h_px - mt - mb;

        const danCount = STATE.grid.dan;
        const charsPerDan = STATE.grid.charsPerDan; 
        const totalLines = STATE.grid.totalLines;

        // ã€é«˜ã•è¨ˆç®—ï¼ˆæ®µé–“ã‚ã‚Šï¼‰ã€‘
        const totalHUnits = (charsPerDan * danCount) + (danCount - 1);
        const cellHeight = validH / totalHUnits; 
        const danPitch = (charsPerDan * cellHeight) + cellHeight;

        // æœ¬æ¥ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º(å¹…)
        const fontSizeW = cellHeight / CHAR_SCALE_RATIO;
        
        // æ¨ªæ–¹å‘: è¡Œé–“è¨ˆç®—
        const totalCharW = fontSizeW * totalLines;
        let lineGap = 0;
        if (totalLines > 1) {
            lineGap = (validW - totalCharW) / (totalLines - 1);
        }

        STATE.grid.computed.charSizeW = fontSizeW;
        STATE.grid.computed.charSizeH = cellHeight;
        STATE.grid.computed.lineGap = lineGap;
        STATE.grid.computed.danHeight = cellHeight * charsPerDan;
        STATE.grid.computed.danPitch = danPitch;

        const fontSizeMm = (fontSizeW / PX_PER_MM).toFixed(2);
        const gapMm = (lineGap / PX_PER_MM).toFixed(2);
        document.getElementById('grid-info').innerHTML = 
            `ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º: ${fontSizeMm}mm / è¡Œé–“: ${gapMm}mm`;

        if (!STATE.grid.show) return;

        // ã‚°ãƒªãƒƒãƒ‰æç”»
        for (let l = 0; l < totalLines; l++) {
            const lineX = (w_px - mr) - fontSizeW - (l * (fontSizeW + lineGap));
            
            for (let d = 0; d < danCount; d++) {
                const startY = mt + (d * danPitch);
                for (let c = 0; c < charsPerDan; c++) {
                    const charY = startY + (c * cellHeight);
                    const rect = document.createElementNS(SVG_NS, 'rect');
                    rect.setAttribute('x', lineX);
                    rect.setAttribute('y', charY);
                    rect.setAttribute('width', fontSizeW);
                    rect.setAttribute('height', cellHeight);
                    rect.setAttribute('class', 'grid-rect');
                    layerPaperGrid.appendChild(rect);
                }
            }
        }
        
        for (let d = 0; d < danCount - 1; d++) {
            const y = mt + (d * danPitch) + (charsPerDan * cellHeight) + (cellHeight / 2);
            const line = document.createElementNS(SVG_NS, 'line');
            line.setAttribute('x1', ml);
            line.setAttribute('y1', y);
            line.setAttribute('x2', w_px - mr);
            line.setAttribute('y2', y);
            line.setAttribute('class', 'grid-dan-border');
            layerPaperGrid.appendChild(line);
        }
    }

    function syncAllTextElements() {
        const cGrid = STATE.grid.computed;
        if (cGrid.charSizeW <= 0) return;

        const newFontSize = cGrid.charSizeW;
        const newLineHeight = (cGrid.charSizeW + cGrid.lineGap) / cGrid.charSizeW;

        STATE.elements.forEach(data => {
            if (data.type === 'text') {
                data.fontSize = newFontSize;
                data.lineHeight = newLineHeight;
                data.writingMode = 'vertical-rl';
                data.charScale = 85;
                renderElement(data);
            }
        });
        renderUi(); 
    }

    // --- ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° (Data -> SVG DOM) ---
    function renderElement(data) {
        let group = document.getElementById(data.id);
        if (!group) {
            group = document.createElementNS(SVG_NS, 'g');
            group.id = data.id;
            group.addEventListener('mousedown', (e) => onElemMouseDown(e, data.id));
            layerContent.appendChild(group);
        }

        const scaleVal = (data.charScale || 85) / 100;
        
        if (data.type === 'text') {
            if (data.writingMode === 'vertical-rl') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y}) scale(1, ${scaleVal})`);
            } else {
                group.setAttribute('transform', `translate(${data.x}, ${data.y}) scale(${scaleVal}, 1)`);
            }
        } else {
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);
        }

        group.innerHTML = '';
        
        if (data.type === 'text') {
            const effW = data.writingMode === 'vertical-rl' ? data.width : data.width / scaleVal;
            const effH = data.writingMode === 'vertical-rl' ? data.height / scaleVal : data.height;

            const textEl = document.createElementNS(SVG_NS, 'text');
            textEl.setAttribute('font-family', data.fontFamily);
            textEl.setAttribute('font-size', data.fontSize);
            textEl.setAttribute('writing-mode', data.writingMode);
            textEl.setAttribute('dominant-baseline', 'central'); 
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('class', 'ink-fill'); 
            textEl.style.fontFamily = data.fontFamily;
            
            const lines = data.text.split('\n');
            const lh = data.fontSize * data.lineHeight; 

            lines.forEach((lineText, i) => {
                const chars = lineText.split('');
                chars.forEach((char, j) => {
                    const tspan = document.createElementNS(SVG_NS, 'tspan');
                    tspan.textContent = char;
                    if (data.writingMode === 'vertical-rl') {
                        const centerX = effW - (i * lh) - (lh / 2);
                        const centerY = (j * data.fontSize) + (data.fontSize / 2);
                        tspan.setAttribute('x', centerX); tspan.setAttribute('y', centerY);
                    } else {
                        const centerY = (i * lh) + (lh / 2);
                        const centerX = (j * data.fontSize) + (data.fontSize / 2);
                        tspan.setAttribute('x', centerX); tspan.setAttribute('y', centerY);
                    }
                    textEl.appendChild(tspan);
                });
            });
            group.appendChild(textEl);

            if (data.showGrid) {
                const gridGroup = document.createElementNS(SVG_NS, 'g');
                gridGroup.style.pointerEvents = 'none';
                
                if (data.writingMode === 'vertical-rl') {
                    const pitchX = data.fontSize * data.lineHeight;
                    const cols = Math.floor(effW / pitchX);
                    const rows = Math.floor(effH / data.fontSize);
                    for (let c = 0; c < cols; c++) {
                        const centerX = effW - (c * pitchX) - (pitchX / 2);
                        const cellX = centerX - (data.fontSize / 2);
                        for (let r = 0; r < rows; r++) {
                            const centerY = (r * data.fontSize) + (data.fontSize / 2);
                            const cellY = centerY - (data.fontSize / 2);
                            const rect = document.createElementNS(SVG_NS, 'rect');
                            rect.setAttribute('x', cellX); rect.setAttribute('y', cellY);
                            rect.setAttribute('width', data.fontSize); rect.setAttribute('height', data.fontSize);
                            rect.setAttribute('class', 'grid-rect');
                            rect.setAttribute('vector-effect', 'non-scaling-stroke');
                            gridGroup.appendChild(rect);
                        }
                    }
                }
                group.prepend(gridGroup);
            }

        } else if (data.type === 'rect') {
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', 0); rect.setAttribute('y', 0);
            rect.setAttribute('width', data.width); 
            rect.setAttribute('height', data.height);
            rect.setAttribute('fill', data.fill); 
            rect.setAttribute('stroke', STATE.canvas.colors.ink); 
            rect.setAttribute('class', 'ink-stroke'); 
            group.appendChild(rect);
        }
    }

    // --- UIå‡¦ç† ---
    function renderUi() {
        layerUi.innerHTML = ''; 
        renderMarginGuide();

        if (!STATE.selectedId) {
            document.getElementById('prop-panel-none').style.display = 'block';
            document.getElementById('prop-panel-text').style.display = 'none';
            return;
        }

        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if (!data) return;

        document.getElementById('prop-panel-none').style.display = 'none';
        if (data.type === 'text') {
            document.getElementById('prop-panel-text').style.display = 'block';
            if (document.activeElement.id !== 'inp-text') document.getElementById('inp-text').value = data.text;
            document.getElementById('inp-fontsize').value = data.fontSize;
            document.getElementById('inp-lineheight').value = data.lineHeight;
            document.getElementById('inp-writingmode').value = data.writingMode;
            document.getElementById('inp-fontfamily').value = data.fontFamily || '"BIZ UDMincho", serif';
            document.getElementById('inp-showgrid').checked = data.showGrid || false;
        }

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
        rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
        rect.setAttribute('class', 'selection-rect');
        layerUi.appendChild(rect);
        
        // 4éš…ã®ãƒãƒ³ãƒ‰ãƒ«ä½œæˆ
        createHandle(data.x, data.y, 'nw');
        createHandle(data.x + data.width, data.y, 'ne');
        createHandle(data.x, data.y + data.height, 'sw');
        createHandle(data.x + data.width, data.y + data.height, 'se');
    }

    function createHandle(x, y, dir) {
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('class', `resize-handle cursor-${dir}`);
        circle.addEventListener('mousedown', (e) => onHandleMouseDown(e, dir));
        layerUi.appendChild(circle);
    }

    function selectElement(id) {
        STATE.selectedId = id;
        renderUi();
    }
    
    function deleteSelected() {
        if (!STATE.selectedId) return;
        document.getElementById(STATE.selectedId).remove(); 
        STATE.elements = STATE.elements.filter(e => e.id !== STATE.selectedId);
        STATE.selectedId = null;
        renderUi();
    }

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© ---
    function getSvgPoint(e) {
        const vpRect = viewport.getBoundingClientRect();
        const vx = e.clientX - vpRect.left - STATE.view.x;
        const vy = e.clientY - vpRect.top - STATE.view.y;
        return { x: vx / STATE.view.scale, y: vy / STATE.view.scale };
    }

    function onElemMouseDown(e, id) {
        if (STATE.isSpacePressed) return;
        e.stopPropagation();
        selectElement(id);
        STATE.isDragging = true;
        const pt = getSvgPoint(e);
        STATE.dragStart = { x: pt.x, y: pt.y };
        const data = STATE.elements.find(el => el.id === id);
        STATE.elemStart = { x: data.x, y: data.y };
    }

    function onHandleMouseDown(e, dir) {
        if (STATE.isSpacePressed) return;
        e.stopPropagation();
        STATE.isResizing = true;
        STATE.resizeDir = dir;
        const pt = getSvgPoint(e);
        STATE.dragStart = { x: pt.x, y: pt.y };
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        STATE.elemStart = { x: data.x, y: data.y, w: data.width, h: data.height };
    }

    mainSvg.addEventListener('mousedown', (e) => {
        if (STATE.isSpacePressed) return;
        if (e.target === mainSvg) {
            STATE.selectedId = null;
            renderUi();
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (STATE.isPanning) {
            STATE.view.x = STATE.viewStart.x + (e.clientX - STATE.panStart.x);
            STATE.view.y = STATE.viewStart.y + (e.clientY - STATE.panStart.y);
            updateTransform();
            return;
        }
        
        const pt = getSvgPoint(e);
        const dx = pt.x - STATE.dragStart.x;
        const dy = pt.y - STATE.dragStart.y;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);

        if (STATE.isDragging && data) {
            let newX = STATE.elemStart.x + dx;
            let newY = STATE.elemStart.y + dy;
            
            // ç§»å‹•ã‚¹ãƒŠãƒƒãƒ—
            if (data.type === 'text' && data.writingMode === 'vertical-rl') {
                const cGrid = STATE.grid.computed;
                if (cGrid.charSizeW > 0) {
                    const mr = STATE.canvas.margin.right * PX_PER_MM;
                    const w_px = STATE.canvas.width * PX_PER_MM;
                    const rightEdge = w_px - mr;
                    const pitchX = cGrid.charSizeW + cGrid.lineGap;
                    
                    const currentRight = newX + data.width;
                    const colIndex = Math.round((rightEdge - currentRight) / pitchX);
                    const snappedRight = rightEdge - (colIndex * pitchX);
                    newX = snappedRight - data.width;

                    const mt = STATE.canvas.margin.top * PX_PER_MM;
                    const rowIndex = Math.round((newY - mt) / cGrid.charSizeH);
                    newY = mt + (rowIndex * cGrid.charSizeH);
                }
            }
            data.x = newX;
            data.y = newY;
            renderElement(data);
            renderUi();

        } else if (STATE.isResizing && data) {
            const dir = STATE.resizeDir;
            let newX = STATE.elemStart.x;
            let newY = STATE.elemStart.y;
            let newW = STATE.elemStart.w;
            let newH = STATE.elemStart.h;

            if (dir.includes('e')) newW = Math.max(10, STATE.elemStart.w + dx);
            if (dir.includes('s')) newH = Math.max(10, STATE.elemStart.h + dy);
            if (dir.includes('w')) {
                const w = Math.max(10, STATE.elemStart.w - dx);
                newX = STATE.elemStart.x + (STATE.elemStart.w - w);
                newW = w;
            }
            if (dir.includes('n')) {
                const h = Math.max(10, STATE.elemStart.h - dy);
                newY = STATE.elemStart.y + (STATE.elemStart.h - h);
                newH = h;
            }

            // ãƒªã‚µã‚¤ã‚ºã‚¹ãƒŠãƒƒãƒ—
            if (data.type === 'text' && data.writingMode === 'vertical-rl') {
                const cGrid = STATE.grid.computed;
                if (cGrid.charSizeW > 0) {
                    const mr = STATE.canvas.margin.right * PX_PER_MM;
                    const w_px = STATE.canvas.width * PX_PER_MM;
                    const rightEdge = w_px - mr;
                    const pitchX = cGrid.charSizeW + cGrid.lineGap;
                    const mt = STATE.canvas.margin.top * PX_PER_MM;

                    if (dir.includes('w')) {
                        const currentRight = newX + newW;
                        const colN = Math.round((rightEdge - cGrid.charSizeW - newX) / pitchX);
                        const snappedX = rightEdge - (colN * pitchX) - cGrid.charSizeW;
                        newW = currentRight - snappedX;
                        newX = snappedX;
                    }
                    if (dir.includes('e')) {
                        const currentLeft = newX;
                        const currentRight = newX + newW;
                        const colN = Math.round((rightEdge - currentRight) / pitchX);
                        const snappedRight = rightEdge - (colN * pitchX);
                        newW = snappedRight - currentLeft;
                    }
                    if (dir.includes('n')) {
                        const currentBottom = newY + newH;
                        const rowN = Math.round((newY - mt) / cGrid.charSizeH);
                        const snappedY = mt + (rowN * cGrid.charSizeH);
                        newH = currentBottom - snappedY;
                        newY = snappedY;
                    }
                    if (dir.includes('s')) {
                        const currentTop = newY;
                        const currentBottom = newY + newH;
                        const rowN = Math.round((currentBottom - mt) / cGrid.charSizeH);
                        const snappedBottom = mt + (rowN * cGrid.charSizeH);
                        newH = snappedBottom - currentTop;
                    }
                }
            }

            if(newW < 10) newW = 10;
            if(newH < 10) newH = 10;

            data.x = newX; data.y = newY;
            data.width = newW; data.height = newH;
            renderElement(data);
            renderUi();
        }
    });
    window.addEventListener('mouseup', () => {
        STATE.isPanning = false; 
        STATE.isDragging = false; 
        STATE.isResizing = false;
    });

    function updateSelectedText() {
        if (!STATE.selectedId) return;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        data.text = document.getElementById('inp-text').value;
        renderElement(data);
    }
    function updateSelectedStyle() {
        if (!STATE.selectedId) return;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        data.fontSize = parseInt(document.getElementById('inp-fontsize').value);
        data.lineHeight = parseFloat(document.getElementById('inp-lineheight').value);
        data.writingMode = document.getElementById('inp-writingmode').value;
        data.fontFamily = document.getElementById('inp-fontfamily').value;
        data.showGrid = document.getElementById('inp-showgrid').checked;
        renderElement(data);
        renderUi(); 
    }

    async function exportCanvas() {
        layerUi.style.display = 'none';
        layerPaperGrid.style.display = 'none'; 
        
        const currentW = parseFloat(mainSvg.getAttribute('width'));
        const currentH = parseFloat(mainSvg.getAttribute('height'));
        const svgData = new XMLSerializer().serializeToString(mainSvg);
        
        const fontCssUrl = 'https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block';
        let cssContent = '';
        try {
            const res = await fetch(fontCssUrl);
            cssContent = await res.text();
        } catch(e) { console.warn(e); }

        const styleTag = `<style>${cssContent} text { font-family: "BIZ UDMincho", serif; }</style>`;
        const finalSvg = svgData.replace('<defs>', `<defs>${styleTag}`);

        const blob = new Blob([finalSvg], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const scale = 4;
            canvas.width = currentW * scale; 
            canvas.height = currentH * scale;
            const ctx = canvas.getContext('2d');
            ctx.scale(scale, scale);
            ctx.drawImage(img, 0, 0);
            
            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = 'newspaper_export.png';
            a.click();
            URL.revokeObjectURL(url);
            
            layerUi.style.display = 'block';
            layerPaperGrid.style.display = 'block';
        };
        img.src = url;
    }

    function setCanvasPreset(w, h) {
        document.getElementById('inp-canvas-w').value = w;
        document.getElementById('inp-canvas-h').value = h;
        updateCanvasSize();
        fitView();
    }
    
    function swapCanvasSize() {
        const wInput = document.getElementById('inp-canvas-w');
        const hInput = document.getElementById('inp-canvas-h');
        const temp = wInput.value;
        wInput.value = hInput.value;
        hInput.value = temp;
        updateCanvasSize();
    }

    function updateTransform() {
        canvasContainer.style.transform = `translate(${STATE.view.x}px, ${STATE.view.y}px) scale(${STATE.view.scale})`;
    }

    function fitView() {
        const vw = viewport.clientWidth;
        const vh = viewport.clientHeight;
        const sw = parseFloat(mainSvg.getAttribute('width')) || 595;
        const sh = parseFloat(mainSvg.getAttribute('height')) || 842;
        const margin = 40;
        const scale = Math.min((vw - margin*2) / sw, (vh - margin*2) / sh);
        STATE.view.scale = Math.max(0.1, Math.min(scale, 5.0));
        STATE.view.x = (vw - sw * STATE.view.scale) / 2;
        STATE.view.y = (vh - sh * STATE.view.scale) / 2;
        updateTransform();
    }

    window.addEventListener('load', () => {
        updateCanvasSize(); 
        updateGridSettings(); 
        updateColors(); 
        fitView();
    });

    window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
        if (e.code === 'Space' && !STATE.isSpacePressed) {
            STATE.isSpacePressed = true;
            viewport.classList.add('hand-mode');
        }
        if ((e.key === 'Delete' || e.key === 'Backspace') && STATE.selectedId) deleteSelected();
        if (!e.ctrlKey && !e.metaKey && !STATE.isSpacePressed) {
            if (e.key === 'v') setMode('select');
            if (e.key === 't') createTextObject();
            if (e.key === 'r') createRectObject();
            if (e.key === '0' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); fitView(); }
        }
    });
    window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            STATE.isSpacePressed = false;
            STATE.isPanning = false;
            viewport.classList.remove('hand-mode');
        }
    });
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.altKey || e.ctrlKey) {
            const zoomFactor = 0.05;
            const delta = -Math.sign(e.deltaY);
            let newScale = STATE.view.scale * (1 + delta * zoomFactor);
            newScale = Math.max(0.1, Math.min(newScale, 10.0));
            const rect = viewport.getBoundingClientRect();
            const offsetX = (e.clientX - rect.left) - STATE.view.x;
            const offsetY = (e.clientY - rect.top) - STATE.view.y;
            STATE.view.x -= offsetX * (newScale / STATE.view.scale - 1);
            STATE.view.y -= offsetY * (newScale / STATE.view.scale - 1);
            STATE.view.scale = newScale;
        } else {
            STATE.view.x -= e.deltaX;
            STATE.view.y -= e.deltaY;
        }
        updateTransform();
    }, { passive: false });
    viewport.addEventListener('mousedown', (e) => {
        if (STATE.isSpacePressed || e.button === 1) {
            e.preventDefault();
            STATE.isPanning = true;
            STATE.panStart = { x: e.clientX, y: e.clientY };
            STATE.viewStart = { x: STATE.view.x, y: STATE.view.y };
        }
    });
    window.addEventListener('mousemove', (e) => {
        if (STATE.isPanning) {
            STATE.view.x = STATE.viewStart.x + (e.clientX - STATE.panStart.x);
            STATE.view.y = STATE.viewStart.y + (e.clientY - STATE.panStart.y);
            updateTransform();
            return;
        }
    });
    window.addEventListener('mouseup', () => {
        STATE.isPanning = false; 
        STATE.isDragging = false; 
        STATE.isResizing = false;
    });
</script>
</body>
</html>