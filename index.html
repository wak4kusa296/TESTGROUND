<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SVG Newspaper Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block"
        rel="stylesheet">

    <style>
        :root {
            --ui-bg: #DDDDDD;
            --panel-bg: #FFFFFF;
            --border-col: #DDDDDD;
            --primary: #333333;
            --accent: #333333;
            --masthead: #161616;
            --link-col: #333333;
            --text: #333333;
        }

        body {
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            font-family: "Noto Sans JP", sans-serif;
            background: var(--ui-bg);
            color: var(--text);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* 左サイドバー */
        .toolbar {
            width: 50px;
            height: 100vh;
            position: sticky;
            top: 0;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-col);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            z-index: 100;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .toolbar::-webkit-scrollbar {
            width: 4px;
        }

        .toolbar::-webkit-scrollbar-thumb {
            background: var(--border-col);
            border-radius: 2px;
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            margin-bottom: 8px;
            border: 1px solid var(--border-col);
            background: var(--panel-bg);
            cursor: pointer;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2px;
            font-size: 18px;
            transition: background 0.2s;
            position: relative;
            filter: grayscale(100%);
        }

        .tool-btn:hover {
            background: var(--ui-bg);
        }

        .tool-btn.active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
            filter: grayscale(0%);
        }

        .tool-btn.active.btn-heading {
            background: var(--accent);
            border-color: var(--accent);
        }

        .tool-btn.active.btn-masthead {
            background: var(--masthead);
            border-color: var(--masthead);
        }

        .tool-label {
            font-size: 8px;
            line-height: 1;
            font-weight: 500;
        }

        /* メインエリア */
        .viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--ui-bg);
            background-image: none;
            background-size: 20px 20px;
            cursor: default;
            touch-action: none;
        }

        .viewport.mode-create {
            cursor: crosshair;
        }

        .viewport.mode-hand {
            cursor: grab;
        }

        .viewport.mode-hand:active {
            cursor: grabbing;
        }

        /* SVG用紙コンテナ */
        #canvas-container {
            transform-origin: 0 0;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* SVG用紙 */
        #main-svg {
            background: transparent;
            display: block;
            shape-rendering: geometricPrecision;
            text-rendering: geometricPrecision;
            overflow: visible;
        }

        /* 右サイドバー */
        .properties {
            width: 280px;
            background: var(--panel-bg);
            border-left: 1px solid var(--border-col);
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
        }

        .prop-group {
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }

        .prop-group:last-child {
            border-bottom: none;
        }

        .prop-label {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
            color: #555;
        }

        .prop-row {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            align-items: center;
        }

        .prop-input,
        .prop-select,
        .prop-textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 6px;
            border: 1px solid var(--border-col);
            margin-bottom: 8px;
            font-size: 14px;
            font-family: inherit;
            user-select: text;
            -webkit-user-select: text;
        }

        .prop-textarea {
            resize: vertical;
            min-height: 100px;
        }

        /* スライダー */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            margin: 0;
            vertical-align: middle;
            cursor: pointer;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            margin-top: -6px;
            border: 2px solid #fff;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
        }

        .heading-slider::-webkit-slider-thumb {
            background: var(--accent);
        }

        .masthead-slider::-webkit-slider-thumb {
            background: var(--masthead);
        }

        .btn-primary {
            width: 100%;
            padding: 8px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-primary:hover {
            opacity: 0.9;
        }

        .btn-delete {
            background: #e53935;
            margin-top: 20px;
        }

        .btn-secondary {
            flex: 1;
            padding: 6px;
            background: #f0f0f0;
            color: #333;
            border: 1px solid var(--border-col);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        /* UIスタイル */
        .selection-rect {
            fill: none;
            stroke: var(--primary);
            stroke-width: 2px;
            stroke-dasharray: 4 2;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }

        .selection-rect.heading-select {
            stroke: var(--accent);
        }

        .selection-rect.masthead-select {
            stroke: var(--masthead);
        }

        .creation-preview-rect {
            fill: rgba(33, 150, 243, 0.2);
            stroke: var(--primary);
            stroke-width: 1px;
            stroke-dasharray: 4 2;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }

        /* ハンドル */
        .handle-group {
            cursor: pointer;
        }

        .resize-handle-visual {
            fill: white;
            stroke: var(--primary);
            stroke-width: 2px;
            vector-effect: non-scaling-stroke;
            pointer-events: none;
        }

        .resize-handle-hit {
            fill: #ffffff;
            fill-opacity: 0;
            cursor: pointer;
            pointer-events: all;
        }

        .handle-group:hover .resize-handle-visual {
            fill: var(--primary);
        }

        .handle-group.heading-handle .resize-handle-visual {
            stroke: var(--accent);
        }

        .handle-group.heading-handle:hover .resize-handle-visual {
            fill: var(--accent);
        }

        .handle-group.masthead-handle .resize-handle-visual {
            stroke: var(--masthead);
        }

        .handle-group.masthead-handle:hover .resize-handle-visual {
            fill: var(--masthead);
        }

        /* リンクハンドル (四角) */
        .link-handle-rect {
            fill: #fff;
            stroke: var(--link-col);
            stroke-width: 2px;
            cursor: pointer;
            vector-effect: non-scaling-stroke;
        }

        .link-handle-rect.connected {
            fill: var(--link-col);
        }

        .link-handle-hit {
            fill: transparent;
            cursor: pointer;
            pointer-events: all;
        }

        .link-line-preview {
            stroke: var(--link-col);
            stroke-width: 2px;
            stroke-dasharray: 4 2;
            fill: none;
            pointer-events: none;
        }

        .cursor-nw {
            cursor: nw-resize;
        }

        .cursor-ne {
            cursor: ne-resize;
        }

        .cursor-sw {
            cursor: sw-resize;
        }

        .cursor-se {
            cursor: se-resize;
        }

        .margin-guide {
            fill: none;
            stroke: #00bcd4;
            stroke-width: 1px;
            stroke-dasharray: 5 5;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }

        /* 選択モードは通常のカーソル */
        .viewport.mode-select {
            cursor: default;
        }

        text {
            user-select: none;
            pointer-events: none;
        }

        .grid-line,
        .grid-rect {
            stroke: #b3e5fc;
            stroke-width: 0.5px;
            fill: none;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }

        .hit-rect {
            fill: #ffffff;
            fill-opacity: 0;
            cursor: move;
            pointer-events: all;
        }

        /* 色制御用クラス */
        .ink-fill {
            fill: #333;
        }

        .ink-stroke {
            stroke: #333;
        }

        .paper-fill {
            fill: #fff;
        }

        .paper-stroke {
            stroke: #fff;
        }

        /* リンク接続候補（ドラッグ開始時に枠線だけ表示） */
        .link-candidate .hit-rect {
            stroke: var(--link-col);
            stroke-width: 2px;
            stroke-dasharray: 4 4;
            fill: none;
            /* 塗りつぶしなし */
        }

        /* リンク接続対象（ホバー時・強調） */
        .highlight-target .hit-rect {
            stroke: var(--link-col);
            stroke-width: 3px;
            stroke-dasharray: 4 4;
            fill: rgba(156, 39, 176, 0.2) !important;
            fill-opacity: 1 !important;
        }

        /* 自由テキスト揃え位置ボタン */
        .align-btn-group {
            display: flex;
            gap: 6px;
            flex-wrap: nowrap;
            margin-bottom: 8px;
            justify-content: space-between;
        }

        /* 3x3グリッド配置ボタン */
        .align-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-bottom: 8px;
        }

        .align-grid-btn {
            aspect-ratio: 1;
            border: 1px solid #666;
            background: #fff;
            cursor: pointer;
            border-radius: 3px;
            padding: 0;
            min-height: 32px;
            transition: all 0.2s;
        }

        .align-grid-btn:hover {
            background: #f0f0f0;
            border-color: #333;
        }

        .align-grid-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }

        #freetext-align-cross.direction-vertical {
            flex-direction: row-reverse;
        }

        .align-btn {
            flex: 1;
            min-width: 80px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            padding: 8px 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: 0.2s;
        }

        .align-btn span {
            line-height: 1;
        }

        .align-btn:hover {
            background: #f0f0f0;
        }

        .align-btn--active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
        }

        .color-toggle-row {
            display: flex;
            gap: 8px;
        }

        .color-toggle-btn {
            flex: 1;
            padding: 6px 0;
            border: 1px solid var(--border-col);
            background: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }

        .color-toggle-btn.active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
        }

        .align-btn .label-vertical,
        .align-btn .label-horizontal {
            display: none;
        }

        .align-btn-group.direction-vertical .label-vertical {
            display: inline;
        }

        .align-btn-group.direction-horizontal .label-horizontal {
            display: inline;
        }

        /* ローディング画面 */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--ui-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            transition: opacity 0.3s ease-out;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
        }

        .loading-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 16px;
            color: var(--masthead);
            letter-spacing: 0.05em;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--border-col);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 16px;
            color: var(--text);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .loading-subtext {
            font-size: 12px;
            color: #999;
        }

        /* オートセーブインジケーター */
        #autosave-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            background: #333333;
            color: #FFFFFF;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #autosave-indicator.show {
            opacity: 1;
        }

        #autosave-indicator.error {
            background: #161616;
        }

        .autosave-icon {
            width: 14px;
            height: 14px;
            animation: rotate 1s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* 右上の操作ボタングループ（ツールバーの右隣） */
        .top-right-controls {
            position: fixed;
            top: 10px;
            left: 70px; /* ツールバー(50px) + 余白(20px) */
            display: flex;
            gap: 8px;
            z-index: 10000;
        }

        .control-btn {
            padding: 8px 16px;
            background: var(--panel-bg);
            border: 1px solid var(--border-col);
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            user-select: none;
        }

        .control-btn:hover {
            background: var(--ui-bg);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .control-btn.ipad-mode-active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .control-btn.ipad-mode-active:hover {
            background: #45a049;
        }
    </style>
</head>

<body>

    <!-- オートセーブインジケーター -->
    <div id="autosave-indicator">
        <svg class="autosave-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            <path d="M9 12l2 2 4-4"/>
        </svg>
        <span id="autosave-text">保存中...</span>
    </div>

    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-title" role="heading" aria-level="1">新聞制作ツール</div>
            <div class="loading-spinner"></div>
            <div class="loading-text">読み込み中...</div>
            <div class="loading-subtext">フォントデータを準備しています</div>
        </div>
    </div>

    <!-- 右上の操作ボタングループ -->
    <div class="top-right-controls">
        <button class="control-btn" id="btn-undo" title="元に戻す (Ctrl+Z)" onclick="undo()">↶ 戻る</button>
        <button class="control-btn" id="btn-redo" title="やり直す (Ctrl+Y)" onclick="redo()">↷ やり直す</button>
        <button class="control-btn" id="btn-ipad-mode" title="iPad対応モード" onclick="toggleIpadMode()">📱 iPad対応</button>
    </div>

    <div class="toolbar">
        <button class="tool-btn active" id="btn-select" title="選択 (V)" onclick="setMode('select')">▲<span
                class="tool-label">選択</span></button>
        <button class="tool-btn" id="btn-hand" title="ハンド (H)" onclick="setMode('hand')">✋<span
                class="tool-label">ハンド</span></button>
        <button class="tool-btn" id="btn-text" title="記事 (T)" onclick="setMode('text')">T<span
                class="tool-label">記事</span></button>
        <button class="tool-btn" id="btn-freetext" title="自由テキスト (F)" onclick="setMode('freetext')">A<span
                class="tool-label">自由</span></button>
        <button class="tool-btn btn-heading" id="btn-heading" title="見出し (H)" onclick="setMode('heading')">H<span
                class="tool-label">見出</span></button>
        <button class="tool-btn btn-masthead" id="btn-masthead" title="題字 (M)" onclick="setMode('masthead')">題<span
                class="tool-label">題字</span></button>
        <button class="tool-btn" id="btn-rect" title="塗りつぶし (R)" onclick="setMode('rect')">■<span
                class="tool-label">塗潰</span></button>
        <button class="tool-btn" id="btn-vline" title="縦線 (V)" onclick="setMode('vline')">|<span
                class="tool-label">縦線</span></button>
        <button class="tool-btn" id="btn-image" title="画像 (I)" onclick="setMode('image')">🖼<span
                class="tool-label">画像</span></button>
        <div style="flex:1"></div>
        <button class="tool-btn" onclick="exportCanvas()" title="画像として書き出し">📤<span class="tool-label">書出</span></button>
        <button class="tool-btn" onclick="newProject()" title="新規作成">📄<span class="tool-label">新規</span></button>
        <button class="tool-btn" onclick="openProjectFile()" title="開く">📂<span class="tool-label">開く</span></button>
        <button class="tool-btn" onclick="saveProject()" title="保存">💾<span class="tool-label">保存</span></button>
        <button class="tool-btn" onclick="fitView()" title="全体表示">🔍</button>
    </div>

    <div class="viewport" id="viewport">
        <div id="canvas-container">
            <svg id="main-svg" width="297" height="420" viewBox="0 0 297 420" xmlns="http://www.w3.org/2000/svg"
                overflow="visible">
                <defs>
                    <style id="svg-style">
                        .hit-rect {
                            fill: #ffffff;
                            fill-opacity: 0;
                            pointer-events: all;
                        }

                        .ink-fill {
                            fill: #333333;
                        }

                        .ink-stroke {
                            stroke: #333333;
                        }

                        .paper-fill {
                            fill: #ffffff;
                        }

                        .paper-stroke {
                            stroke: #ffffff;
                        }

                        text {
                            fill: #333333;
                        }
                    </style>
                </defs>
                <rect id="paper-bg" class="paper-fill" x="0" y="0" width="100%" height="100%"></rect>

                <!-- レイヤー順序: グリッド < 段間罫線 < コンテンツ < UI < 枠線 -->
                <g id="layer-paper-grid"></g>
                <g id="layer-dan-lines"></g>
                <g id="layer-content"></g>
                <g id="layer-ui"></g>
                <g id="layer-border"></g>
            </svg>
        </div>
    </div>

    <div class="properties">
        <!-- 設定パネル: 未選択 -->
        <div class="prop-group" id="prop-panel-none">
            <div class="prop-label">用紙サイズ (mm)</div>
            <div class="prop-row">
                <input type="number" id="inp-canvas-w" class="prop-input" value="297" onchange="updateCanvasSize()">
                <span>×</span>
                <input type="number" id="inp-canvas-h" class="prop-input" value="420" onchange="updateCanvasSize()">
            </div>
            <div class="prop-row">
                <button class="btn-secondary" onclick="setCanvasPreset(210, 297)">A4</button>
                <button class="btn-secondary" onclick="setCanvasPreset(297, 420)">A3</button>
                <button class="btn-secondary" onclick="swapCanvasSize()">縦横入替</button>
            </div>

            <div class="prop-label" style="margin-top:15px;">カラー設定</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">紙の色</span>
                <input type="color" id="inp-paper-color" value="#ffffff" oninput="updateColors()" style="height:24px;">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">インクの色</span>
                <input type="color" id="inp-ink-color" value="#333333" oninput="updateColors()" style="height:24px;">
            </div>

            <div class="prop-label" style="margin-top:15px;">余白 (mm)</div>
            <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee; margin-bottom:10px;">
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">上</span>
                    <input type="number" id="inp-margin-t" class="prop-input" style="flex:0.6" value="20" oninput="updateCanvasSize()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">下</span>
                    <input type="number" id="inp-margin-b" class="prop-input" style="flex:0.6" value="20" oninput="updateCanvasSize()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">左</span>
                    <input type="number" id="inp-margin-l" class="prop-input" style="flex:0.6" value="20" oninput="updateCanvasSize()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">右</span>
                    <input type="number" id="inp-margin-r" class="prop-input" style="flex:0.6" value="20" oninput="updateCanvasSize()">
                </div>
            </div>

            <div class="prop-label" style="margin-top:15px; color:#2196f3;">紙面割付</div>
            <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee;">
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">縦の段数</span>
                    <input type="number" id="inp-layout-dan" class="prop-input" style="flex:0.6" value="6"
                        onchange="updateGridSettings()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">1段の文字数</span>
                    <input type="number" id="inp-layout-chars" class="prop-input" style="flex:0.6" value="11"
                        onchange="updateGridSettings()">
                </div>
                <div class="prop-row">
                    <span style="font-size:11px; flex:1;">全体の行数</span>
                    <input type="number" id="inp-layout-lines" class="prop-input" style="flex:0.6" value="25"
                        onchange="updateGridSettings()">
                </div>
                <div class="prop-row">
                    <label style="font-size:11px; display:flex; align-items:center;">
                        <input type="checkbox" id="inp-layout-show" checked onchange="updateGridSettings()"
                            style="margin-right:5px;"> グリッド表示
                    </label>
                </div>
                <div id="grid-info" style="font-size:10px; color:#666; margin-top:5px;"></div>
            </div>

            <div class="prop-label" style="margin-top:15px;">記事ボックス設定</div>
            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="inp-snap-article" checked onchange="updateSnapMode()"
                        style="margin-right:5px;"> 記事配置モード (段スナップ)
                </label>
            </div>

            <div class="prop-label" style="margin-top:15px; color:#2196f3;">ヘッダーテキスト</div>
            <div
                style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee; margin-bottom:15px;">
                <!-- 左ヘッダー -->
                <div style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #ddd;">
                    <div style="font-size:11px; font-weight:bold; margin-bottom:5px; color:#666;">左揃え</div>
                    <input type="text" id="inp-header-left-text" class="prop-input" value="20XX年（令和X年）XX月XX日"
                        placeholder="左側のテキスト" oninput="updateHeaderText('left')" style="margin-bottom:5px;">
                    <div class="prop-row">
                        <select id="inp-header-left-font" class="prop-select" onchange="updateHeaderFont('left')"
                            style="flex:2; margin-bottom:0;">
                            <option value='"Noto Sans JP", sans-serif' selected>Noto Sans JP</option>
                            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                            <option value='"BIZ UDMincho", serif'>BIZ UDMincho</option>
                            <option value='"Yuji Syuku", serif'>Yuji Syuku</option>
                        </select>
                        <select id="inp-header-left-weight" class="prop-select" onchange="updateHeaderWeight('left')"
                            style="flex:1; margin-bottom:0;">
                            <option value="400">標準</option>
                            <option value="700" selected>太字</option>
                            <option value="900">極太</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span style="font-size:10px; flex:0.6;">サイズ</span>
                        <input type="number" id="inp-header-left-size" class="prop-input" value="4" min="1" max="20"
                            step="0.5" onchange="updateHeaderSize('left')" style="flex:1; margin-bottom:0;">
                        <span style="font-size:10px; flex:0.6;">字間</span>
                        <input type="number" id="inp-header-left-spacing" class="prop-input" value="0" min="-2" max="10"
                            step="0.1" onchange="updateHeaderSpacing('left')" style="flex:1; margin-bottom:0;">
                    </div>
                </div>

                <!-- 中央ヘッダー -->
                <div style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #ddd;">
                    <div style="font-size:11px; font-weight:bold; margin-bottom:5px; color:#666;">中央揃え</div>
                    <input type="text" id="inp-header-center-text" class="prop-input" value="空想新聞" placeholder="中央のテキスト"
                        oninput="updateHeaderText('center')" style="margin-bottom:5px;">
                    <div class="prop-row">
                        <select id="inp-header-center-font" class="prop-select" onchange="updateHeaderFont('center')"
                            style="flex:2; margin-bottom:0;">
                            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
                            <option value='"Noto Serif JP", serif' selected>Noto Serif JP</option>
                            <option value='"BIZ UDMincho", serif'>BIZ UDMincho</option>
                            <option value='"Yuji Syuku", serif'>Yuji Syuku</option>
                        </select>
                        <select id="inp-header-center-weight" class="prop-select"
                            onchange="updateHeaderWeight('center')" style="flex:1; margin-bottom:0;">
                            <option value="400">標準</option>
                            <option value="700">太字</option>
                            <option value="900" selected>極太</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span style="font-size:10px; flex:0.6;">サイズ</span>
                        <input type="number" id="inp-header-center-size" class="prop-input" value="6" min="1" max="20"
                            step="0.5" onchange="updateHeaderSize('center')" style="flex:1; margin-bottom:0;">
                        <span style="font-size:10px; flex:0.6;">字間</span>
                        <input type="number" id="inp-header-center-spacing" class="prop-input" value="10" min="-2"
                            max="20" step="0.1" onchange="updateHeaderSpacing('center')"
                            style="flex:1; margin-bottom:0;">
                    </div>
                </div>

                <!-- 右ヘッダー -->
                <div>
                    <div style="font-size:11px; font-weight:bold; margin-bottom:5px; color:#666;">右揃え</div>
                    <input type="text" id="inp-header-right-text" class="prop-input" value="○○について深く知る。"
                        placeholder="右側のテキスト" oninput="updateHeaderText('right')" style="margin-bottom:5px;">
                    <div class="prop-row">
                        <select id="inp-header-right-font" class="prop-select" onchange="updateHeaderFont('right')"
                            style="flex:2; margin-bottom:0;">
                            <option value='"Noto Sans JP", sans-serif' selected>Noto Sans JP</option>
                            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                            <option value='"BIZ UDMincho", serif'>BIZ UDMincho</option>
                            <option value='"Yuji Syuku", serif'>Yuji Syuku</option>
                        </select>
                        <select id="inp-header-right-weight" class="prop-select" onchange="updateHeaderWeight('right')"
                            style="flex:1; margin-bottom:0;">
                            <option value="400" selected>標準</option>
                            <option value="700">太字</option>
                            <option value="900">極太</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span style="font-size:10px; flex:0.6;">サイズ</span>
                        <input type="number" id="inp-header-right-size" class="prop-input" value="4" min="1" max="20"
                            step="0.5" onchange="updateHeaderSize('right')" style="flex:1; margin-bottom:0;">
                        <span style="font-size:10px; flex:0.6;">字間</span>
                        <input type="number" id="inp-header-right-spacing" class="prop-input" value="0" min="-2"
                            max="10" step="0.1" onchange="updateHeaderSpacing('right')"
                            style="flex:1; margin-bottom:0;">
                    </div>
                </div>
            </div>

            <div class="prop-label" style="margin-top:20px;">エクスポート</div>
            <button class="btn-primary" id="btn-export" onclick="exportCanvas()">画像として書き出し</button>
        </div>

        <!-- 設定パネル: 記事 -->
        <div class="prop-group" id="prop-panel-text" style="display:none;">
            <div class="prop-label">記事ボックス編集</div>
            <textarea id="inp-text" class="prop-textarea" oninput="updateSelectedText()"></textarea>

            <div id="text-char-info" style="font-size:11px; color:#666; margin-top:5px; margin-bottom:10px;">
                現在: <span id="char-current">0</span>文字 /
                最大: <span id="char-capacity">0</span>文字 /
                あふれ: <span id="char-overflow" style="color:#f44336;">0</span>文字
            </div>

            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center; cursor:pointer; width:100%;">
                    <input type="checkbox" id="inp-snap-article-txt" checked onchange="updateSnapMode()"
                        style="margin-right:5px;"> 記事配置モード (段スナップ)
                </label>
            </div>

            <div class="prop-label">フォント設定</div>
            <select id="inp-fontfamily" class="prop-select" onchange="updateSelectedStyle()">
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UD明朝 標準)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (佑字 宿 筆文字)</option>
            </select>
            <div style="font-size:11px; color:#777; margin-bottom:10px;">
                表示中のフォントは Google Fonts での正式名称 (BIZ UDMincho / Yuji Syuku) をそのまま記載しています。
            </div>

            <div id="text-link-info" style="font-size:11px; color:#9c27b0; margin-bottom:10px; display:none;">
                ※このボックスはリンク接続されています。<br>文字は前のボックスから流し込まれます。
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>

        <!-- 設定パネル: 見出し -->
        <div class="prop-group" id="prop-panel-heading" style="display:none;">
            <div class="prop-label" style="color:var(--accent);">見出し編集</div>
            <input type="text" id="inp-heading-text" class="prop-input" oninput="updateHeadingProp('text')">

            <div class="prop-row" style="margin-top:10px;">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="checkbox" id="inp-heading-inverted" onchange="updateHeadingProp('inverted')"
                        style="margin-right:5px;"> 白黒反転 (座布団)
                </label>
            </div>

            <div class="prop-label" style="margin-top:10px;">フォント設定</div>
            <select id="inp-heading-font" class="prop-select" onchange="updateHeadingProp('fontFamily')">
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP (ゴシック)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP (明朝)</option>
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UD明朝)</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (佑字 宿)</option>
            </select>
            <div class="prop-label">余白設定 (mm)</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">左右</span>
                <input type="range" id="inp-heading-ph-slider" class="heading-slider" min="0" max="50" step="0.5"
                    value="5" oninput="updateHeadingProp('padding', 'h', this.value)" style="flex:2;">
                <input type="number" id="inp-heading-ph" class="prop-input" style="flex:0.8; margin-bottom:0;" value="5"
                    onchange="updateHeadingProp('padding', 'h', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">天地</span>
                <input type="range" id="inp-heading-pv-slider" class="heading-slider" min="0" max="50" step="0.5"
                    value="5" oninput="updateHeadingProp('padding', 'v', this.value)" style="flex:2;">
                <input type="number" id="inp-heading-pv" class="prop-input" style="flex:0.8; margin-bottom:0;" value="5"
                    onchange="updateHeadingProp('padding', 'v', this.value)">
            </div>
            <div style="font-size:11px; color:#666; margin-top:10px;">
                ※左右に行間分の紙色シャドウがつきます。<br>
                ※文字は常時最大太さ(900)で表示されます。
            </div>
            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>

        <!-- 設定パネル: 題字 -->
        <div class="prop-group" id="prop-panel-masthead" style="display:none;">
            <div class="prop-label" style="color:var(--masthead);">題字編集</div>
            <input type="text" id="inp-masthead-text" class="prop-input" value="空想新聞"
                oninput="updateMastheadProp('text')">

            <div class="prop-row" style="margin-top:10px;">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="checkbox" id="inp-masthead-inverted" onchange="updateMastheadProp('inverted')"
                        style="margin-right:5px;"> 文字色反転 (白抜き)
                </label>
            </div>

            <div class="prop-label" style="margin-top:10px;">デザイン設定 (mm)</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">外枠の太さ</span>
                <input type="range" id="inp-masthead-bo-slider" class="masthead-slider" min="0.5" max="5.0" step="0.1"
                    value="1.0" oninput="updateMastheadProp('borderWidthOuter', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-bo" class="prop-input" style="flex:0.8;" value="1.0"
                    onchange="updateMastheadProp('borderWidthOuter', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">内枠の太さ</span>
                <input type="range" id="inp-masthead-bi-slider" class="masthead-slider" min="0.1" max="3.0" step="0.1"
                    value="0.3" oninput="updateMastheadProp('borderWidthInner', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-bi" class="prop-input" style="flex:0.8;" value="0.3"
                    onchange="updateMastheadProp('borderWidthInner', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">地紋線の太さ</span>
                <input type="range" id="inp-masthead-pl-slider" class="masthead-slider" min="0.1" max="1.0" step="0.1"
                    value="0.4" oninput="updateMastheadProp('patternLineHeight', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-pl" class="prop-input" style="flex:0.8;" value="0.4"
                    onchange="updateMastheadProp('patternLineHeight', this.value)">
            </div>

            <div class="prop-row">
                <span style="font-size:11px; flex:1;">文字縁取り</span>
                <input type="range" id="inp-masthead-ts-slider" class="masthead-slider" min="0" max="4" step="0.5"
                    value="2" oninput="updateMastheadProp('textStrokeWidth', this.value)" style="flex:1.5;">
                <input type="number" id="inp-masthead-ts" class="prop-input" style="flex:0.8;" min="0" max="4" step="0.5" value="2"
                    onchange="updateMastheadProp('textStrokeWidth', this.value)">
            </div>

            <div class="prop-label">余白設定 (mm)</div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">左右</span>
                <input type="range" id="inp-masthead-ph-slider" class="masthead-slider" min="0" max="50" step="0.5"
                    value="0" oninput="updateMastheadProp('paddingH', this.value)" style="flex:2;">
                <input type="number" id="inp-masthead-ph" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0" onchange="updateMastheadProp('paddingH', this.value)">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">天地</span>
                <input type="range" id="inp-masthead-pv-slider" class="masthead-slider" min="0" max="50" step="0.5"
                    value="0" oninput="updateMastheadProp('paddingV', this.value)" style="flex:2;">
                <input type="number" id="inp-masthead-pv" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0" onchange="updateMastheadProp('paddingV', this.value)">
            </div>

            <div class="prop-label">フォント設定</div>
            <select id="inp-masthead-font" class="prop-select" onchange="updateMastheadProp('fontFamily')">
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UD明朝 標準)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP (明朝)</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (佑字 宿 筆文字)</option>
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP (ゴシック)</option>
            </select>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>

        <!-- 設定パネル: 塗りつぶし -->
        <div class="prop-group" id="prop-panel-rect" style="display:none;">
            <div class="prop-label">塗りつぶし設定</div>
            <div class="prop-row">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="checkbox" id="inp-rect-ink" onchange="updateRectProp()"> インク色で塗りつぶす
                </label>
            </div>
            <div style="font-size:11px; color:#666; margin-bottom:10px;">
                ※OFFの場合は紙色で塗りつぶされます。
            </div>

            <div class="prop-label">枠線設定</div>
            <select id="inp-rect-border-style" class="prop-select" onchange="updateRectProp()">
                <option value="none">なし</option>
                <option value="solid">実線</option>
                <option value="dotted">点線</option>
                <option value="double">二重線</option>
            </select>

            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">太さ(mm)</span>
                <input type="range" id="inp-rect-border-w-slider" min="0.1" max="3.0" step="0.1" value="0.5"
                    oninput="updateRectProp('width', this.value)" style="flex:2;">
                <input type="number" id="inp-rect-border-w" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0.5" onchange="updateRectProp('width', this.value)">
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px;">
                ※枠線は内側に描画されます。インク塗りつぶし時は塗りつぶしが1mm内側に配置され、枠線は白抜きになります。
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>

        <!-- 設定パネル: 縦線 -->
        <div class="prop-group" id="prop-panel-vline" style="display:none;">
            <div class="prop-label">縦線設定</div>

            <div class="prop-row">
                <span style="font-size:11px; flex:0.8;">太さ(mm)</span>
                <input type="range" id="inp-vline-width-slider" min="0.1" max="5.0" step="0.1" value="0.5"
                    oninput="updateVlineProp(this.value)" style="flex:2;">
                <input type="number" id="inp-vline-width" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="0.5" onchange="updateVlineProp(this.value)">
            </div>
            <div style="font-size:11px; color:#666; margin-top:5px;">
                ※縦線はボックスの左右中央にインク色で描画されます。
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>

        <div class="prop-group" id="prop-panel-image" style="display:none;">
            <div class="prop-label">画像設定</div>
            <div class="prop-row" style="flex-direction: column; gap: 8px;">
                <input type="file" id="inp-image-file" accept="image/*" onchange="loadImageFile(this)"
                    style="font-size: 11px;">
                <div id="image-info" style="font-size:11px; color:#666;"></div>
            </div>

            <div class="prop-label" style="margin-top: 15px;">カラーモード</div>
            <select id="inp-image-colormode" class="prop-input" onchange="updateImageProp('colorMode')">
                <option value="fullcolor">フルカラー</option>
                <option value="ink">インクモード（全体設定の色を使用）</option>
            </select>

            <div id="image-ink-settings" style="display:none; margin-top:10px;">
                <div class="prop-label">コントラスト</div>
                <input type="range" id="inp-image-contrast" class="prop-input" min="0" max="200" value="100"
                    oninput="updateImageProp('contrast')">
                <span id="label-image-contrast" style="font-size:11px;">100</span>

                <div class="prop-label" style="margin-top:10px;">明るさ</div>
                <input type="range" id="inp-image-brightness" class="prop-input" min="0" max="200" value="100"
                    oninput="updateImageProp('brightness')">
                <span id="label-image-brightness" style="font-size:11px;">100</span>
            </div>

            <div class="prop-label" style="margin-top: 15px;">トリミング</div>
            <button class="btn-primary" id="btn-crop-mode" onclick="toggleCropMode()"
                style="margin-bottom: 10px;">トリミング調整</button>
            <div style="font-size:11px; color:#666; margin-bottom:10px;">
                ※ボタンを押すと画像上で直接ドラッグしてトリミングできます
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>

        <div class="prop-group" id="prop-panel-freetext" style="display:none;">
            <div class="prop-label">自由テキスト編集</div>
            <textarea id="inp-freetext" class="prop-input" oninput="updateFreeTextProp('text')"
                style="min-height:80px; resize:vertical;"></textarea>

            <div class="prop-label" style="margin-top:10px;">文字方向</div>
            <div class="prop-row">
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="radio" name="freetext-direction" value="vertical"
                        onchange="updateFreeTextProp('direction')" style="margin-right:5px;"> 縦書き
                </label>
                <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                    <input type="radio" name="freetext-direction" value="horizontal"
                        onchange="updateFreeTextProp('direction')" style="margin-right:5px;"> 横書き
                </label>
            </div>

            <div class="prop-label" style="margin-top:10px;">配置</div>
            <div class="align-grid" id="freetext-align-grid">
                <!-- 左上 -->
                <button type="button" class="align-grid-btn" data-align="top-left" onclick="setFreetextAlign('top-left')">■</button>
                <!-- 中上 -->
                <button type="button" class="align-grid-btn" data-align="top-center" onclick="setFreetextAlign('top-center')">■</button>
                <!-- 右上 -->
                <button type="button" class="align-grid-btn" data-align="top-right" onclick="setFreetextAlign('top-right')">■</button>
                <!-- 左中 -->
                <button type="button" class="align-grid-btn" data-align="middle-left" onclick="setFreetextAlign('middle-left')">■</button>
                <!-- 中央 -->
                <button type="button" class="align-grid-btn" data-align="middle-center" onclick="setFreetextAlign('middle-center')">■</button>
                <!-- 右中 -->
                <button type="button" class="align-grid-btn" data-align="middle-right" onclick="setFreetextAlign('middle-right')">■</button>
                <!-- 左下 -->
                <button type="button" class="align-grid-btn" data-align="bottom-left" onclick="setFreetextAlign('bottom-left')">■</button>
                <!-- 中下 -->
                <button type="button" class="align-grid-btn" data-align="bottom-center" onclick="setFreetextAlign('bottom-center')">■</button>
                <!-- 右下 -->
                <button type="button" class="align-grid-btn" data-align="bottom-right" onclick="setFreetextAlign('bottom-right')">■</button>
            </div>
            <div id="freetext-align-hint" style="font-size:11px; color:#666; margin-top:4px;">
                ボタンの位置 = テキストの配置位置
            </div>

            <div class="prop-label" style="margin-top:10px;">フォント設定</div>
            <select id="inp-freetext-font" class="prop-select" onchange="updateFreeTextProp('fontFamily')">
                <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UD明朝 標準)</option>
                <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
                <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
                <option value='"Yuji Syuku", serif'>Yuji Syuku (佑字 宿 筆文字)</option>
            </select>

            <div class="prop-label" style="margin-top:10px;">文字サイズ (mm)</div>
            <div class="prop-row">
                <input type="range" id="inp-freetext-size-slider" min="2" max="50" step="0.5" value="4"
                    oninput="updateFreeTextProp('fontSize')" style="flex:2;">
                <input type="number" id="inp-freetext-size" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="4" onchange="updateFreeTextProp('fontSize')">
            </div>

            <div class="prop-label" style="margin-top:10px;">太さ</div>
            <div class="prop-row">
                <input type="range" id="inp-freetext-weight-slider" min="200" max="900" step="100" value="400"
                    oninput="updateFreeTextProp('fontWeight')" style="flex:2;">
                <input type="number" id="inp-freetext-weight" class="prop-input" style="flex:0.8; margin-bottom:0;"
                    value="400" min="200" max="900" step="100" onchange="updateFreeTextProp('fontWeight')">
            </div>

            <div class="prop-label" style="margin-top:10px;">文字色</div>
            <div class="prop-row color-toggle-row">
                <button type="button" class="color-toggle-btn" data-color-source="ink"
                    onclick="updateFreeTextProp('colorSource', 'ink')">インク</button>
                <button type="button" class="color-toggle-btn" data-color-source="paper"
                    onclick="updateFreeTextProp('colorSource', 'paper')">紙色</button>
            </div>

            <button class="btn-primary btn-delete" onclick="deleteSelected()">削除</button>
        </div>
    </div>

    <script>
        const PX_PER_MM = 2.834645;
        const CHAR_SCALE_RATIO = 0.85;
        const LEADING_FULLWIDTH_SPACE = '　';

        const STATE = {
            mode: 'select',
            articleSnapMode: true,
            ipadMode: false, // iPad対応モード
            canvas: { width: 297, height: 420, margin: { top: 20, bottom: 20, left: 20, right: 20 }, colors: { paper: '#ffffff', ink: '#333333' } },
            grid: { show: true, dan: 6, charsPerDan: 11, totalLines: 25, computed: { charSizeW: 0, charSizeH: 0, lineGap: 0, danHeight: 0, danPitch: 0, pitchX: 0 } },
            view: { x: 0, y: 0, scale: 1.0 },
            activePointerId: null, interactionType: null, selectedId: null, resizeDir: null,
            pointerStart: { x: 0, y: 0 }, elemStart: { x: 0, y: 0, w: 0, h: 0 }, viewStart: { x: 0, y: 0, scale: 1 },
            touchStartDist: 0, pinchStartCanvas: { x: 0, y: 0 }, resizeAnchor: { x: 0, y: 0 },
            elements: [],
            linking: null, // { sourceId, lineEl }
            cropMode: false, // トリミングモード
            cropEdge: null, // ドラッグ中のトリミング辺
            // Undo/Redo履歴管理
            history: [],
            historyIndex: -1,
            // ヘッダーテキスト設定
            header: {
                left: { text: '20XX年（令和X年）XX月XX日', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 700, letterSpacing: 0 },
                center: { text: '空想新聞', fontFamily: '"Noto Serif JP", serif', fontSize: 6, fontWeight: 900, letterSpacing: 10 },
                right: { text: '○○について深く知る。', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 400, letterSpacing: 0 }
            }
        };

        const SVG_NS = "http://www.w3.org/2000/svg";
        const mainSvg = document.getElementById('main-svg');
        const canvasContainer = document.getElementById('canvas-container');
        const viewport = document.getElementById('viewport');
        const layerPaperGrid = document.getElementById('layer-paper-grid');
        const layerContent = document.getElementById('layer-content');
        const layerUi = document.getElementById('layer-ui');
        const svgStyle = document.getElementById('svg-style');

        function ensureLeadingFullwidthSpace(value) {
            if (typeof value !== 'string' || value.trim() === '') {
                return value;
            }
            if (value.startsWith(LEADING_FULLWIDTH_SPACE)) {
                return value;
            }
            return LEADING_FULLWIDTH_SPACE + value;
        }

        function ensureLeadingFullwidthSpacePerLine(value) {
            if (typeof value !== 'string') return LEADING_FULLWIDTH_SPACE;
            return value.split('\n').map(line => ensureLeadingFullwidthSpace(line)).join('\n');
        }
    
        function normalizeTextElements(list) {
            if (!Array.isArray(list)) return;
            list.forEach(el => {
                if (el && el.type === 'text') {
                    el.text = ensureLeadingFullwidthSpacePerLine(el.text);
                }
            });
        }
    
        function enforceTextareaLeadingSpace(textarea) {
            if (!textarea) return ensureLeadingFullwidthSpacePerLine("");
            const rawValue = textarea.value || "";
            const normalized = ensureLeadingFullwidthSpacePerLine(rawValue);
            if (normalized !== rawValue) {
                const selectionStart = textarea.selectionStart;
                const selectionEnd = textarea.selectionEnd;
                textarea.value = normalized;
                if (typeof selectionStart === 'number' && typeof selectionEnd === 'number') {
                    const delta = normalized.length - rawValue.length;
                    const newStart = Math.max(selectionStart + delta, 1);
                    const newEnd = Math.max(selectionEnd + delta, 1);
                    textarea.setSelectionRange(newStart, newEnd);
                }
            }
            return normalized;
        }

        // Init Events
        viewport.addEventListener('pointerdown', onPointerDown);
        viewport.addEventListener('pointermove', onPointerMove);
        viewport.addEventListener('pointerup', onPointerUp);
        viewport.addEventListener('pointercancel', onPointerUp);
        viewport.addEventListener('touchstart', onTouchStart, { passive: false });
        viewport.addEventListener('touchmove', onTouchMove, { passive: false });
        viewport.addEventListener('touchend', onTouchEnd);
        viewport.addEventListener('wheel', onWheel, { passive: false });

        // --- Handlers ---
        function onPointerDown(e) {
            if (!e.isPrimary) return;
            if (STATE.touchStartDist > 0) return;

            STATE.activePointerId = e.pointerId;
            STATE.pointerStart = { x: e.clientX, y: e.clientY };
            STATE.viewStart = { ...STATE.view };

            const target = e.target;
            const pt = getSvgPoint(e.clientX, e.clientY);

            // 0. Link Handle Interaction
            if (target.classList.contains('link-handle-hit')) {
                e.preventDefault();
                const sourceId = STATE.selectedId;
                if (!sourceId) return;
                const data = STATE.elements.find(el => el.id === sourceId);

                if (data.next) {
                    disconnectBlock(sourceId);
                    return;
                }

                STATE.interactionType = 'linking';
                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', data.x + data.width / 2);
                line.setAttribute('y1', data.y + data.height);
                line.setAttribute('x2', pt.x);
                line.setAttribute('y2', pt.y);
                line.setAttribute('class', 'link-line-preview');
                layerUi.appendChild(line);
                STATE.linking = { sourceId: sourceId, lineEl: line };

                showLinkCandidates(sourceId);
                viewport.setPointerCapture(e.pointerId);
                return;
            }

            // 1. Resize Handle
            if (target.classList.contains('resize-handle-hit') || target.parentNode.classList.contains('handle-group')) {
                e.preventDefault();
                const group = target.classList.contains('handle-group') ? target : target.parentNode;
                group.setPointerCapture(e.pointerId);
                STATE.interactionType = 'resize';

                const classes = group.getAttribute('class');
                if (classes.includes('cursor-nw')) STATE.resizeDir = 'nw';
                if (classes.includes('cursor-ne')) STATE.resizeDir = 'ne';
                if (classes.includes('cursor-sw')) STATE.resizeDir = 'sw';
                if (classes.includes('cursor-se')) STATE.resizeDir = 'se';

                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                STATE.elemStart = { x: data.x, y: data.y, w: data.width, h: data.height };

                if (STATE.resizeDir === 'nw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y + data.height };
                if (STATE.resizeDir === 'ne') STATE.resizeAnchor = { x: data.x, y: data.y + data.height };
                if (STATE.resizeDir === 'sw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y };
                if (STATE.resizeDir === 'se') STATE.resizeAnchor = { x: data.x, y: data.y };
                return;
            }

            // 1.5 Image Scale Handle Hit
            if (target.classList.contains('image-scale-handle')) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);
                STATE.interactionType = 'image-scale';
                STATE.scaleCorner = target.getAttribute('data-scale-corner');
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                STATE.elemStart = {
                    scale: data.imageScale || 1.0,
                    offsetX: data.imageOffsetX || 0,
                    offsetY: data.imageOffsetY || 0
                };
                return;
            }

            // 1.6 Image Drag Area Hit
            if (target.classList.contains('image-drag-area')) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);
                STATE.interactionType = 'image-drag';
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                STATE.elemStart = {
                    offsetX: data.imageOffsetX || 0,
                    offsetY: data.imageOffsetY || 0
                };
                return;
            }

            // 2. Element Hit Logic
            let hitElementId = null;
            if (target.classList.contains('hit-rect')) {
                // hit-rectの親要素のIDを取得。親がIDを持たない場合は、さらに親を探す
                let parent = target.parentNode;
                while (parent && !parent.id && parent !== layerContent) {
                    parent = parent.parentNode;
                }
                hitElementId = parent ? parent.id : null;
            }

            // ハンドモードの場合は常にpan
            if (STATE.mode === 'hand') {
                e.preventDefault();
                if (STATE.selectedId) {
                    STATE.selectedId = null;
                    renderUi();
                }
                STATE.interactionType = 'pan';
                viewport.setPointerCapture(e.pointerId);
                return;
            }

            if (hitElementId) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);

                // クロップモード中は画像を移動
                const data = STATE.elements.find(el => el.id === hitElementId);
                if (!data) {
                    STATE.selectedId = hitElementId;
                    STATE.interactionType = 'drag';
                    renderUi();
                    return;
                }
                if (STATE.cropMode && data.type === 'image') {
                    STATE.selectedId = hitElementId;
                    STATE.interactionType = 'image-drag';
                    STATE.elemStart = {
                        offsetX: data.imageOffsetX || 0,
                        offsetY: data.imageOffsetY || 0
                    };
                    renderUi();
                    return;
                }

                // 既に選択されている要素の場合のみドラッグ可能
                if (STATE.selectedId === hitElementId) {
                    STATE.interactionType = 'drag';
                    STATE.elemStart = { x: data.x, y: data.y };
                    renderUi();
                } else {
                    // 未選択の要素の場合
                    if (STATE.mode === 'select') {
                        // Select mode: 一旦クリック判定として保留、ドラッグされたらドラッグ開始
                        STATE.pendingSelection = hitElementId;
                        STATE.interactionType = 'pending-or-drag';
                        STATE.elemStart = { x: data.x, y: data.y };
                    } else {
                        // Other modes: ドラッグされた場合は新規要素作成として扱う
                        STATE.pendingSelection = hitElementId;
                        STATE.interactionType = 'pending-or-create';
                        STATE.elemStart = { x: pt.x, y: pt.y };
                    }
                }
            } else {
                // 3. Create new element (only if not in select mode)
                if (STATE.mode === 'select') {
                    // Select mode: deselect if clicking empty space
                    e.preventDefault();
                    if (STATE.selectedId) {
                        STATE.selectedId = null;
                        renderUi();
                    }
                } else {
                    // Other modes: create new element
                    e.preventDefault();
                    if (STATE.selectedId) {
                        STATE.selectedId = null;
                        renderUi();
                    }
                    viewport.setPointerCapture(e.pointerId);
                    STATE.interactionType = 'create';
                    STATE.elemStart = { x: pt.x, y: pt.y };
                }
            }
        }

        function onPointerMove(e) {
            if (e.pointerId !== STATE.activePointerId) return;
            const pt = getSvgPoint(e.clientX, e.clientY);

            // pending-or-create: 少しでもドラッグされたら新規作成モードに移行
            if (STATE.interactionType === 'pending-or-create') {
                const dx = Math.abs(e.clientX - STATE.pointerStart.x);
                const dy = Math.abs(e.clientY - STATE.pointerStart.y);
                if (dx > 3 || dy > 3) {
                    // ドラッグ判定: 新規要素作成に移行
                    STATE.pendingSelection = null;
                    STATE.interactionType = 'create';
                }
            }

            // pending-or-drag: 少しでもドラッグされたら要素ドラッグに移行
            if (STATE.interactionType === 'pending-or-drag') {
                const dx = Math.abs(e.clientX - STATE.pointerStart.x);
                const dy = Math.abs(e.clientY - STATE.pointerStart.y);
                if (dx > 3 || dy > 3) {
                    // ドラッグ判定: 要素を選択してドラッグ開始
                    STATE.selectedId = STATE.pendingSelection;
                    STATE.pendingSelection = null;
                    STATE.interactionType = 'drag';
                    renderUi();
                }
            }

            if (STATE.interactionType === 'pan') {
                const dx = e.clientX - STATE.pointerStart.x;
                const dy = e.clientY - STATE.pointerStart.y;
                STATE.view.x = STATE.viewStart.x + dx;
                STATE.view.y = STATE.viewStart.y + dy;
                updateTransform();

            } else if (STATE.interactionType === 'linking') {
                if (STATE.linking && STATE.linking.lineEl) {
                    STATE.linking.lineEl.setAttribute('x2', pt.x);
                    STATE.linking.lineEl.setAttribute('y2', pt.y);

                    let targetId = null;
                    for (const el of STATE.elements) {
                        if (el.id === STATE.linking.sourceId) continue;
                        if (el.type !== 'text') continue;
                        if (el.next || el.prev) continue;

                        if (pt.x >= el.x && pt.x <= el.x + el.width && pt.y >= el.y && pt.y <= el.y + el.height) {
                            targetId = el.id;
                            break;
                        }
                    }
                    updateLinkHighlight(targetId);
                }
            } else if (STATE.interactionType === 'drag') {
                const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data) {
                    let newX = STATE.elemStart.x + dx;
                    let newY = STATE.elemStart.y + dy;

                    if ((data.type === 'text' || data.type === 'heading' || data.type === 'rect' || data.type === 'vline' || data.type === 'masthead' || data.type === 'image') && STATE.grid.computed.charSizeW > 0) {
                        newX = getClosestColumnLeftEdge(newX);
                        const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
                        if ((data.type === 'text' || data.type === 'vline') && useSnapMode) {
                            // 移動時もGapに入らないように厳格スナップ
                            newY = snapY_StrictGap(newY);
                        } else {
                            // 画像ボックス・塗りつぶしはマス目スナップ
                            newY = snapY(newY, true);
                        }
                    }

                    data.x = newX; data.y = newY;
                    if (data.type === 'text' || data.type === 'rect') {
                        renderElement(data);
                    } else {
                        updateElementTransform(data);
                    }
                    updateUiPositions(data);
                }

            } else if (STATE.interactionType === 'resize') {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data) {
                    const anchor = STATE.resizeAnchor;
                    let targetX = pt.x; let targetY = pt.y;
                    let effAnchorX = anchor.x;
                    let effAnchorY = anchor.y;

                    const cGrid = STATE.grid.computed;

                    if ((data.type === 'text' || data.type === 'heading' || data.type === 'rect' || data.type === 'vline' || data.type === 'masthead' || data.type === 'image') && cGrid.charSizeW > 0) {

                        if (STATE.resizeDir.includes('e')) {
                            if (targetX >= anchor.x) {
                                effAnchorX = anchor.x; targetX = getClosestColumnRightEdge(targetX);
                            } else {
                                effAnchorX = anchor.x - cGrid.lineGap; targetX = getClosestColumnLeftEdge(targetX);
                            }
                        } else if (STATE.resizeDir.includes('w')) {
                            if (targetX <= anchor.x) {
                                effAnchorX = anchor.x; targetX = getClosestColumnLeftEdge(targetX);
                            } else {
                                effAnchorX = anchor.x + cGrid.lineGap; targetX = getClosestColumnRightEdge(targetX);
                            }
                        } else {
                            targetX = getClosestColumnLeftEdge(data.x);
                        }

                        const gapY = cGrid.danPitch - cGrid.danHeight;
                        const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
                        if (STATE.resizeDir.includes('n')) {
                            if (targetY <= anchor.y) {
                                effAnchorY = anchor.y;
                                // リサイズ(Top)時: 記事・縦線はGap回避、画像・塗りつぶしはマス目スナップ
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap(targetY) : snapY(targetY, true);
                            } else {
                                effAnchorY = anchor.y + gapY;
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap(targetY) : snapY(targetY, false);
                            }
                        } else if (STATE.resizeDir.includes('s')) {
                            if (targetY >= anchor.y) {
                                effAnchorY = anchor.y;
                                // リサイズ(Bottom)時: 記事・縦線は段の下端、画像・塗りつぶしはマス目スナップ
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap_Bottom(targetY) : snapY(targetY, false);
                            } else {
                                effAnchorY = anchor.y - gapY;
                                targetY = ((data.type === 'text' || data.type === 'vline') && useSnapMode) ? snapY_StrictGap_Bottom(targetY) : snapY(targetY, true);
                            }
                        }
                    }

                    let newW = Math.abs(targetX - effAnchorX);
                    let newH = Math.abs(targetY - effAnchorY);
                    let newX = Math.min(targetX, effAnchorX);
                    let newY = Math.min(targetY, effAnchorY);
                    if (newW < 1) newW = 1; if (newH < 1) newH = 1;

                    data.x = newX; data.y = newY; data.width = newW; data.height = newH;

                    if (data.type === 'text') {
                        const head = findChainHead(data);
                        updateTextChain(head);
                        updateUiPositions(data);
                    } else if (data.type === 'image') {
                        // 画像ボックスのリサイズ時、オフセットを調整して余白が見えないようにする
                        if (data._imageAspect) {
                            const boxAspect = data.width / data.height;
                            const imgAspect = data._imageAspect;
                            const scale = data.imageScale || 1.0;
                            let baseW, baseH;
                            if (imgAspect > boxAspect) {
                                baseH = data.height;
                                baseW = baseH * imgAspect;
                            } else {
                                baseW = data.width;
                                baseH = baseW / imgAspect;
                            }

                            const scaledW = baseW * scale;
                            const scaledH = baseH * scale;
                            const maxOffsetX = (scaledW - data.width) / 2;
                            const maxOffsetY = (scaledH - data.height) / 2;

                            // 現在のオフセットを制限内に収める
                            const currentOffsetX = data.imageOffsetX || 0;
                            const currentOffsetY = data.imageOffsetY || 0;
                            data.imageOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, currentOffsetX));
                            data.imageOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, currentOffsetY));
                        }

                        renderElement(data);
                        updateUiPositions(data);
                    } else {
                        if (data.type === 'heading' || data.type === 'masthead' || data.type === 'rect') {
                            renderElement(data); // Re-render for new size
                        } else {
                            updateElementTransform(data);
                        }
                        updateUiPositions(data);
                    }
                }

            } else if (STATE.interactionType === 'crop') {
                // ... (crop code same)
            } else if (STATE.interactionType === 'image-drag') {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'image' && data._imageAspect) {
                    const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                    const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;

                    // カバーフィット基準サイズを計算
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;
                    const scale = data.imageScale || 1.0;
                    let baseW, baseH;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                    }

                    // スケール適用後の画像サイズ
                    const scaledW = baseW * scale;
                    const scaledH = baseH * scale;

                    // オフセットの制限（画像の端がクリップの端に来るまで）
                    const maxOffsetX = (scaledW - data.width) / 2;
                    const maxOffsetY = (scaledH - data.height) / 2;

                    const newOffsetX = STATE.elemStart.offsetX + dx;
                    const newOffsetY = STATE.elemStart.offsetY + dy;

                    data.imageOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, newOffsetX));
                    data.imageOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, newOffsetY));

                    renderElement(data);
                    renderUi();
                }

            } else if (STATE.interactionType === 'image-scale') {
                // ... (image-scale code same)
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'image' && data._imageAspect) {
                    const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                    const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;

                    // カバーフィット基準サイズを計算
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;
                    let baseW, baseH;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                    }

                    // コーナーに応じてスケール計算
                    const corner = STATE.scaleCorner;
                    let scaleChange = 0;

                    if (corner === 'nw') {
                        scaleChange = -(dx + dy) / Math.max(baseW, baseH);
                    } else if (corner === 'ne') {
                        scaleChange = (dx - dy) / Math.max(baseW, baseH);
                    } else if (corner === 'sw') {
                        scaleChange = (-dx + dy) / Math.max(baseW, baseH);
                    } else if (corner === 'se') {
                        scaleChange = (dx + dy) / Math.max(baseW, baseH);
                    }

                    // 画像の短辺がクリップの短辺以上になるように最小スケールを計算
                    const minScaleX = data.width / baseW;
                    const minScaleY = data.height / baseH;
                    const minScale = Math.max(minScaleX, minScaleY, 0.1);

                    // 新しいスケールを適用
                    data.imageScale = Math.max(minScale, Math.min(10, STATE.elemStart.scale + scaleChange));

                    renderElement(data);
                    renderUi();
                }
            } else if (STATE.interactionType === 'create') {
                // ... (create code same)
                // プレビュー要素の準備
                let preview = null;

                if (STATE.mode === 'image') {
                    // 画像モード用のグループプレビュー
                    let previewGroup = document.getElementById('creation-preview-group');
                    if (!previewGroup) {
                        previewGroup = document.createElementNS(SVG_NS, 'g');
                        previewGroup.id = 'creation-preview-group';
                        layerUi.appendChild(previewGroup);
                    }
                    // 単一プレビューがあれば削除
                    const singlePreview = document.getElementById('creation-preview');
                    if (singlePreview) singlePreview.remove();
                } else {
                    // 通常モード: 単一プレビュー要素
                    preview = document.getElementById('creation-preview');
                    if (!preview) {
                        preview = document.createElementNS(SVG_NS, 'rect');
                        preview.id = 'creation-preview';
                        preview.setAttribute('class', 'creation-preview-rect');
                        layerUi.appendChild(preview);
                    }
                    // 不要なグループがあれば削除
                    const group = document.getElementById('creation-preview-group');
                    if (group) group.remove();
                }

                let currentX = pt.x; let currentY = pt.y;
                let effStartX = STATE.elemStart.x;
                let effStartY = STATE.elemStart.y;
                const cGrid = STATE.grid.computed;

                if ((STATE.mode === 'text' || STATE.mode === 'heading' || STATE.mode === 'rect' || STATE.mode === 'vline' || STATE.mode === 'masthead' || STATE.mode === 'image') && cGrid.charSizeW > 0) {
                    // 特殊処理: 記事配置モードのとき
                    if (STATE.articleSnapMode && STATE.mode === 'text') {
                        const startLeftEdge = getClosestColumnLeftEdge(STATE.elemStart.x);
                        const startRightEdge = getClosestColumnRightEdge(STATE.elemStart.x);
                        const currentLeftEdge = getClosestColumnLeftEdge(currentX);
                        const currentRightEdge = getClosestColumnRightEdge(currentX);
                        const leftEdgeCandidate = currentX >= STATE.elemStart.x ? startLeftEdge : currentLeftEdge;
                        const rightEdgeCandidate = currentX >= STATE.elemStart.x ? currentRightEdge : startRightEdge;
                        const leftEdge = Math.min(leftEdgeCandidate, rightEdgeCandidate);
                        const rightEdge = Math.max(leftEdgeCandidate, rightEdgeCandidate);
                        const rawTop = Math.min(STATE.elemStart.y, currentY);
                        const rawBottom = Math.max(STATE.elemStart.y, currentY);
                        const snappedTop = snapY_DanTop(rawTop);
                        const snappedBottom = snapY_DanBottom(rawBottom);

                        const x = leftEdge;
                        const width = rightEdge - leftEdge;
                        const y = snappedTop;
                        const height = snappedBottom - snappedTop;

                        if (width < 1 || height < 1) {
                            if (preview) preview.remove();
                            return;
                        }

                        if (preview) {
                            preview.setAttribute('x', x);
                            preview.setAttribute('y', y);
                            preview.setAttribute('width', width);
                            preview.setAttribute('height', height);

                            if (!preview.parentNode) layerUi.appendChild(preview);
                        }
                        return;

                    } else {
                        // 通常モード（従来ロジック）
                        if (currentX >= STATE.elemStart.x) {
                            effStartX = getClosestColumnLeftEdge(STATE.elemStart.x); currentX = getClosestColumnRightEdge(currentX);
                        } else {
                            effStartX = getClosestColumnRightEdge(STATE.elemStart.x); currentX = getClosestColumnLeftEdge(currentX);
                        }
                        if (currentY >= STATE.elemStart.y) {
                            effStartY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanTop(STATE.elemStart.y) : snapY(STATE.elemStart.y, true);
                            currentY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanBottom(currentY) : snapY(currentY, false);
                        } else {
                            effStartY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanBottom(STATE.elemStart.y) : snapY(STATE.elemStart.y, false);
                            currentY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanTop(currentY) : snapY(currentY, true);
                        }
                    }
                }

                const w = Math.abs(currentX - effStartX);
                const h = Math.abs(currentY - effStartY);
                const x = Math.min(currentX, effStartX);
                const y = Math.min(currentY, effStartY);

                if (STATE.mode === 'image') {
                    const previewGroup = document.getElementById('creation-preview-group');
                    if (!previewGroup) return;

                    previewGroup.innerHTML = '';

                    const gap = (cGrid.lineGap && cGrid.lineGap > 0) ? cGrid.lineGap : 5;

                    // ボックスシャドウ（左右のみ）
                    const shadowRect = document.createElementNS(SVG_NS, 'rect');
                    shadowRect.setAttribute('x', x - gap);
                    shadowRect.setAttribute('y', y);
                    shadowRect.setAttribute('width', w + gap * 2);
                    shadowRect.setAttribute('height', h);
                    shadowRect.setAttribute('class', 'paper-fill');
                    shadowRect.setAttribute('opacity', '0.5');
                    previewGroup.appendChild(shadowRect);

                    // メインボックス
                    const mainRect = document.createElementNS(SVG_NS, 'rect');
                    mainRect.setAttribute('x', x);
                    mainRect.setAttribute('y', y);
                    mainRect.setAttribute('width', w);
                    mainRect.setAttribute('height', h);
                    mainRect.setAttribute('class', 'creation-preview-rect');
                    previewGroup.appendChild(mainRect);
                } else {
                    if (preview) {
                        preview.setAttribute('x', x); preview.setAttribute('y', y);
                        preview.setAttribute('width', w); preview.setAttribute('height', h);
                        if (!preview.parentNode) layerUi.appendChild(preview);
                    }
                }
            }
        }

        function onPointerUp(e) {
            if (e.pointerId !== STATE.activePointerId) return;
            const wasInteracting = (STATE.interactionType === 'drag' || STATE.interactionType === 'resize');

            // pending-or-create: ドラッグせずにクリックだけした場合は選択
            if (STATE.interactionType === 'pending-or-create' && STATE.pendingSelection) {
                STATE.selectedId = STATE.pendingSelection;
                STATE.pendingSelection = null;
                renderUi();
            }

            // pending-or-drag: ドラッグせずにクリックだけした場合は選択
            if (STATE.interactionType === 'pending-or-drag' && STATE.pendingSelection) {
                STATE.selectedId = STATE.pendingSelection;
                STATE.pendingSelection = null;
                renderUi();
            }

            if (STATE.interactionType === 'linking') {
                const pt = getSvgPoint(e.clientX, e.clientY);
                let targetId = null;
                for (const el of STATE.elements) {
                    if (el.id === STATE.linking.sourceId) continue;
                    if (el.type !== 'text') continue;
                    if (el.next || el.prev) continue;

                    if (pt.x >= el.x && pt.x <= el.x + el.width && pt.y >= el.y && pt.y <= el.y + el.height) {
                        targetId = el.id;
                        break;
                    }
                }
                if (targetId) {
                    connectBlocks(STATE.linking.sourceId, targetId);
                }
                if (STATE.linking.lineEl) STATE.linking.lineEl.remove();
                STATE.linking = null;

                clearLinkCandidates();
                renderUi();
            }

            if (STATE.interactionType === 'create') {
                const preview = document.getElementById('creation-preview');
                const group = document.getElementById('creation-preview-group');

                let x, y, w, h;

                // 画像モードの場合はグループから、それ以外はpreviewから座標取得
                if (group) {
                    // グループ内のメインボックス（2番目の子要素）から座標取得
                    const mainRect = group.children[1];
                    if (mainRect) {
                        w = parseFloat(mainRect.getAttribute('width'));
                        h = parseFloat(mainRect.getAttribute('height'));
                        x = parseFloat(mainRect.getAttribute('x'));
                        y = parseFloat(mainRect.getAttribute('y'));
                        if (w > 5 && h > 5) createObjectFromRect({ x, y, w, h });
                    }
                    group.remove();
                } else if (preview) {
                    w = parseFloat(preview.getAttribute('width'));
                    h = parseFloat(preview.getAttribute('height'));
                    x = parseFloat(preview.getAttribute('x'));
                    y = parseFloat(preview.getAttribute('y'));
                    if (w > 5 && h > 5) createObjectFromRect({ x, y, w, h });
                    preview.remove();
                }
            }

            STATE.activePointerId = null; STATE.interactionType = null;
            try { e.target.releasePointerCapture(e.pointerId); } catch (err) { }

            if (wasInteracting) {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data) {
                    if (data.type === 'text') {
                        const head = findChainHead(data);
                        updateTextChain(head);
                    } else {
                        renderElement(data);
                    }
                    renderUi();
                    saveHistory();
                }
            }
        }

        // --- Link Logic ---
        function connectBlocks(sourceId, targetId) {
            const source = STATE.elements.find(e => e.id === sourceId);
            const target = STATE.elements.find(e => e.id === targetId);
            if (!source || !target || source.type !== 'text' || target.type !== 'text') return;

            if (target.next) return;
            if (target.prev) return;

            let curr = source;
            while (curr) {
                if (curr.id === targetId) return;
                if (curr.prev) curr = STATE.elements.find(e => e.id === curr.prev);
                else break;
            }

            source.next = targetId;
            target.prev = sourceId;

            const head = findChainHead(source);
            updateTextChain(head);
            saveHistory();
        }

        function disconnectBlock(sourceId) {
            const source = STATE.elements.find(e => e.id === sourceId);
            if (!source || !source.next) return;

            const nextId = source.next;
            const nextEl = STATE.elements.find(e => e.id === nextId);

            source.next = null;
            if (nextEl) {
                nextEl.prev = null;
                delete nextEl._renderedText;
                if (!nextEl.text) nextEl.text = ensureLeadingFullwidthSpacePerLine("新規記事");
                renderElement(nextEl);
            }

            const head = findChainHead(source);
            updateTextChain(head);
            renderUi();
            saveHistory();
        }

        function findChainHead(block) {
            let curr = block;
            while (curr.prev) {
                const prev = STATE.elements.find(e => e.id === curr.prev);
                if (!prev) { curr.prev = null; break; }
                curr = prev;
            }
            return curr;
        }

        function updateTextChain(head) {
            if (!head || head.type !== 'text') return;

            let curr = head;
            let remainingText = head.text;

            while (curr) {
                const res = measureCapacity(curr, remainingText);
                curr._renderedText = res.fitted;
                remainingText = res.remaining;

                renderElement(curr);

                if (curr.next) {
                    const next = STATE.elements.find(e => e.id === curr.next);
                    if (!next) { curr.next = null; break; }
                    curr = next;
                } else {
                    curr = null;
                }
            }
        }

        // Internal Column Logic Helper
        function getIntersectingDans(data) {
            const cGrid = STATE.grid.computed;
            if (!STATE.grid.show || !cGrid.danPitch) {
                return [{ yOffset: 0, height: data.height, localY: 0 }];
            }

            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const boxTop = data.y;
            const boxBottom = data.y + data.height;

            const segments = [];
            const epsilon = 1.0;

            for (let i = 0; i < STATE.grid.dan; i++) {
                const danTop = mt + (i * cGrid.danPitch);
                const danBottom = danTop + cGrid.danHeight;

                const start = Math.max(boxTop, danTop - epsilon);
                const end = Math.min(boxBottom, danBottom + epsilon);

                if (end > start + 5) {
                    const localY = danTop - boxTop;
                    segments.push({
                        danIndex: i,
                        danTop: danTop,
                        localY: localY,
                        height: cGrid.danHeight
                    });
                }
            }

            if (segments.length === 0) return [{ yOffset: 0, height: data.height, localY: 0 }];

            return segments;
        }

        function getLayoutMetrics(data, forcedHeight, useSnapMode = false) {
            const cGrid = STATE.grid.computed;
            let fontSize, charHeight, pitchX;

            if (cGrid.charSizeW > 0 && STATE.grid.show) {
                fontSize = cGrid.charSizeW;
                charHeight = cGrid.charSizeH;
                pitchX = cGrid.pitchX;
            } else {
                fontSize = data.fontSize;
                charHeight = data.fontSize;
                pitchX = data.fontSize * data.lineHeight;
            }

            const w = data.width;
            const h = forcedHeight !== undefined ? forcedHeight : data.height;

            const safeCharHeight = charHeight > 0 ? charHeight : 1;
            const safePitchX = pitchX > 0 ? pitchX : 1;
            let charsPerLine = Math.max(1, Math.floor((h / safeCharHeight) + 0.5));
            const maxLines = Math.max(1, Math.floor((w / safePitchX) + 0.5));
            if (useSnapMode && STATE.grid.show && STATE.grid.charsPerDan > 0) {
                charsPerLine = STATE.grid.charsPerDan;
            }

            return { fontSize, charHeight, pitchX, charsPerLine, maxLines };
        }

        function measureCapacity(data, text) {
            if (!text) return { fitted: "", remaining: "" };

            let segments;
            const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
            if (useSnapMode) {
                segments = getIntersectingDans(data);
            } else {
                segments = [{ height: data.height, localY: 0 }];
            }

            let processedChars = 0; // 実際に処理した元テキストの文字数
            let currentTextPos = 0; // 現在の元テキスト位置

            for (const seg of segments) {
                const metrics = getLayoutMetrics(data, seg.height, useSnapMode);
                const { charsPerLine, maxLines } = metrics;

                // 残りのテキスト
                const remainingText = text.substring(currentTextPos);
                if (!remainingText) break;

                // ★段落先頭判定（セグメント境界で誤字下げしない）
                const paragraphStart =
                    (currentTextPos === 0) ||
                    (text[currentTextPos - 1] === '\n');

                // トークン化→禁則→行配列
                const tokens = tokenizeText(remainingText, { paragraphStart });
                const lines = applyKinsoku(tokens, charsPerLine);

                let lineCount = 0;
                let segmentChars = 0; // ★元テキストとして消費した文字数（字下げは含めない）

                for (const line of lines) {
                    if (lineCount >= maxLines) break;

                    for (const token of line) {
                        // ★字下げは“表示用”なので元テキスト消費に数えない
                        if (token.isLineIndent) continue;

                        if (token.type === 'tcy') {
                            segmentChars += token.char.length;
                        } else {
                            segmentChars += 1;
                        }
                    }
                    lineCount++;
                }

                currentTextPos += segmentChars;
                processedChars = currentTextPos;

                if (processedChars >= text.length) break;
            }

            return {
                fitted: text.substring(0, processedChars),
                remaining: text.substring(processedChars)
            };
        }


        // 縦中横判定（2文字以内の連続数字）
        function isTateChuYoko(text, index) {
            if (index >= text.length) return null;
            const char = text[index];
            if (!/[0-9０-９]/.test(char)) return null;

            let count = 1;
            let nextChar = text[index + 1];

            if (nextChar && /[0-9０-９]/.test(nextChar)) {
                count = 2;
                let thirdChar = text[index + 2];
                if (thirdChar && /[0-9０-９]/.test(thirdChar)) {
                    return null;
                }
            }

            return count;
        }

        // 縦中横用のグリフ配列を生成（見出し・題字・自由テキスト用）
        function getGlyphsWithTcy(text) {
            const glyphs = [];
            let i = 0;
            while (i < text.length) {
                const tcyCount = isTateChuYoko(text, i);
                if (tcyCount) {
                    glyphs.push({ type: 'tcy', text: text.substr(i, tcyCount) });
                    i += tcyCount;
                } else {
                    glyphs.push({ type: 'char', text: text[i] });
                    i++;
                }
            }
            return glyphs;
        }

        // --- 日本語組版処理 ---
        // 行頭禁則文字
        const GYOTO_KINSOKU = [
            // 句読点・記号
            '。', '、', '．', '，', '：', '；',
            // 閉じ括弧類
            '）', ')', '］', ']', '｝', '}', '」', '』', '】', '〉', '》', '》', '〕', '›', '»',
            // 感嘆符・疑問符
            '！', '？', '!', '?', '‼', '⁇', '⁈', '⁉',
            // 長音・中点など
            'ー', '－', '−', '‐', '‑', '‒', '–', '—', '―', '〜', '～',
            '・', '･', '：', '；', '゠',
            // 繰り返し記号
            'ゝ', 'ゞ', 'ヽ', 'ヾ', '々', '〻',
            // 小書き仮名
            'ぁ', 'ぃ', 'ぅ', 'ぇ', 'ぉ', 'っ', 'ゃ', 'ゅ', 'ょ', 'ゎ',
            'ァ', 'ィ', 'ゥ', 'ェ', 'ォ', 'ッ', 'ャ', 'ュ', 'ョ', 'ヮ', 'ヵ', 'ヶ',
            // その他
            '…', '‥', '°', '′', '″', '℃', '￠', '¢', '%', '％', '‰'
        ];
        // 行末禁則文字（開き括弧など）
        const GYOMATSU_KINSOKU = [
            '（', '(', '［', '[', '｛', '{', '「', '『', '【', '〈', '《', '〔', '‹', '«'
        ];

        // ===== tokenize（段落頭だけ字下げ） =====
        // opts.paragraphStart: true のとき、その呼び出し開始時点を段落先頭として扱う
        function tokenizeText(text, opts = {}) {
            const tokens = [];
            let i = 0;

            // ★「この呼び出し開始時点で段落先頭か？」（セグメント境界対策）
            let atParagraphStart = !!opts.paragraphStart;

            while (i < text.length) {
                const ch = text[i];

                // 改行：ここで段落先頭に戻す
                if (ch === '\n') {
                    tokens.push({ type: 'newline', char: '\n', isLineIndent: false });
                    i++;
                    atParagraphStart = true;
                    continue;
                }

                // ★段落先頭のときだけ字下げ（1回だけ）
                if (atParagraphStart) {
                    tokens.push({ type: 'indent', char: '', isLineIndent: true }); // 表示用1マス
                    atParagraphStart = false;
                }

                // 縦中横（あなたの既存関数を使用）
                const tcyCount = isTateChuYoko(text, i);
                if (tcyCount) {
                    const tcyText = text.substr(i, tcyCount);
                    tokens.push({ type: 'tcy', char: tcyText, isLineIndent: false });
                    i += tcyCount;
                    continue;
                }

                // 通常文字
                tokens.push({ type: 'char', char: ch, isLineIndent: false });
                i++;
            }

            return tokens;
        }

        // 1行の「マス数」(改行は0、それ以外は1マス)
        function getLineGlyphCount(tokens) {
            return tokens.reduce((n, t) => {
                if (t.type === 'newline') return n;
                return n + 1; // char / tcy / indent は 1マス
            }, 0);
        }

        function findFirstRenderableToken(tokens) {
            for (const t of tokens) {
                if (t.type === 'newline') continue;
                if (!t.isLineIndent) return t;
            }
            return null;
        }

        function findLastRenderableToken(tokens) {
            for (let i = tokens.length - 1; i >= 0; i--) {
                const t = tokens[i];
                if (t.type === 'newline') continue;
                if (!t.isLineIndent) return t;
            }
            return null;
        }

        function removeFirstRenderableToken(tokens) {
            for (let i = 0; i < tokens.length; i++) {
                const t = tokens[i];
                if (t.type === 'newline') continue;
                if (t.isLineIndent) continue;
                return tokens.splice(i, 1)[0];
            }
            return null;
        }

        function removeLastRenderableToken(tokens, { excludeIndent = true } = {}) {
            for (let i = tokens.length - 1; i >= 0; i--) {
                const t = tokens[i];
                if (t.type === 'newline') continue;
                if (excludeIndent && t.isLineIndent) continue;
                return tokens.splice(i, 1)[0];
            }
            return null;
        }

        // nextLine の先頭（indent群の後ろ）に token を挿入
        function insertAfterIndents(nextLine, token) {
            let idx = 0;
            while (idx < nextLine.length) {
                const t = nextLine[idx];
                if (t.type === 'newline') break;
                if (!t.isLineIndent) break;
                idx++;
            }
            nextLine.splice(idx, 0, token);
        }

        function enforceMaxCells(lines, maxCells) {
            for (let i = 0; i < lines.length; i++) {
                while (getLineGlyphCount(lines[i]) > maxCells) {
                    const overflow = removeLastRenderableToken(lines[i], { excludeIndent: true });
                    if (!overflow) break;

                    // 次の行がなければ作る
                    if (!lines[i + 1]) lines[i + 1] = [];

                    // Kinsoku-aware overflow: if the character being pushed is a line-head
                    // prohibited character, pull the one before it as well.
                    let beforeKinsoku = null;
                    if (GYOTO_KINSOKU.includes(overflow.char)) {
                        beforeKinsoku = removeLastRenderableToken(lines[i], { excludeIndent: true });
                    }

                    // Insert in correct order (the one removed last was first on the line)
                    insertAfterIndents(lines[i + 1], overflow);
                    if (beforeKinsoku) {
                        insertAfterIndents(lines[i + 1], beforeKinsoku);
                    }
                }
            }
        }

        function applyKinsoku(tokens, charsPerLine) {
            if (!tokens || tokens.length === 0 || charsPerLine <= 0) return [];

            const maxCells = Math.max(1, charsPerLine);

            // --- 1) ラフ折り ---
            const roughLines = [];
            let currentLine = [];
            let currentCells = 0;

            for (const token of tokens) {
                if (token.type === 'newline') {
                    if (currentLine.length === 0) {
                        roughLines.push([token]);
                    } else {
                        currentLine.push(token);
                        roughLines.push(currentLine);
                    }
                    currentLine = [];
                    currentCells = 0;
                    continue;
                }

                currentLine.push(token);
                currentCells++;

                if (currentCells >= maxCells) {
                    roughLines.push(currentLine);
                    currentLine = [];
                    currentCells = 0;
                }
            }
            if (currentLine.length) roughLines.push(currentLine);

            // --- 2) 禁則処理（次行へ切り上げ） ---
            // 複数回実行して、すべての禁則を解決する
            let kinsokuChanged = true;
            let kinsokuIterations = 0;
            const MAX_ITERATIONS = 50;

            while (kinsokuChanged && kinsokuIterations < MAX_ITERATIONS) {
                kinsokuChanged = false;
                kinsokuIterations++;

                for (let i = 0; i < roughLines.length - 1; i++) {
                    const thisLine = roughLines[i];
                    const nextLine = roughLines[i + 1];

                    const last = thisLine[thisLine.length - 1];
                    const thisEndsWithNewline = last && last.type === 'newline';

                    // 行頭禁則
                    let gyotoLoopCount = 0;
                    while (gyotoLoopCount < 30) {
                        gyotoLoopCount++;
                        const head = findFirstRenderableToken(nextLine);
                        if (!head || !GYOTO_KINSOKU.includes(head.char)) break;
                        if (thisEndsWithNewline) break;

                        const moved1 = removeLastRenderableToken(thisLine, { excludeIndent: true });
                        if (!moved1) break;

                        // Try to move one more character, but not if it creates a line-end violation
                        const newLastToken = findLastRenderableToken(thisLine);
                        const moved2 = (newLastToken && !GYOMATSU_KINSOKU.includes(newLastToken.char))
                            ? removeLastRenderableToken(thisLine, { excludeIndent: true })
                            : null;

                        // Insert in correct order (the one removed last was first on the line)
                        insertAfterIndents(nextLine, moved1);
                        if (moved2) {
                            insertAfterIndents(nextLine, moved2);
                        }
                        kinsokuChanged = true;

                        // 次の行が最大文字数を超えた場合、オーバーフロー分をさらに次の行へ
                        let overflowLoopCount = 0;
                        while (getLineGlyphCount(nextLine) > maxCells && overflowLoopCount < 30) {
                            overflowLoopCount++;

                            // さらに次の行がなければ作る
                            if (!roughLines[i + 2]) roughLines[i + 2] = [];

                            // 末尾の文字を取得
                            const overflow = removeLastRenderableToken(nextLine, { excludeIndent: true });
                            if (!overflow) break;

                            // オーバーフローする文字が禁則文字の場合、必ずその前の文字も一緒に送る
                            if (GYOTO_KINSOKU.includes(overflow.char)) {
                                const beforeKinsoku = removeLastRenderableToken(nextLine, { excludeIndent: true });
                                if (beforeKinsoku) {
                                    // 前の文字を先に送る
                                    insertAfterIndents(roughLines[i + 2], beforeKinsoku);
                                }
                            }

                            // 禁則文字（または通常文字）を送る
                            insertAfterIndents(roughLines[i + 2], overflow);
                            kinsokuChanged = true;
                        }
                    }

                    // 行末禁則
                    let gyomatsuLoopCount = 0;
                    while (gyomatsuLoopCount < 30) {
                        gyomatsuLoopCount++;
                        const lastTok = findLastRenderableToken(thisLine);
                        if (!lastTok || !GYOMATSU_KINSOKU.includes(lastTok.char)) break;

                        const moved = removeLastRenderableToken(thisLine, { excludeIndent: false });
                        if (!moved) break;

                        insertAfterIndents(nextLine, moved);
                        kinsokuChanged = true;

                        // 次の行が最大文字数を超えた場合、オーバーフロー分をさらに次の行へ
                        let overflowLoopCount2 = 0;
                        while (getLineGlyphCount(nextLine) > maxCells && overflowLoopCount2 < 30) {
                            overflowLoopCount2++;

                            // さらに次の行がなければ作る
                            if (!roughLines[i + 2]) roughLines[i + 2] = [];

                            // 末尾の文字を取得
                            const overflow = removeLastRenderableToken(nextLine, { excludeIndent: true });
                            if (!overflow) break;

                            // オーバーフローする文字が禁則文字の場合、必ずその前の文字も一緒に送る
                            if (GYOTO_KINSOKU.includes(overflow.char)) {
                                const beforeKinsoku = removeLastRenderableToken(nextLine, { excludeIndent: true });
                                if (beforeKinsoku) {
                                    // 前の文字を先に送る
                                    insertAfterIndents(roughLines[i + 2], beforeKinsoku);
                                }
                            }

                            // 禁則文字（または通常文字）を送る
                            insertAfterIndents(roughLines[i + 2], overflow);
                            kinsokuChanged = true;
                        }
                    }
                }
            }

            // ★★★ ここが追加ポイント ★★★
            // --- 3) 最大文字数の最終保証 ---
            enforceMaxCells(roughLines, maxCells);

            return roughLines.filter(line => line.length > 0);
        }

        // renderElement 側が欲しい形に合わせる
        function layoutLines(tokens, charsPerLine) {
            const raw = applyKinsoku(tokens, charsPerLine);
            return raw.map(toks => ({
                tokens: toks,
                usedCells: getLineGlyphCount(toks)
            }));
        }

        // ===== 行の「マス間自動調整」しつつ描画（★禁則の0.6オフセットは無し） =====
        function renderLineWithAutoSpacing({
            line,                // { tokens, usedCells }
            lineIndex,           // 列番号
            charsPerLine,
            renderCharHeight,
            fontSize,
            pitchX,
            data,
            segGroup,
            segRenderHeight,
        }) {
            const used = line.usedCells;
            if (used <= 0) return; // ただし newline-only 行はここを通らない（消費は別ロジックでやる想定）

            // ===== 字間調整量 =====
            let gapAdjust = 0;
            const gapCount = Math.max(0, used - 1);

            // 1文字以下の行は「均し」しない（見た目が破綻しやすい）
            if (used > 1) {
                const ideal = charsPerLine * renderCharHeight;
                const actual = used * renderCharHeight;
                const delta = ideal - actual;
                const gaps = Math.max(1, used - 1);

                gapAdjust = delta / gaps;

                // 安全ガード（±5%）
                const MAX = renderCharHeight * 0.05;
                gapAdjust = Math.max(-MAX, Math.min(MAX, gapAdjust));
            }

            // ===== 描画 =====
            const minY = renderCharHeight / 2;
            const maxY = Math.max(minY, segRenderHeight - renderCharHeight / 2);
            const ratio = charsPerLine > 0 ? used / charsPerLine : 0;
            const shouldEvenSpacing = ratio > 0.8 && gapCount > 0;
            let extraPerGap = 0;
            if (shouldEvenSpacing) {
                const targetSpan = Math.max(0, maxY - minY);
                const usedSpan = gapCount * (renderCharHeight + gapAdjust);
                const extraSpace = Math.max(0, targetSpan - usedSpan);
                extraPerGap = gapCount > 0 ? extraSpace / gapCount : 0;
            }
            let y = minY;

            for (const token of line.tokens) {
                if (token.type === 'newline') continue;

                const columnCenterX =
                    data.width - (fontSize / 2) - (lineIndex * pitchX);

                // 基本のY（禁則オフセット無し）
                const drawY = Math.min(Math.max(y, minY), maxY);

                // ===== 縦中横 =====
                if (token.type === 'tcy') {
                    const chars = String(token.char || '').slice(0, 2).split('');
                    const n = Math.max(1, chars.length);

                    const cellW = fontSize;
                    const slotW = cellW / n;
                    const leftX = columnCenterX - cellW / 2;

                    for (let i = 0; i < n; i++) {
                        const ch = chars[i];
                        const x = leftX + slotW * (i + 0.5);

                        const t = document.createElementNS(SVG_NS, 'text');
                        t.textContent = ch;
                        t.setAttribute('x', x);
                        t.setAttribute('y', drawY);
                        t.setAttribute('font-family', data.fontFamily);
                        t.setAttribute('class', 'ink-fill');
                        t.setAttribute('writing-mode', 'horizontal-tb');
                        t.setAttribute('text-anchor', 'middle');
                        t.setAttribute('dominant-baseline', 'central');
                        t.setAttribute('font-size', renderCharHeight);
                        t.setAttribute('textLength', slotW);
                        t.setAttribute('lengthAdjust', 'spacingAndGlyphs');
                        segGroup.appendChild(t);
                    }

                    y += renderCharHeight + gapAdjust;
                    continue;
                }

                // ===== 通常文字（indent含む） =====
                const char = token.char || '';

                // iPadで回転してしまう文字（90度回転が必要）
                const needsRotation = /[）\)］\]｝\}」』】〉》〕›»‼⁇⁈⁉ー－−‐‑‒–—―〜～・･゠=＝…‥°′″（\(［\[｛\{「『【〈《〔‹«]/.test(char);

                // 句読点（右0.3マス、上0.8マスに移動）
                const isPunctuation = /[、。，．]/.test(char);

                // コロン・セミコロン（常に90度回転）
                const isColon = /[：；]/.test(char);

                const t = document.createElementNS(SVG_NS, 'text');
                t.textContent = char;
                t.setAttribute('font-family', data.fontFamily);
                t.setAttribute('class', 'ink-fill');
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'central');
                t.setAttribute('font-size', fontSize);

                // 縦書きモード判定
                const isVertical = (data.writingMode === 'vertical-rl' || !data.writingMode);

                if (isVertical && isColon) {
                    // コロン・セミコロンは常に90度回転
                    t.setAttribute('writing-mode', 'horizontal-tb');
                    t.setAttribute('transform', `rotate(90 ${columnCenterX} ${drawY})`);
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                } else if (STATE.ipadMode && isVertical && isPunctuation) {
                    // 句読点は右0.65マス、上0.65マス移動
                    t.setAttribute('writing-mode', data.writingMode || 'vertical-rl');
                    const offsetX = renderCharHeight * 0.65;
                    const offsetY = -renderCharHeight * 0.65;
                    t.setAttribute('x', columnCenterX + offsetX);
                    t.setAttribute('y', drawY + offsetY);
                    t.style.textOrientation = 'upright';
                } else if (STATE.ipadMode && isVertical && needsRotation) {
                    // iPadモード: 回転している文字を90度回転で修正
                    t.setAttribute('writing-mode', 'horizontal-tb');
                    t.setAttribute('transform', `rotate(90 ${columnCenterX} ${drawY})`);
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                } else if (isVertical) {
                    // その他の文字は通常通り
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                    t.setAttribute('writing-mode', data.writingMode || 'vertical-rl');
                    t.style.textOrientation = 'upright';
                } else {
                    // 通常モード
                    t.setAttribute('x', columnCenterX);
                    t.setAttribute('y', drawY);
                    t.setAttribute('writing-mode', data.writingMode || 'vertical-rl');

                    // Safari/iOS対策
                    const allSpecialChars = /[、。，．・：；！？（）「」『』【】〈〉《》〔〕［］｛｝]/.test(char);
                    if (allSpecialChars) {
                        t.style.textOrientation = 'upright';
                    }
                }

                segGroup.appendChild(t);

                y += renderCharHeight + gapAdjust + extraPerGap;
            }
        }


        // --- Helper Snaps ---
        function getColumnIndexAt(rawX) {
            const cGrid = STATE.grid.computed;
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const rightEdge = w_px - mr;
            const center0 = rightEdge - (cGrid.charSizeW / 2);
            return Math.round((center0 - rawX) / cGrid.pitchX);
        }

        function getClosestColumnRightEdge(rawX) {
            const cGrid = STATE.grid.computed;
            const col = getColumnIndexAt(rawX);
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const rightEdge = w_px - mr;
            return rightEdge - (col * cGrid.pitchX);
        }

        function getClosestColumnLeftEdge(rawX) {
            const cGrid = STATE.grid.computed;
            return getClosestColumnRightEdge(rawX) - cGrid.charSizeW;
        }

        // 左右どちらか近い方の列グリッド線を取得
        function getClosestColumnGridLine(rawX) {
            const cGrid = STATE.grid.computed;
            const col = getColumnIndexAt(rawX);
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const rightEdgeBase = w_px - mr;
            const rEdge = rightEdgeBase - (col * cGrid.pitchX);
            const lEdge = rEdge - cGrid.charSizeW;
            return Math.abs(rawX - rEdge) < Math.abs(rawX - lEdge) ? rEdge : lEdge;
        }

        // ドラッグ進行方向にある、最も近い有効な列境界線を取得
        function getSnapEdgeX(rawX, diffX) {
            const cGrid = STATE.grid.computed;
            // ... (snap logic used implicitly in resize)
            return getClosestColumnLeftEdge(rawX); // Simplified
        }

        // --- Gap回避スナップ関数 (New) ---
        function snapY_StrictGap(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight || cGrid.charSizeH <= 0) return rawY;

            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const relY = rawY - mt;

            // どの段のエリアにいるか（Gap含む）
            const danPitch = cGrid.danPitch;
            const danIndex = Math.floor(relY / danPitch);
            const offsetInDan = relY % danPitch; // 段Topからの距離

            // 範囲外（上端より上、最終段より下）のガード
            if (danIndex < 0) return mt;
            if (danIndex >= STATE.grid.dan) return mt + (STATE.grid.dan * danPitch) - (danPitch - cGrid.danHeight);

            // Gap判定
            if (offsetInDan > cGrid.danHeight) {
                // Gapの中にいる -> 次の段の上端にスナップ
                return mt + ((danIndex + 1) * danPitch);
            } else {
                // 段の中にいる -> この段の上端にスナップ
                return mt + (danIndex * danPitch);
            }
        }

        // 下端リサイズ用: 段の下端にスナップ
        function snapY_StrictGap_Bottom(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight || cGrid.charSizeH <= 0) return rawY;

            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const relY = rawY - mt;

            // どの段のエリアにいるか（Gap含む）
            const danPitch = cGrid.danPitch;
            const danIndex = Math.floor(relY / danPitch);
            const offsetInDan = relY % danPitch; // 段Topからの距離

            // 範囲外（上端より上、最終段より下）のガード
            if (danIndex < 0) return mt;
            if (danIndex >= STATE.grid.dan) return mt + (STATE.grid.dan * danPitch) - (danPitch - cGrid.danHeight);

            // Gap判定
            if (offsetInDan > cGrid.danHeight) {
                // Gapの中にいる -> 次の段の下端にスナップ
                return mt + ((danIndex + 1) * danPitch) + cGrid.danHeight;
            } else {
                // 段の中にいる -> この段の下端にスナップ
                return mt + (danIndex * danPitch) + cGrid.danHeight;
            }
        }

        function snapY(rawY, isTopEdge) {
            const cGrid = STATE.grid.computed; if (cGrid.charSizeH <= 0) return rawY;
            const mt = STATE.canvas.margin.top * PX_PER_MM; const relY = rawY - mt;
            const danIndex = Math.floor(relY / cGrid.danPitch); const danStart = mt + (danIndex * cGrid.danPitch);
            const charIndex = Math.round((rawY - danStart) / cGrid.charSizeH);
            return danStart + (charIndex * cGrid.charSizeH);
        }

        function snapY_Dan(rawY) { return snapY_DanTop(rawY); }

        function snapY_DanTop(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight) return rawY;
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            let candidates = [];
            for (let i = 0; i < STATE.grid.dan; i++) {
                candidates.push(mt + (i * cGrid.danPitch));
            }
            return candidates.reduce((prev, curr) => Math.abs(curr - rawY) < Math.abs(prev - rawY) ? curr : prev);
        }

        function snapY_DanBottom(rawY) {
            const cGrid = STATE.grid.computed;
            if (!cGrid.danHeight) return rawY;
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            let candidates = [];
            for (let i = 0; i < STATE.grid.dan; i++) {
                candidates.push(mt + (i * cGrid.danPitch) + cGrid.danHeight);
            }
            return candidates.reduce((prev, curr) => Math.abs(curr - rawY) < Math.abs(prev - rawY) ? curr : prev);
        }

        // --- Touch (Pinch Zoom) ---
        function onTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault(); STATE.activePointerId = null; STATE.interactionType = null;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                STATE.touchStartDist = Math.sqrt(dx * dx + dy * dy);
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                STATE.viewStart = { ...STATE.view };
                const rect = viewport.getBoundingClientRect();
                const vx = cx - rect.left; const vy = cy - rect.top;
                STATE.pinchStartCanvas = { x: (vx - STATE.viewStart.x) / STATE.viewStart.scale, y: (vy - STATE.viewStart.y) / STATE.viewStart.scale };
            }
        }
        function onTouchMove(e) {
            if (e.touches.length === 2 && STATE.touchStartDist > 0) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const zoomFactor = Math.sqrt(dx * dx + dy * dy) / STATE.touchStartDist;
                let newScale = Math.max(0.1, Math.min(STATE.viewStart.scale * zoomFactor, 10.0));
                const rect = viewport.getBoundingClientRect();
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const vx = cx - rect.left; const vy = cy - rect.top;
                STATE.view.scale = newScale;
                STATE.view.x = vx - (STATE.pinchStartCanvas.x * newScale);
                STATE.view.y = vy - (STATE.pinchStartCanvas.y * newScale);
                updateTransform();
            }
        }
        function onTouchEnd(e) { if (e.touches.length < 2) STATE.touchStartDist = 0; }
        function onWheel(e) {
            e.preventDefault();
            if (e.altKey || e.ctrlKey) {
                const delta = -Math.sign(e.deltaY);
                let newScale = Math.max(0.1, Math.min(STATE.view.scale * (1 + delta * 0.05), 10.0));
                const rect = viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
                STATE.view.x = mouseX - (mouseX - STATE.view.x) * (newScale / STATE.view.scale);
                STATE.view.y = mouseY - (mouseY - STATE.view.y) * (newScale / STATE.view.scale);
                STATE.view.scale = newScale;
            } else { STATE.view.x -= e.deltaX; STATE.view.y -= e.deltaY; }
            updateTransform();
        }

        // --- Core Logic ---
        function setMode(mode) {
            STATE.mode = mode;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if (mode === 'select') document.getElementById('btn-select').classList.add('active');
            if (mode === 'hand') document.getElementById('btn-hand').classList.add('active');
            if (mode === 'text') document.getElementById('btn-text').classList.add('active');
            if (mode === 'heading') document.getElementById('btn-heading').classList.add('active');
            if (mode === 'masthead') document.getElementById('btn-masthead').classList.add('active');
            if (mode === 'rect') document.getElementById('btn-rect').classList.add('active');
            if (mode === 'vline') document.getElementById('btn-vline').classList.add('active');
            if (mode === 'image') document.getElementById('btn-image').classList.add('active');
            if (mode === 'freetext') document.getElementById('btn-freetext').classList.add('active');

            viewport.className = 'viewport';
            // モード別のクラス付与
            if (mode === 'select') viewport.classList.add('mode-select');
            else if (mode === 'hand') viewport.classList.add('mode-hand');
            else viewport.classList.add('mode-create');
        }

        function updateSnapMode() {
            const cbNone = document.getElementById('inp-snap-article');
            const cbText = document.getElementById('inp-snap-article-txt');

            // 選択中の記事ボックスがある場合は、そのボックスのsnapModeを更新
            if (STATE.selectedId) {
                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'text') {
                    if (document.activeElement === cbText) {
                        data.snapMode = cbText.checked;
                        cbNone.checked = cbText.checked; // 同期
                        STATE.articleSnapMode = cbText.checked; // グローバルも更新
                    }

                    // 選択中のボックスのチェーンを再計算
                    const head = findChainHead(data);
                    updateTextChain(head);
                    renderUi();
                    return;
                }
            }

            // 選択中のボックスがない場合は、グローバル設定のみ更新
            if (document.activeElement === cbNone) {
                STATE.articleSnapMode = cbNone.checked;
                cbText.checked = STATE.articleSnapMode;
            } else if (document.activeElement === cbText) {
                STATE.articleSnapMode = cbText.checked;
                cbNone.checked = STATE.articleSnapMode;
            } else {
                STATE.articleSnapMode = cbNone.checked;
            }
        }

        function createObjectFromRect(rect) {
            const id = 'el_' + Math.random().toString(36).substr(2, 9);
            const cGrid = STATE.grid.computed;
            const initFontSize = cGrid.charSizeW > 0 ? cGrid.charSizeW : 24;
            const initLineHeight = cGrid.charSizeW > 0 ? (cGrid.lineGap / cGrid.charSizeW) + 1 : 1.5;
            let data;

            if (STATE.mode === 'text') {
                data = {
                    id, type: 'text', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "新規記事", fontSize: initFontSize, lineHeight: initLineHeight,
                    writingMode: 'vertical-rl', fontFamily: '"BIZ UDMincho", serif', charScale: 85, showGrid: false,
                    snapMode: STATE.articleSnapMode // 個別の記事配置モード設定
                };
            } else if (STATE.mode === 'heading') {
                data = {
                    id, type: 'heading', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "見出し", paddingV: 5, paddingH: 5, fontFamily: '"Noto Sans JP", sans-serif',
                    inverted: false,
                    textStrokeWidth: 2
                };
            } else if (STATE.mode === 'masthead') {
                data = {
                    id, type: 'masthead', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "空想新聞", fontFamily: '"Noto Serif JP", serif',
                    borderWidthOuter: 1.0, borderWidthInner: 0.3, patternLineHeight: 0.4,
                    paddingH: 0, paddingV: 0, textStrokeWidth: 2, inverted: false
                };
            } else if (STATE.mode === 'image') {
                data = {
                    id, type: 'image', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    imageUrl: null,
                    imageScale: 1.0,
                    imageOffsetX: 0,
                    imageOffsetY: 0,
                    colorMode: 'fullcolor',
                    contrast: 100,
                    brightness: 100
                };
            } else if (STATE.mode === 'freetext') {
                data = {
                    id, type: 'freetext', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    text: "自由テキスト",
                    direction: 'vertical',
                    align: 'top-left',
                    fontFamily: '"BIZ UDMincho", serif',
                    fontSize: 4,
                    fontWeight: 400,
                    colorSource: 'ink'
                };
            } else if (STATE.mode === 'vline') {
                data = {
                    id, type: 'vline', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    lineWidth: 0.5
                };
            } else {
                data = {
                    id, type: 'rect', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                    fillMode: 'paper',
                    borderStyle: 'none',
                    borderWidth: 0.5
                };
            }
            STATE.elements.push(data);
            renderElement(data);
            selectElement(id);
            saveHistory();
        }

        function updateElementTransform(data) {
            const group = document.getElementById(data.id);
            if (!group) return;

            let trans = `translate(${data.x}, ${data.y})`;
            if (data.type === 'text') {
                const scaleVal = (data.charScale || 85) / 100;
                trans += (data.writingMode === 'vertical-rl') ? ` scale(1, ${scaleVal})` : ` scale(${scaleVal}, 1)`;
            }
            if (data.type === 'heading' || data.type === 'masthead') {
                renderElement(data);
                return;
            }
            group.setAttribute('transform', trans);
            const hitRect = group.querySelector('.hit-rect');
            if (hitRect) {
                let effW = data.width; let effH = data.height;
                if (data.type === 'text' && data.writingMode === 'vertical-rl') effH = data.height / ((data.charScale || 85) / 100);
                hitRect.setAttribute('width', effW); hitRect.setAttribute('height', effH);
            }
        }

        function computeImageCoverLayout(data) {
            const boxAspect = data.width > 0 && data.height > 0 ? data.width / data.height : 1;
            const imgAspect = data._imageAspect || 1;
            let baseW, baseH;
            let baseX = 0;
            let baseY = 0;

            if (imgAspect > boxAspect) {
                baseH = data.height;
                baseW = baseH * imgAspect;
                baseX = (data.width - baseW) / 2;
            } else {
                baseW = data.width;
                baseH = baseW / imgAspect;
                baseY = (data.height - baseH) / 2;
            }

            return { baseW, baseH, baseX, baseY };
        }

        function renderElement(data) {
            let group = document.getElementById(data.id);
            if (!group) {
                group = document.createElementNS(SVG_NS, 'g');
                group.id = data.id;
                layerContent.appendChild(group);
            }
            group.innerHTML = '';

            // ============================
            // TEXT（記事）
            // ============================
            if (data.type === 'text') {
                const scaleVal = (data.charScale || 85) / 100;

                // transform
                let trans = `translate(${data.x}, ${data.y})`;
                trans += (data.writingMode === 'vertical-rl')
                    ? ` scale(1, ${scaleVal})`
                    : ` scale(${scaleVal}, 1)`;
                group.setAttribute('transform', trans);

                // チェーン対応の本文
                const contentToRender =
                    (data.prev !== undefined && data.prev !== null)
                        ? (data._renderedText || '')
                        : (data._renderedText !== undefined ? data._renderedText : (data.text || ''));

                // 段（セグメント）
                const useSnapMode =
                    (data.snapMode !== undefined) ? data.snapMode : STATE.articleSnapMode;
                const segments = useSnapMode
                    ? getIntersectingDans(data)
                    : [{ height: data.height, localY: 0 }];

                let charCursor = 0;
                const gap =
                    (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0)
                        ? STATE.grid.computed.lineGap
                        : 5;

                for (const seg of segments) {
                    if (charCursor >= contentToRender.length) break;

                    let segRenderHeight = seg.height;
                    if (data.writingMode === 'vertical-rl') {
                        segRenderHeight = seg.height / scaleVal;
                    }

                    const segGroup = document.createElementNS(SVG_NS, 'g');
                    segGroup.setAttribute(
                        'transform',
                        `translate(0, ${seg.localY / scaleVal})`
                    );

                    // 背景（左右に行間幅の紙色背景）- Free modeのみ
                    if (!useSnapMode) {
                        const bg = document.createElementNS(SVG_NS, 'rect');
                        bg.setAttribute('x', -gap);
                        bg.setAttribute('y', 0);
                        bg.setAttribute('width', data.width + gap * 2);
                        bg.setAttribute('height', segRenderHeight);
                        bg.setAttribute('class', 'paper-fill');
                        segGroup.appendChild(bg);
                    }

                    // hit rect（枠全体を選択可能にするため、ギャップを含む）
                    const hit = document.createElementNS(SVG_NS, 'rect');
                    hit.setAttribute('class', 'hit-rect');
                    hit.setAttribute('x', -gap);
                    hit.setAttribute('y', 0);
                    hit.setAttribute('width', data.width + gap * 2);
                    hit.setAttribute('height', segRenderHeight);
                    segGroup.appendChild(hit);

                    // レイアウト情報
                    const metrics = getLayoutMetrics(data, seg.height, useSnapMode);
                    const { fontSize, charHeight, pitchX, charsPerLine, maxLines } = metrics;
                    const renderCharHeight = charHeight / scaleVal;

                    const remainingText = contentToRender.substring(charCursor);

                    // 段落判定（チェーン先では先頭字下げしない）
                    const isChained = (data.prev !== undefined && data.prev !== null);
                    const paragraphStart =
                        (!isChained && charCursor === 0) ||
                        (charCursor > 0 && contentToRender[charCursor - 1] === '\n');

                    const tokens = tokenizeText(remainingText, { paragraphStart });
                    const lines = layoutLines(tokens, charsPerLine);

                    let consumedRaw = 0;

                    lines.forEach((line, lineIndex) => {
                        if (lineIndex >= maxLines) return;

                        // ==== 行描画（字間自動調整つき）====
                        renderLineWithAutoSpacing({
                            line,
                            lineIndex,
                            charsPerLine,
                            renderCharHeight,
                            fontSize,
                            pitchX,
                            data,
                            segGroup,
                            segRenderHeight,
                        });

                        // ==== 消費文字数カウント（論理）====
                        for (const token of line.tokens) {
                            if (token.type === 'newline') {
                                consumedRaw += 1;
                            } else if (token.type === 'tcy') {
                                consumedRaw += token.rawLength ?? String(token.char || '').length;
                            } else if (!token.isLineIndent) {
                                consumedRaw += token.rawLength ?? 1;
                            }
                        }
                    });

                    // ★このセグメントで消費した分だけ進める
                    charCursor += consumedRaw;

                    group.appendChild(segGroup);
                }

                // 全体をカバーするhit-rect（左右にギャップを含む）
                const overallHit = document.createElementNS(SVG_NS, 'rect');
                overallHit.setAttribute('class', 'hit-rect');
                overallHit.setAttribute('x', -gap);
                overallHit.setAttribute('y', 0);
                overallHit.setAttribute('width', data.width + gap * 2);
                overallHit.setAttribute('height', data.height);
                group.appendChild(overallHit);

                return;
            }

            // ============================
            // HEADING（見出し）
            // ============================
            if (data.type === 'heading') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const gap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -gap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + gap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                const bgRect = document.createElementNS(SVG_NS, 'rect');
                bgRect.setAttribute('x', 0); bgRect.setAttribute('y', 0);
                bgRect.setAttribute('width', data.width); bgRect.setAttribute('height', data.height);
                bgRect.setAttribute('class', data.inverted ? 'ink-fill' : 'paper-fill');
                group.appendChild(bgRect);

                const isVertical = data.height > data.width;
                const glyphs = getGlyphsWithTcy(data.text || '');
                const glyphCount = glyphs.length;
                const content = getHeadingContentBounds(data);

                if (content.width > 0 && content.height > 0 && glyphCount > 0) {
                    const columns = isVertical ? 1 : glyphCount;
                    const rows = isVertical ? glyphCount : 1;
                    const cellWidth = columns > 0 ? content.width / columns : content.width;
                    const cellHeight = rows > 0 ? content.height / rows : content.height;

                    const baseFontSize = Math.min(cellWidth, cellHeight) * 0.9;
                    const scaleX = (cellWidth * 0.9) / baseFontSize;
                    const scaleY = (cellHeight * 0.9) / baseFontSize;

                    for (let idx = 0; idx < glyphCount; idx++) {
                        const glyph = glyphs[idx];
                        const cellX = content.offsetX + (isVertical ? 0 : idx * cellWidth);
                        const cellY = content.offsetY + (isVertical ? idx * cellHeight : 0);
                        const centerX = cellX + cellWidth / 2;
                        const centerY = cellY + cellHeight / 2;

                        const verticalOffset = -baseFontSize * 0.075;
                        const adjustedY = isVertical ? centerY : centerY + verticalOffset;

                        const textEl = document.createElementNS(SVG_NS, 'text');
                        textEl.textContent = glyph.text;
                        textEl.setAttribute('font-family', data.fontFamily);
                        textEl.setAttribute('font-weight', '900');
                        textEl.setAttribute('font-size', baseFontSize);
                        textEl.setAttribute('x', centerX);
                        textEl.setAttribute('y', adjustedY);
                        textEl.setAttribute('dominant-baseline', 'central');
                        textEl.setAttribute('text-anchor', 'middle');

                        // iPadモード対応
                        const char = glyph.text || '';
                        // iPadで回転してしまう文字（90度回転が必要）
                        const needsRotation = /[）\)］\]｝\}」』】〉》〕›»‼⁇⁈⁉ー－−‐‑‒–—―〜～・･゠=＝…‥°′″（\(［\[｛\{「『【〈《〔‹«]/.test(char);
                        // 句読点（右0.3マス、上0.8マスに移動）
                        const isPunctuation = /[、。，．]/.test(char);
                        // コロン・セミコロン（常に90度回転）
                        const isColon = /[：；]/.test(char);

                        if (glyph.type === 'tcy' && isVertical) {
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                        } else if (isVertical && isColon) {
                            // コロン・セミコロンは常に90度回転
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else if (STATE.ipadMode && isVertical && isPunctuation) {
                            // 句読点は右0.65マス、上0.65マス移動
                            textEl.setAttribute('writing-mode', 'vertical-rl');
                            const offsetX = cellWidth * 0.65 * scaleX;
                            const offsetY = -cellHeight * 0.65 * scaleY;
                            textEl.setAttribute('x', centerX + offsetX);
                            textEl.setAttribute('y', adjustedY + offsetY);
                            textEl.style.textOrientation = 'upright';
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        } else if (STATE.ipadMode && isVertical && needsRotation) {
                            // iPadモード: 回転している文字を90度回転で修正
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else {
                            textEl.setAttribute('writing-mode', isVertical ? 'vertical-rl' : 'horizontal-tb');
                            if (isVertical && glyph.type !== 'tcy') {
                                textEl.style.textOrientation = 'upright';
                            }
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        }
                        textEl.setAttribute('class', data.inverted ? 'paper-fill' : 'ink-fill');
                        const textStrokeWidth = ((data.textStrokeWidth !== undefined ? data.textStrokeWidth : 2)) * PX_PER_MM;
                        if (data.inverted && textStrokeWidth > 0) {
                            textEl.setAttribute('paint-order', 'stroke');
                            const inkColor = STATE.canvas.colors?.ink || '#333333';
                            textEl.setAttribute('stroke', inkColor);
                            textEl.setAttribute('stroke-width', textStrokeWidth);
                        }
                        textEl.style.fontFamily = data.fontFamily;

                        group.appendChild(textEl);
                    }
                }

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width); hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // MASTHEAD（題字）
            // ============================
            if (data.type === 'masthead') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const bo = parseFloat(data.borderWidthOuter) * PX_PER_MM;
                const gap = bo;
                const bi = parseFloat(data.borderWidthInner) * PX_PER_MM;
                const pl = parseFloat(data.patternLineHeight) * PX_PER_MM;

                // 行間幅を取得
                const lineGap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;

                // 背景（左右に行間幅の紙色背景）
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -lineGap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + lineGap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                const bg = document.createElementNS(SVG_NS, 'rect');
                bg.setAttribute('width', data.width);
                bg.setAttribute('height', data.height);
                bg.setAttribute('class', 'paper-fill');
                group.appendChild(bg);

                // 外枠
                const outerRect = document.createElementNS(SVG_NS, 'rect');
                const oOffset = bo / 2;
                outerRect.setAttribute('x', oOffset);
                outerRect.setAttribute('y', oOffset);
                outerRect.setAttribute('width', Math.max(0, data.width - bo));
                outerRect.setAttribute('height', Math.max(0, data.height - bo));
                outerRect.setAttribute('fill', 'none');
                outerRect.setAttribute('class', 'ink-stroke');
                outerRect.setAttribute('stroke-width', bo);
                outerRect.setAttribute('stroke-linejoin', 'miter');
                group.appendChild(outerRect);

                // 内枠
                const innerRect = document.createElementNS(SVG_NS, 'rect');
                const iOffset = bo + gap + (bi / 2);
                innerRect.setAttribute('x', iOffset);
                innerRect.setAttribute('y', iOffset);
                innerRect.setAttribute('width', Math.max(0, data.width - iOffset * 2));
                innerRect.setAttribute('height', Math.max(0, data.height - iOffset * 2));
                innerRect.setAttribute('fill', 'none');
                innerRect.setAttribute('class', 'ink-stroke');
                innerRect.setAttribute('stroke-width', bi);
                innerRect.setAttribute('stroke-linejoin', 'round');
                group.appendChild(innerRect);

                // 地紋パターン（水平線）
                const patternId = 'pat-' + data.id;
                const patternSize = pl * 4; // 線の太さ + 間隔(線の3倍) = 4倍

                let defs = mainSvg.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS(SVG_NS, 'defs');
                    mainSvg.insertBefore(defs, mainSvg.firstChild);
                }
                let pattern = document.getElementById(patternId);
                if (pattern) pattern.remove();

                pattern = document.createElementNS(SVG_NS, 'pattern');
                pattern.setAttribute('id', patternId);
                pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                pattern.setAttribute('width', patternSize);
                pattern.setAttribute('height', patternSize);

                // 水平線
                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', pl / 2);
                line.setAttribute('x2', patternSize);
                line.setAttribute('y2', pl / 2);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', pl);
                pattern.appendChild(line);
                defs.appendChild(pattern);

                // 地紋領域
                const fillRect = document.createElementNS(SVG_NS, 'rect');
                const fillOffset = bo + gap + bi + gap;
                fillRect.setAttribute('x', fillOffset);
                fillRect.setAttribute('y', fillOffset);
                fillRect.setAttribute('width', Math.max(0, data.width - fillOffset * 2));
                fillRect.setAttribute('height', Math.max(0, data.height - fillOffset * 2));
                fillRect.setAttribute('fill', `url(#${patternId})`);
                group.appendChild(fillRect);

                // テキスト描画（見出しと同様に1文字ずつセル分割）
                const isVertical = data.height > data.width;
                const glyphs = getGlyphsWithTcy(data.text || '');
                const glyphCount = glyphs.length;

                // テキスト描画領域を計算（枠とパディングを考慮）
                const textPadding = fillOffset + gap * 2;
                const contentWidth = Math.max(0, data.width - textPadding * 2);
                const contentHeight = Math.max(0, data.height - textPadding * 2);
                const contentOffsetX = textPadding;
                const contentOffsetY = textPadding;

                if (contentWidth > 0 && contentHeight > 0 && glyphCount > 0) {
                    const columns = isVertical ? 1 : glyphCount;
                    const rows = isVertical ? glyphCount : 1;
                    const cellWidth = columns > 0 ? contentWidth / columns : contentWidth;
                    const cellHeight = rows > 0 ? contentHeight / rows : contentHeight;

                    const baseFontSize = Math.min(cellWidth, cellHeight) * 0.9;
                    const scaleX = (cellWidth * 0.9) / baseFontSize;
                    const scaleY = (cellHeight * 0.9) / baseFontSize;

                    for (let idx = 0; idx < glyphCount; idx++) {
                        const glyph = glyphs[idx];
                        const cellX = contentOffsetX + (isVertical ? 0 : idx * cellWidth);
                        const cellY = contentOffsetY + (isVertical ? idx * cellHeight : 0);
                        const centerX = cellX + cellWidth / 2;
                        const centerY = cellY + cellHeight / 2;

                        const verticalOffset = -baseFontSize * 0.075;
                        const adjustedY = isVertical ? centerY : centerY + verticalOffset;

                        const textEl = document.createElementNS(SVG_NS, 'text');
                        textEl.textContent = glyph.text;
                        textEl.setAttribute('font-family', data.fontFamily);
                        textEl.setAttribute('font-weight', '900');
                        textEl.setAttribute('font-size', baseFontSize);
                        textEl.setAttribute('x', centerX);
                        textEl.setAttribute('y', adjustedY);
                        textEl.setAttribute('dominant-baseline', 'central');
                        textEl.setAttribute('text-anchor', 'middle');

                        // iPadモード対応
                        const char = glyph.text || '';
                        // iPadで回転してしまう文字（90度回転が必要）
                        const needsRotation = /[）\)］\]｝\}」』】〉》〕›»‼⁇⁈⁉ー－−‐‑‒–—―〜～・･゠=＝…‥°′″（\(［\[｛\{「『【〈《〔‹«]/.test(char);
                        // 句読点（右0.3マス、上0.8マスに移動）
                        const isPunctuation = /[、。，．]/.test(char);
                        // コロン・セミコロン（常に90度回転）
                        const isColon = /[：；]/.test(char);

                        if (glyph.type === 'tcy' && isVertical) {
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                        } else if (isVertical && isColon) {
                            // コロン・セミコロンは常に90度回転
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else if (isVertical && isPunctuation) {
                            // 句読点は右0.65マス、上0.65マス移動
                            textEl.setAttribute('writing-mode', 'vertical-rl');
                            const offsetX = cellWidth * 0.65 * scaleX;
                            const offsetY = -cellHeight * 0.65 * scaleY;
                            textEl.setAttribute('x', centerX + offsetX);
                            textEl.setAttribute('y', adjustedY + offsetY);
                            textEl.style.textOrientation = 'upright';
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        } else if (STATE.ipadMode && isVertical && needsRotation) {
                            // iPadモード: 回転している文字を90度回転で修正
                            textEl.setAttribute('writing-mode', 'horizontal-tb');
                            textEl.setAttribute('x', centerX);
                            textEl.setAttribute('y', adjustedY);
                            textEl.setAttribute('transform', `rotate(90 ${centerX} ${adjustedY}) scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${adjustedY}`);
                        } else {
                            textEl.setAttribute('writing-mode', isVertical ? 'vertical-rl' : 'horizontal-tb');
                            if (isVertical && glyph.type !== 'tcy') {
                                textEl.style.textOrientation = 'upright';
                            }
                            textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                            textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                        }
                        textEl.setAttribute('class', data.inverted ? 'paper-fill' : 'ink-fill');
                        textEl.style.fontFamily = data.fontFamily;

                        // 白フチ（inverted=falseの時のみ）
                        const textStrokeWidth = (data.textStrokeWidth !== undefined ? data.textStrokeWidth : 2) * PX_PER_MM;
                        if (textStrokeWidth > 0) {
                            textEl.setAttribute('paint-order', 'stroke');
                            if (data.inverted) {
                                const inkColor = STATE.canvas.colors?.ink || '#333333';
                                textEl.setAttribute('stroke', inkColor);
                            } else {
                                textEl.setAttribute('stroke', '#fff');
                            }
                            textEl.setAttribute('stroke-width', textStrokeWidth);
                        }

                        group.appendChild(textEl);
                    }
                }

                // ヒット領域
                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // RECT（塗り）
            // ============================
            if (data.type === 'rect') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const isInkFill = data.fillMode === 'ink';
                const borderStyle = data.borderStyle || 'none';
                const borderWidth = (data.borderWidth || 0.5) * PX_PER_MM;

                const lineGap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0)
                    ? STATE.grid.computed.lineGap
                    : 5;
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -lineGap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + lineGap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                // 塗りつぶし面（ボックス全体を覆う）
                const fillRect = document.createElementNS(SVG_NS, 'rect');
                fillRect.setAttribute('x', 0);
                fillRect.setAttribute('y', 0);
                fillRect.setAttribute('width', data.width);
                fillRect.setAttribute('height', data.height);
                if (isInkFill) fillRect.setAttribute('class', 'ink-fill');
                else fillRect.setAttribute('class', 'paper-fill');
                group.appendChild(fillRect);

                // 枠線（内側に描画）
                if (borderStyle !== 'none') {
                    // インク色塗りつぶしの場合は1mm内側に枠線を配置
                    const baseInset = isInkFill ? 1 * PX_PER_MM : 0;
                    // 枠線を内側に描画するため、枠線幅の半分だけさらに内側にずらす
                    const borderInset = borderWidth / 2;
                    const totalInset = baseInset + borderInset;

                    const borderRect = document.createElementNS(SVG_NS, 'rect');
                    borderRect.setAttribute('x', totalInset);
                    borderRect.setAttribute('y', totalInset);
                    borderRect.setAttribute('width', data.width - (totalInset * 2));
                    borderRect.setAttribute('height', data.height - (totalInset * 2));
                    borderRect.setAttribute('fill', 'none');

                    // 枠線の色
                    const inkColor = STATE.canvas.colors.ink || '#333333';
                    const paperColor = STATE.canvas.colors.paper || '#ffffff';
                    const borderStrokeColor = isInkFill ? paperColor : inkColor;
                    borderRect.setAttribute('stroke', borderStrokeColor);
                    borderRect.setAttribute('stroke-width', borderWidth);

                    // 枠線のスタイル
                    if (borderStyle === 'dotted') {
                        borderRect.setAttribute('stroke-dasharray', `${borderWidth * 0.5}, ${borderWidth * 1.5}`);
                    } else if (borderStyle === 'double') {
                        borderRect.setAttribute('stroke-dasharray', 'none');
                    } else {
                        // solid
                        borderRect.setAttribute('stroke-dasharray', 'none');
                    }
                    group.appendChild(borderRect);

                    // 二重線の場合は内側にもう一本線を描画
                    if (borderStyle === 'double') {
                        const innerRect = document.createElementNS(SVG_NS, 'rect');
                        const gap = borderWidth * 2; // 2本の線の間隔
                        const innerInset = totalInset + gap;
                        innerRect.setAttribute('x', innerInset);
                        innerRect.setAttribute('y', innerInset);
                        innerRect.setAttribute('width', data.width - (innerInset * 2));
                        innerRect.setAttribute('height', data.height - (innerInset * 2));
                        innerRect.setAttribute('fill', 'none');
                        innerRect.setAttribute('stroke', borderStrokeColor);
                        innerRect.setAttribute('stroke-width', borderWidth);
                        group.appendChild(innerRect);
                    }
                }

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // VLINE（縦線）
            // ============================
            if (data.type === 'vline') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                // 行間幅を取得
                const lineGap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;

                // 背景（左右に行間幅の紙色背景）
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', -lineGap);
                shadowRect.setAttribute('y', 0);
                shadowRect.setAttribute('width', data.width + lineGap * 2);
                shadowRect.setAttribute('height', data.height);
                shadowRect.setAttribute('class', 'paper-fill');
                group.appendChild(shadowRect);

                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', data.width / 2);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', data.width / 2);
                line.setAttribute('y2', data.height);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', (data.lineWidth || 0.5) * PX_PER_MM);
                group.appendChild(line);

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('x', -lineGap);
                hitRect.setAttribute('y', 0);
                hitRect.setAttribute('width', data.width + lineGap * 2);
                hitRect.setAttribute('height', data.height);
                hitRect.setAttribute('class', 'hit-rect');
                group.appendChild(hitRect);
                return;
            }

            // ============================
            // FREETEXT（自由テキスト）
            // ============================
            if (data.type === 'freetext') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);

                const fo = document.createElementNS(SVG_NS, 'foreignObject');
                fo.setAttribute('x', 0);
                fo.setAttribute('y', 0);
                fo.setAttribute('width', data.width);
                fo.setAttribute('height', data.height);
                fo.setAttribute('pointer-events', 'none');

                const div = document.createElement('div');
                div.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
                div.style.width = '100%';
                div.style.height = '100%';
                div.style.display = 'flex';
                div.style.padding = '0';
                div.style.margin = '0';
                div.style.whiteSpace = 'pre-wrap';
                div.style.wordBreak = 'break-word';
                div.style.overflow = 'hidden';
                div.style.fontFamily = data.fontFamily || '"BIZ UDMincho", serif';
                div.style.fontSize = `${(data.fontSize || 4) * PX_PER_MM}px`;
                const colorSource = data.colorSource === 'paper' ? 'paper' : 'ink';
                const freetextColor = colorSource === 'paper'
                    ? (STATE.canvas.colors.paper || '#ffffff')
                    : (STATE.canvas.colors.ink || '#333333');
                div.style.color = freetextColor;
                div.style.fontWeight = (data.fontWeight !== undefined ? data.fontWeight : 400).toString();

                const direction = data.direction || 'vertical';
                const align = data.align || 'top-left';
                const [vAlign, hAlign] = align.split('-');

                if (direction === 'vertical') {
                    div.style.writingMode = 'vertical-rl';
                    div.style.textOrientation = 'upright';

                    // 上下 (justify-content)
                    const vPosMap = { top: 'flex-start', middle: 'center', bottom: 'flex-end' };
                    div.style.justifyContent = vPosMap[vAlign] || 'flex-start';
                    
                    // 左右 (align-items) - 縦書きでは flex-end が左揃えになる
                    const hPosMap = { left: 'flex-end', center: 'center', right: 'flex-start' };
                    div.style.alignItems = hPosMap[hAlign] || 'flex-start';

                } else { // horizontal
                    div.style.writingMode = 'horizontal-tb';
                    div.style.flexDirection = 'column'; // 横書きの時だけ column にする
                    div.style.justifyContent = { top: 'flex-start', middle: 'center', bottom: 'flex-end' }[vAlign] || 'flex-start';
                    div.style.alignItems = { left: 'flex-start', center: 'center', right: 'flex-end' }[hAlign] || 'flex-start';
                    div.style.textAlign = { left: 'left', center: 'center', right: 'right' }[hAlign] || 'left';
                }

                div.textContent = data.text || '';
                fo.appendChild(div);
                group.appendChild(fo);
                return;
            }

            // ============================
            // IMAGE（画像）
            // ============================
            if (data.type === 'image') {
                group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

                // クリップパスを作成
                const clipId = `clip-${data.id}`;
                const defs = document.createElementNS(SVG_NS, 'defs');
                const clipPath = document.createElementNS(SVG_NS, 'clipPath');
                clipPath.setAttribute('id', clipId);
                const clipRect = document.createElementNS(SVG_NS, 'rect');
                clipRect.setAttribute('x', 0);
                clipRect.setAttribute('y', 0);
                clipRect.setAttribute('width', data.width);
                clipRect.setAttribute('height', data.height);
                clipPath.appendChild(clipRect);
                const isCropPreviewActive = STATE.cropMode && STATE.selectedId === data.id;
                let previewMaskId;
                if (isCropPreviewActive) {
                    previewMaskId = `crop-preview-${data.id}`;
                    const previewMask = document.createElementNS(SVG_NS, 'mask');
                    previewMask.setAttribute('id', previewMaskId);
                    previewMask.setAttribute('maskUnits', 'userSpaceOnUse');
                    const outerRect = document.createElementNS(SVG_NS, 'rect');
                    outerRect.setAttribute('x', -1000);
                    outerRect.setAttribute('y', -1000);
                    outerRect.setAttribute('width', data.width + 2000);
                    outerRect.setAttribute('height', data.height + 2000);
                    outerRect.setAttribute('fill', 'white');
                    const innerRect = document.createElementNS(SVG_NS, 'rect');
                    innerRect.setAttribute('x', 0);
                    innerRect.setAttribute('y', 0);
                    innerRect.setAttribute('width', data.width);
                    innerRect.setAttribute('height', data.height);
                    innerRect.setAttribute('fill', 'black');
                    previewMask.appendChild(outerRect);
                    previewMask.appendChild(innerRect);
                    defs.appendChild(previewMask);
                }
                defs.appendChild(clipPath);
                group.appendChild(defs);

                const layout = computeImageCoverLayout(data);
                const scale = data.imageScale || 1.0;
                const offsetX = data.imageOffsetX || 0;
                const offsetY = data.imageOffsetY || 0;
                const imgW = layout.baseW * scale;
                const imgH = layout.baseH * scale;
                const imgX = layout.baseX + (layout.baseW - imgW) / 2 + offsetX;
                const imgY = layout.baseY + (layout.baseH - imgH) / 2 + offsetY;

                if (isCropPreviewActive && data.imageUrl) {
                    const previewImg = document.createElementNS(SVG_NS, 'image');
                    previewImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.imageUrl);
                    previewImg.setAttribute('x', imgX);
                    previewImg.setAttribute('y', imgY);
                    previewImg.setAttribute('width', imgW);
                    previewImg.setAttribute('height', imgH);
                    previewImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    previewImg.setAttribute('opacity', '0.45');
                    previewImg.setAttribute('mask', `url(#${previewMaskId})`);
                    previewImg.setAttribute('pointer-events', 'none');
                    group.appendChild(previewImg);
                }

                const bg = document.createElementNS(SVG_NS, 'rect');
                bg.setAttribute('x', 0);
                bg.setAttribute('y', 0);
                bg.setAttribute('width', data.width);
                bg.setAttribute('height', data.height);
                bg.setAttribute('class', 'paper-fill');
                group.appendChild(bg);

                if (data.imageUrl) {
                    const img = document.createElementNS(SVG_NS, 'image');
                    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.imageUrl);
                    img.setAttribute('x', imgX);
                    img.setAttribute('y', imgY);
                    img.setAttribute('width', imgW);
                    img.setAttribute('height', imgH);
                    img.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    img.setAttribute('clip-path', `url(#${clipId})`);
                    group.appendChild(img);
                }

                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width);
                hitRect.setAttribute('height', data.height);
                group.appendChild(hitRect);
                return;
            }


        }
        // --- Heading Helpers ---
        function getHeadingContentBounds(data) {
            // ボーダーとパディングを考慮した描画領域を計算
            let extraP = 0;
            if (data.type === 'masthead') {
                const bo = parseFloat(data.borderWidthOuter) * PX_PER_MM;
                const gap = bo;
                const bi = parseFloat(data.borderWidthInner) * PX_PER_MM;
                extraP = bo + gap + bi + (2 * PX_PER_MM);
            }

            // パディングを追加
            const paddingH = parseFloat(data.paddingH || 0) * PX_PER_MM;
            const paddingV = parseFloat(data.paddingV || 0) * PX_PER_MM;

            const totalOffsetX = extraP + paddingH;
            const totalOffsetY = extraP + paddingV;

            const contentW = Math.max(0, data.width - (totalOffsetX * 2));
            const contentH = Math.max(0, data.height - (totalOffsetY * 2));

            return {
                offsetX: totalOffsetX,
                offsetY: totalOffsetY,
                width: contentW,
                height: contentH
            };
        }

        // --- Border Rendering ---
        function renderBorder() {
            const layerBorder = document.getElementById('layer-border');
            if (!layerBorder) return;
            layerBorder.innerHTML = '';

            const m = STATE.canvas.margin;
            const w = STATE.canvas.width;
            const h = STATE.canvas.height;
            const offset = 3; // mm

            // 版面サイズ
            const contentX = m.left;
            const contentY = m.top;
            const contentW = w - m.left - m.right;
            const contentH = h - m.top - m.bottom;

            // 枠線座標 (版面から外側へ3mm)
            const x = (contentX - offset) * PX_PER_MM;
            const y = (contentY - offset) * PX_PER_MM;
            const width = (contentW + offset * 2) * PX_PER_MM;
            const height = (contentH + offset * 2) * PX_PER_MM;

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', 'none');
            rect.setAttribute('class', 'ink-stroke');
            const strokeWidth = 0.4 * PX_PER_MM; // 枠線の太さ
            rect.setAttribute('stroke-width', strokeWidth);
            rect.setAttribute('stroke-linejoin', 'miter');
            rect.setAttribute('pointer-events', 'none');

            layerBorder.appendChild(rect);

            // --- ヘッダーテキストの描画 ---
            renderHeaderTexts();

            // --- カラーパッチの描画 ---
            renderColorPatches();
        }

        function renderColorPatches() {
            const layerBorder = document.getElementById('layer-border');
            if (!layerBorder) return;

            // KWYMCKK の色定義（Kは常時真っ黒）
            const colors = [
                { name: 'K', color: '#000000' },  // Black (Key) - 常時真っ黒
                { name: 'W', color: '#FFFFFF' },  // White
                { name: 'Y', color: '#FFFF00' },  // Yellow
                { name: 'M', color: '#FF00FF' },  // Magenta
                { name: 'C', color: '#00FFFF' },  // Cyan
                { name: 'K', color: '#000000' },  // Black - 常時真っ黒
                { name: 'K', color: '#000000' }   // Black - 常時真っ黒
            ];

            const patchSize = 1; // mm (ダイヤの対角線)
            const spacing = 3; // mm
            const offsetBelow = 5; // mm (外枠下辺から下に5mm)

            const m = STATE.canvas.margin;
            const w = STATE.canvas.width;
            const h = STATE.canvas.height;
            const offset = 3; // 外枠のオフセット

            // 外枠の下辺位置
            const contentX = m.left;
            const contentY = m.top;
            const contentW = w - m.left - m.right;
            const contentH = h - m.top - m.bottom;
            const borderBottom = (contentY + contentH + offset) * PX_PER_MM;

            // パッチの総幅を計算
            const totalWidth = (colors.length * patchSize + (colors.length - 1) * spacing);
            const centerX = (w / 2) * PX_PER_MM;
            const startX = centerX - (totalWidth * PX_PER_MM / 2);
            const patchY = borderBottom + (offsetBelow * PX_PER_MM);

            // 各カラーパッチを描画
            colors.forEach((colorDef, index) => {
                const patchX = startX + (index * (patchSize + spacing) * PX_PER_MM);

                // ダイヤ形（45度回転した正方形）
                const diamond = document.createElementNS(SVG_NS, 'rect');
                const size = patchSize * PX_PER_MM;

                diamond.setAttribute('x', patchX);
                diamond.setAttribute('y', patchY);
                diamond.setAttribute('width', size);
                diamond.setAttribute('height', size);
                diamond.setAttribute('fill', colorDef.color);
                diamond.setAttribute('transform', `rotate(45 ${patchX + size / 2} ${patchY + size / 2})`);
                diamond.setAttribute('style', 'mix-blend-mode: multiply;');
                diamond.setAttribute('pointer-events', 'none');

                layerBorder.appendChild(diamond);
            });
        }

        function renderHeaderTexts() {
            const layerBorder = document.getElementById('layer-border');
            if (!layerBorder) return;

            const m = STATE.canvas.margin;
            const w = STATE.canvas.width;
            const contentX = m.left;
            const contentY = m.top;
            const contentW = w - m.left - m.right;

            // ヘッダーのY位置（版面上端の5mm上）
            const headerY = (contentY - 8) * PX_PER_MM;

            // 左揃え
            if (STATE.header.left.text) {
                const textEl = document.createElementNS(SVG_NS, 'text');
                textEl.textContent = STATE.header.left.text;
                textEl.setAttribute('x', contentX * PX_PER_MM);
                textEl.setAttribute('y', headerY);
                textEl.setAttribute('font-family', STATE.header.left.fontFamily);
                textEl.setAttribute('font-size', STATE.header.left.fontSize * PX_PER_MM);
                textEl.setAttribute('font-weight', STATE.header.left.fontWeight);
                textEl.setAttribute('text-anchor', 'start');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('class', 'ink-fill');
                textEl.style.fontFamily = STATE.header.left.fontFamily;
                if (STATE.header.left.letterSpacing !== 0) {
                    textEl.setAttribute('letter-spacing', STATE.header.left.letterSpacing * PX_PER_MM);
                }
                const leftLineHeight = STATE.header.left.lineHeight;
                if (leftLineHeight !== undefined && leftLineHeight !== null) {
                    textEl.style.lineHeight = `${leftLineHeight * PX_PER_MM}px`;
                }
                layerBorder.appendChild(textEl);
            }

            // 中央揃え
            if (STATE.header.center.text) {
                const textEl = document.createElementNS(SVG_NS, 'text');
                textEl.textContent = STATE.header.center.text;
                textEl.setAttribute('x', (contentX + contentW / 2) * PX_PER_MM);
                textEl.setAttribute('y', headerY);
                textEl.setAttribute('font-family', STATE.header.center.fontFamily);
                textEl.setAttribute('font-size', STATE.header.center.fontSize * PX_PER_MM);
                textEl.setAttribute('font-weight', STATE.header.center.fontWeight);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('class', 'ink-fill');
                textEl.style.fontFamily = STATE.header.center.fontFamily;
                if (STATE.header.center.letterSpacing !== 0) {
                    textEl.setAttribute('letter-spacing', STATE.header.center.letterSpacing * PX_PER_MM);
                }
                const centerLineHeight = STATE.header.center.lineHeight;
                if (centerLineHeight !== undefined && centerLineHeight !== null) {
                    textEl.style.lineHeight = `${centerLineHeight * PX_PER_MM}px`;
                }
                layerBorder.appendChild(textEl);
            }

            // 右揃え
            if (STATE.header.right.text) {
                const textEl = document.createElementNS(SVG_NS, 'text');
                textEl.textContent = STATE.header.right.text;
                textEl.setAttribute('x', (contentX + contentW) * PX_PER_MM);
                textEl.setAttribute('y', headerY);
                textEl.setAttribute('font-family', STATE.header.right.fontFamily);
                textEl.setAttribute('font-size', STATE.header.right.fontSize * PX_PER_MM);
                textEl.setAttribute('font-weight', STATE.header.right.fontWeight);
                textEl.setAttribute('text-anchor', 'end');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('class', 'ink-fill');
                textEl.style.fontFamily = STATE.header.right.fontFamily;
                if (STATE.header.right.letterSpacing !== 0) {
                    textEl.setAttribute('letter-spacing', STATE.header.right.letterSpacing * PX_PER_MM);
                }
                const rightLineHeight = STATE.header.right.lineHeight;
                if (rightLineHeight !== undefined && rightLineHeight !== null) {
                    textEl.style.lineHeight = `${rightLineHeight * PX_PER_MM}px`;
                }
                layerBorder.appendChild(textEl);
            }
        }

        // --- Character Count Info ---
        function calculateMaxCapacity(data) {
            const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
            let segments;
            if (useSnapMode) {
                segments = getIntersectingDans(data);
            } else {
                segments = [{ height: data.height, localY: 0 }];
            }

            let totalCapacity = 0;
            for (const seg of segments) {
                const metrics = getLayoutMetrics(data, seg.height, useSnapMode);
                const { charsPerLine, maxLines } = metrics;
                const baseCapacity = charsPerLine * maxLines;
                totalCapacity += baseCapacity;
            }
            return totalCapacity;
        }

        function updateCharInfo(data) {
            if (data.type !== 'text') return;

            const charCurrentEl = document.getElementById('char-current');
            const charCapacityEl = document.getElementById('char-capacity');
            const charOverflowEl = document.getElementById('char-overflow');

            const head = findChainHead(data);
            const fullText = head.text || "";
            const currentCount = fullText.length;

            let totalCapacity = 0;
            let curr = head;
            while (curr) {
                totalCapacity += calculateMaxCapacity(curr);
                curr = curr.next ? STATE.elements.find(el => el.id === curr.next) : null;
            }

            const overflow = Math.max(0, currentCount - totalCapacity);

            charCurrentEl.textContent = currentCount;
            charCapacityEl.textContent = totalCapacity;
            charOverflowEl.textContent = overflow;

            if (overflow > 0) {
                charOverflowEl.style.color = '#f44336';
                charOverflowEl.style.fontWeight = 'bold';
            } else {
                charOverflowEl.style.color = '#666';
                charOverflowEl.style.fontWeight = 'normal';
            }
        }

        // --- UI/Updates ---
        function renderUi() {
            if (STATE.interactionType === 'resize' || STATE.interactionType === 'drag') {
                if (STATE.selectedId) {
                    const data = STATE.elements.find(e => e.id === STATE.selectedId);
                    if (data) updateUiPositions(data);
                }
                return;
            }
            layerUi.innerHTML = ''; renderMarginGuide();
            document.getElementById('prop-panel-none').style.display = 'none';
            document.getElementById('prop-panel-text').style.display = 'none';
            document.getElementById('prop-panel-heading').style.display = 'none';
            document.getElementById('prop-panel-masthead').style.display = 'none';
            document.getElementById('prop-panel-rect').style.display = 'none';
            document.getElementById('prop-panel-image').style.display = 'none';
            document.getElementById('prop-panel-freetext').style.display = 'none';

            if (!STATE.selectedId) { document.getElementById('prop-panel-none').style.display = 'block'; return; }
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data) return;

            if (data.type === 'text') {
                document.getElementById('prop-panel-text').style.display = 'block';

                const isChild = (data.prev !== undefined && data.prev !== null);
                const infoEl = document.getElementById('text-link-info');
                const txtArea = document.getElementById('inp-text');

                if (isChild) {
                    infoEl.style.display = 'block';
                    txtArea.disabled = true;
                    txtArea.value = "(リンク元のテキストを表示中)";
                } else {
                    infoEl.style.display = 'none';
                    txtArea.disabled = false;
                    if (document.activeElement.id !== 'inp-text') txtArea.value = data.text;
                }

                document.getElementById('inp-fontfamily').value = data.fontFamily;
                document.getElementById('inp-snap-article-txt').checked = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;

                updateCharInfo(data);
            } else if (data.type === 'heading') {
                document.getElementById('prop-panel-heading').style.display = 'block';
                if (document.activeElement.id !== 'inp-heading-text') document.getElementById('inp-heading-text').value = data.text;
                document.getElementById('inp-heading-font').value = data.fontFamily;
                document.getElementById('inp-heading-pv').value = data.paddingV;
                document.getElementById('inp-heading-pv-slider').value = data.paddingV;
                document.getElementById('inp-heading-ph').value = data.paddingH;
                document.getElementById('inp-heading-ph-slider').value = data.paddingH;
                document.getElementById('inp-heading-inverted').checked = data.inverted || false;
            } else if (data.type === 'masthead') {
                document.getElementById('prop-panel-masthead').style.display = 'block';
                if (document.activeElement.id !== 'inp-masthead-text') document.getElementById('inp-masthead-text').value = data.text;
                document.getElementById('inp-masthead-font').value = data.fontFamily;
                document.getElementById('inp-masthead-inverted').checked = data.inverted || false;

                document.getElementById('inp-masthead-bo').value = data.borderWidthOuter;
                document.getElementById('inp-masthead-bo-slider').value = data.borderWidthOuter;

                document.getElementById('inp-masthead-bi').value = data.borderWidthInner;
                document.getElementById('inp-masthead-bi-slider').value = data.borderWidthInner;

                document.getElementById('inp-masthead-pl').value = data.patternLineHeight;
                document.getElementById('inp-masthead-pl-slider').value = data.patternLineHeight;

                document.getElementById('inp-masthead-ph').value = data.paddingH;
                document.getElementById('inp-masthead-ph-slider').value = data.paddingH;

                document.getElementById('inp-masthead-pv').value = data.paddingV;
                document.getElementById('inp-masthead-pv-slider').value = data.paddingV;

                document.getElementById('inp-masthead-ts').value = data.textStrokeWidth;
                document.getElementById('inp-masthead-ts-slider').value = data.textStrokeWidth;
            } else if (data.type === 'rect') {
                document.getElementById('prop-panel-rect').style.display = 'block';
                document.getElementById('inp-rect-ink').checked = (data.fillMode === 'ink');
                document.getElementById('inp-rect-border-style').value = data.borderStyle || 'none';
                document.getElementById('inp-rect-border-w').value = data.borderWidth || 0.5;
                document.getElementById('inp-rect-border-w-slider').value = data.borderWidth || 0.5;
            } else if (data.type === 'vline') {
                document.getElementById('prop-panel-vline').style.display = 'block';
                document.getElementById('inp-vline-width').value = data.lineWidth || 0.5;
                document.getElementById('inp-vline-width-slider').value = data.lineWidth || 0.5;
            } else if (data.type === 'image') {
                document.getElementById('prop-panel-image').style.display = 'block';

                const infoEl = document.getElementById('image-info');
                if (data.imageUrl) {
                    const widthPx = Math.ceil(data.width);
                    const heightPx = Math.ceil(data.height);
                    infoEl.textContent = `画像が設定されています (${widthPx}px×${heightPx}px)`;
                } else {
                    infoEl.textContent = '画像を選択してください';
                }

                // カラーモード設定を更新
                const colorMode = data.colorMode || 'fullcolor';
                document.getElementById('inp-image-colormode').value = colorMode;

                // インクモード設定の表示/非表示
                const inkSettings = document.getElementById('image-ink-settings');
                if (colorMode === 'ink') {
                    inkSettings.style.display = 'block';
                    document.getElementById('inp-image-contrast').value = data.contrast || 100;
                    document.getElementById('label-image-contrast').textContent = data.contrast || 100;
                    document.getElementById('inp-image-brightness').value = data.brightness || 100;
                    document.getElementById('label-image-brightness').textContent = data.brightness || 100;
                } else {
                    inkSettings.style.display = 'none';
                }

                if (STATE.cropMode && data.imageUrl && data._imageAspect) {
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;

                    let baseW, baseH, baseX, baseY;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                        baseX = (data.width - baseW) / 2;
                        baseY = 0;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                        baseX = 0;
                        baseY = (data.height - baseH) / 2;
                    }

                    const scale = data.imageScale || 1.0;
                    const offsetX = data.imageOffsetX || 0;
                    const offsetY = data.imageOffsetY || 0;

                    const imgW = baseW * scale;
                    const imgH = baseH * scale;
                    const imgX = data.x + baseX + (baseW - imgW) / 2 + offsetX;
                    const imgY = data.y + baseY + (baseH - imgH) / 2 + offsetY;

                    const boxFrame = document.createElementNS(SVG_NS, 'rect');
                    boxFrame.setAttribute('x', data.x);
                    boxFrame.setAttribute('y', data.y);
                    boxFrame.setAttribute('width', data.width);
                    boxFrame.setAttribute('height', data.height);
                    boxFrame.setAttribute('fill', 'none');
                    boxFrame.setAttribute('stroke', '#00ff00');
                    boxFrame.setAttribute('stroke-width', '2');
                    boxFrame.setAttribute('stroke-dasharray', '5,5');
                    layerUi.appendChild(boxFrame);

                    const imgFrame = document.createElementNS(SVG_NS, 'rect');
                    imgFrame.setAttribute('x', imgX);
                    imgFrame.setAttribute('y', imgY);
                    imgFrame.setAttribute('width', imgW);
                    imgFrame.setAttribute('height', imgH);
                    imgFrame.setAttribute('fill', 'none');
                    imgFrame.setAttribute('stroke', '#ff00ff');
                    imgFrame.setAttribute('stroke-width', '2');
                    imgFrame.setAttribute('cursor', 'move');
                    imgFrame.classList.add('image-drag-area');
                    layerUi.appendChild(imgFrame);

                    const handleSize = 10;
                    const createScaleHandle = (x, y, corner) => {
                        const handle = document.createElementNS(SVG_NS, 'rect');
                        handle.setAttribute('x', x - handleSize / 2);
                        handle.setAttribute('y', y - handleSize / 2);
                        handle.setAttribute('width', handleSize);
                        handle.setAttribute('height', handleSize);
                        handle.setAttribute('fill', '#ff00ff');
                        handle.setAttribute('stroke', 'white');
                        handle.setAttribute('stroke-width', '1');
                        handle.setAttribute('cursor', corner === 'nw' || corner === 'se' ? 'nwse-resize' : 'nesw-resize');
                        handle.setAttribute('data-scale-corner', corner);
                        handle.classList.add('image-scale-handle');
                        layerUi.appendChild(handle);
                    };

                    createScaleHandle(imgX, imgY, 'nw');
                    createScaleHandle(imgX + imgW, imgY, 'ne');
                    createScaleHandle(imgX, imgY + imgH, 'sw');
                    createScaleHandle(imgX + imgW, imgY + imgH, 'se');

                    return;
                }
            } else if (data.type === 'freetext') {
                document.getElementById('prop-panel-freetext').style.display = 'block';
                if (document.activeElement.id !== 'inp-freetext') document.getElementById('inp-freetext').value = data.text;
                document.getElementById('inp-freetext-font').value = data.fontFamily;
                document.getElementById('inp-freetext-size').value = data.fontSize;
                document.getElementById('inp-freetext-size-slider').value = data.fontSize;

                const directionRadios = document.getElementsByName('freetext-direction');
                for (const radio of directionRadios) {
                    radio.checked = (radio.value === data.direction);
                }

                updateFreetextAlignDirectionIndicators(data.direction);
                updateFreetextAlignButtons(data);
                document.getElementById('inp-freetext-weight').value = data.fontWeight || 400;
                document.getElementById('inp-freetext-weight-slider').value = data.fontWeight || 400;
                updateFreetextColorButtons(data);
            }

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.id = 'ui-selection-rect';
            rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
            rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);

            let selClass = 'selection-rect';
            if (data.type === 'heading') selClass += ' heading-select';
            if (data.type === 'masthead') selClass += ' masthead-select';
            rect.setAttribute('class', selClass);
            layerUi.appendChild(rect);

            const isHeading = (data.type === 'heading');
            const isMasthead = (data.type === 'masthead');
            createHandle(data.x, data.y, 'nw', isHeading, isMasthead);
            createHandle(data.x + data.width, data.y, 'ne', isHeading, isMasthead);
            createHandle(data.x, data.y + data.height, 'sw', isHeading, isMasthead);
            createHandle(data.x + data.width, data.y + data.height, 'se', isHeading, isMasthead);

            if (data.type === 'text') {
                createLinkHandle(data);
            }
        }

        function createLinkHandle(data) {
            const size = 10;
            const x = data.x + data.width / 2 - size / 2;
            const y = data.y + data.height; // Bottom center

            const g = document.createElementNS(SVG_NS, 'g');

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', x); rect.setAttribute('y', y);
            rect.setAttribute('width', size); rect.setAttribute('height', size);
            rect.setAttribute('class', 'link-handle-rect' + (data.next ? ' connected' : ''));

            const hit = document.createElementNS(SVG_NS, 'rect');
            hit.setAttribute('x', x - 5); hit.setAttribute('y', y - 5);
            hit.setAttribute('width', size + 10); hit.setAttribute('height', size + 10);
            hit.setAttribute('class', 'link-handle-hit');

            g.appendChild(rect);
            g.appendChild(hit);
            layerUi.appendChild(g);
        }

        // 接続可能な候補を全て線枠表示する
        function showLinkCandidates(sourceId) {
            STATE.elements.forEach(el => {
                if (el.id === sourceId) return;
                if (el.type !== 'text') return;
                if (el.next || el.prev) return;

                const group = document.getElementById(el.id);
                if (group) group.classList.add('link-candidate');
            });
        }

        function clearLinkCandidates() {
            document.querySelectorAll('.link-candidate').forEach(el => el.classList.remove('link-candidate'));
            document.querySelectorAll('.highlight-target').forEach(el => el.classList.remove('highlight-target'));
        }

        function updateLinkHighlight(targetId) {
            const highlights = document.querySelectorAll('.highlight-target');
            highlights.forEach(el => el.classList.remove('highlight-target'));

            if (targetId) {
                const group = document.getElementById(targetId);
                if (group) group.classList.add('highlight-target');
            }
        }

        function updateUiPositions(data) {
            const rect = document.getElementById('ui-selection-rect');
            if (rect) {
                rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
                rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
            }
            const setPos = (sel, x, y) => {
                const group = layerUi.querySelector(sel);
                if (group) group.querySelectorAll('circle').forEach(c => { c.setAttribute('cx', x); c.setAttribute('cy', y); });
            };
            setPos('.cursor-nw', data.x, data.y); setPos('.cursor-ne', data.x + data.width, data.y);
            setPos('.cursor-sw', data.x, data.y + data.height); setPos('.cursor-se', data.x + data.width, data.y + data.height);

            const linkHandle = layerUi.querySelector('.link-handle-rect');
            const linkHit = layerUi.querySelector('.link-handle-hit');
            if (linkHandle && linkHit) {
                const size = 10;
                const lx = data.x + data.width / 2 - size / 2;
                const ly = data.y + data.height;
                linkHandle.setAttribute('x', lx); linkHandle.setAttribute('y', ly);
                linkHit.setAttribute('x', lx - 5); linkHit.setAttribute('y', ly - 5);
            }
        }

        function createHandle(x, y, dir, isHeading, isMasthead) {
            const group = document.createElementNS(SVG_NS, 'g');
            let classes = `handle-group cursor-${dir}`;
            if (isHeading) classes += ' heading-handle';
            if (isMasthead) classes += ' masthead-handle';

            group.setAttribute('class', classes);
            const hitArea = document.createElementNS(SVG_NS, 'circle');
            hitArea.setAttribute('cx', x); hitArea.setAttribute('cy', y); hitArea.setAttribute('r', 30);
            hitArea.setAttribute('class', 'resize-handle-hit');
            const visible = document.createElementNS(SVG_NS, 'circle');
            visible.setAttribute('cx', x); visible.setAttribute('cy', y); visible.setAttribute('r', 6);
            visible.setAttribute('class', 'resize-handle-visual');
            group.appendChild(visible); group.appendChild(hitArea);
            layerUi.appendChild(group);
        }

        function selectElement(id) { STATE.selectedId = id; renderUi(); }
        function deleteSelected() {
            if (!STATE.selectedId) return;
            const id = STATE.selectedId;
            const data = STATE.elements.find(e => e.id === id);
            if (data && data.type === 'text') {
                if (data.next) {
                    const next = STATE.elements.find(e => e.id === data.next);
                    if (next) {
                        next.prev = null;
                        delete next._renderedText;
                        if (!next.text) next.text = ensureLeadingFullwidthSpacePerLine("新規記事");
                        renderElement(next);
                    }
                }
                if (data.prev) {
                    const prev = STATE.elements.find(e => e.id === data.prev);
                    if (prev) {
                        prev.next = null;
                        const head = findChainHead(prev);
                        updateTextChain(head);
                    }
                }
            }

            const pattern = document.getElementById('pat-' + id);
            if (pattern) pattern.remove();
            const clip = document.getElementById('clip-' + id);
            if (clip) clip.remove();

            document.getElementById(id).remove();
            STATE.elements = STATE.elements.filter(e => e.id !== id);
            STATE.selectedId = null; renderUi();
        }

        function updateSelectedText() {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (data && data.type === 'text') {
                if (!data.prev) {
                    const textarea = document.getElementById('inp-text');
                    data.text = textarea.value;
                    updateTextChain(data);
                    updateCharInfo(data);
                }
            }
        }
        function updateSelectedStyle() {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (data && data.type === 'text') {
                data.fontFamily = document.getElementById('inp-fontfamily').value;
                const head = findChainHead(data);
                updateTextChain(head);
                updateUiPositions(data);
            }
        }

        function updateHeadingProp(key, subKey, val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'heading') return;

            if (key === 'text') data.text = document.getElementById('inp-heading-text').value;
            if (key === 'fontFamily') data.fontFamily = document.getElementById('inp-heading-font').value;
            if (key === 'inverted') data.inverted = document.getElementById('inp-heading-inverted').checked;

            if (key === 'padding') {
                const numVal = parseFloat(val);
                if (subKey === 'h') {
                    data.paddingH = numVal;
                    document.getElementById('inp-heading-ph').value = numVal;
                    document.getElementById('inp-heading-ph-slider').value = numVal;
                } else if (subKey === 'v') {
                    data.paddingV = numVal;
                    document.getElementById('inp-heading-pv').value = numVal;
                    document.getElementById('inp-heading-pv-slider').value = numVal;
                }
            }
            renderElement(data);
        }

        function updateMastheadProp(key, val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'masthead') return;

            if (key === 'text') data.text = document.getElementById('inp-masthead-text').value;
            if (key === 'fontFamily') data.fontFamily = document.getElementById('inp-masthead-font').value;
            if (key === 'inverted') data.inverted = document.getElementById('inp-masthead-inverted').checked;

            if (key === 'borderWidthOuter') {
                data.borderWidthOuter = val;
                document.getElementById('inp-masthead-bo').value = val;
                document.getElementById('inp-masthead-bo-slider').value = val;
            }
            if (key === 'borderWidthInner') {
                data.borderWidthInner = val;
                document.getElementById('inp-masthead-bi').value = val;
                document.getElementById('inp-masthead-bi-slider').value = val;
            }
            if (key === 'patternLineHeight') {
                data.patternLineHeight = val;
                document.getElementById('inp-masthead-pl').value = val;
                document.getElementById('inp-masthead-pl-slider').value = val;
            }

            if (key === 'paddingH') {
                data.paddingH = val;
                document.getElementById('inp-masthead-ph').value = val;
                document.getElementById('inp-masthead-ph-slider').value = val;
            }
            if (key === 'paddingV') {
                data.paddingV = val;
                document.getElementById('inp-masthead-pv').value = val;
                document.getElementById('inp-masthead-pv-slider').value = val;
            }
            if (key === 'textStrokeWidth') {
                data.textStrokeWidth = val;
                document.getElementById('inp-masthead-ts').value = val;
                document.getElementById('inp-masthead-ts-slider').value = val;
            }

            renderElement(data);
        }

        function updateRectProp(key, val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'rect') return;

            const isInk = document.getElementById('inp-rect-ink').checked;
            data.fillMode = isInk ? 'ink' : 'paper';

            data.borderStyle = document.getElementById('inp-rect-border-style').value;

            if (key === 'width') {
                const w = parseFloat(val);
                data.borderWidth = w;
                document.getElementById('inp-rect-border-w').value = w;
                document.getElementById('inp-rect-border-w-slider').value = w;
            }

            renderElement(data);
        }

        function updateVlineProp(val) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'vline') return;

            const w = parseFloat(val);
            data.lineWidth = w;
            document.getElementById('inp-vline-width').value = w;
            document.getElementById('inp-vline-width-slider').value = w;

            renderElement(data);
        }

        async function updateImageProp(key) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'image') return;

            if (key === 'colorMode') {
                const colorMode = document.getElementById('inp-image-colormode').value;
                data.colorMode = colorMode;

                // インクモード設定の表示/非表示
                const inkSettings = document.getElementById('image-ink-settings');
                if (colorMode === 'ink') {
                    inkSettings.style.display = 'block';
                } else {
                    inkSettings.style.display = 'none';
                }
            } else if (key === 'contrast') {
                const val = parseInt(document.getElementById('inp-image-contrast').value);
                data.contrast = val;
                document.getElementById('label-image-contrast').textContent = val;
            } else if (key === 'brightness') {
                const val = parseInt(document.getElementById('inp-image-brightness').value);
                data.brightness = val;
                document.getElementById('label-image-brightness').textContent = val;
            }

            // カラーモードを再適用
            await applyImageColorMode(data);
            renderElement(data);
        }

        function updateFreeTextProp(prop, value) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'freetext') return;

            let shouldRefreshPanel = false;
            if (prop === 'text') {
                data.text = document.getElementById('inp-freetext').value;
            } else if (prop === 'direction') {
                const directionRadios = document.getElementsByName('freetext-direction');
                for (const radio of directionRadios) {
                    if (radio.checked) {
                        data.direction = radio.value;
                        shouldRefreshPanel = true;
                        break;
                    }
                }
            } else if (prop === 'fontFamily') {
                data.fontFamily = document.getElementById('inp-freetext-font').value;
            } else if (prop === 'fontSize') {
                const size = parseFloat(document.activeElement.value);
                data.fontSize = size;
                document.getElementById('inp-freetext-size').value = size;
                document.getElementById('inp-freetext-size-slider').value = size;
            } else if (prop === 'fontWeight') {
                const rawValue = value !== undefined ? value : document.activeElement.value;
                const weight = parseInt(rawValue, 10) || 400;
                data.fontWeight = weight;
                document.getElementById('inp-freetext-weight').value = weight;
                document.getElementById('inp-freetext-weight-slider').value = weight;
            } else if (prop === 'colorSource') {
                data.colorSource = value || 'ink';
                updateFreetextColorButtons(data);
            }

            renderElement(data);
            if (shouldRefreshPanel) renderUi();
        }

        function setFreetextAlign(align) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'freetext') return;
            data.align = align;
            renderElement(data);
            updateFreetextAlignButtons(data);
        }

        function updateFreetextAlignButtons(data) {
            if (!data) return;
            const currentAlign = data.align || 'start-start';
            document.querySelectorAll('#freetext-align-grid .align-grid-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.align === currentAlign);
            });
        }

        function updateFreetextAlignDirectionIndicators(direction) {
            // 不要になったが互換性のため残す
        }

        function updateFreetextColorButtons(data) {
            const activeSource = data?.colorSource || 'ink';
            document.querySelectorAll('#prop-panel-freetext .color-toggle-btn').forEach(btn => {
                const source = btn.dataset.colorSource;
                btn.classList.toggle('active', source === activeSource);
            });
        }

        function toggleCropMode() {
            STATE.cropMode = !STATE.cropMode;
            const btn = document.getElementById('btn-crop-mode');
            if (STATE.cropMode) {
                btn.textContent = 'トリミング完了';
                btn.style.backgroundColor = '#4CAF50';
            } else {
                btn.textContent = 'トリミング調整';
                btn.style.backgroundColor = '';
            }
            renderUi();
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (data && data.type === 'image') {
                renderElement(data);
            }
        }

        function loadImageFile(input) {
            const data = STATE.elements.find(e => e.id === STATE.selectedId);
            if (!data || data.type !== 'image') return;

            const file = input.files[0];
            if (!file) return;

            loadImageToElement(file, data);
        }

        // --- Export & Utils ---
        function fitView() {
            const vw = viewport.clientWidth; const vh = viewport.clientHeight;
            const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
            const margin = 40;
            const scale = Math.min((vw - margin * 2) / w_px, (vh - margin * 2) / h_px);
            STATE.view.scale = Math.max(0.1, Math.min(scale, 5.0));
            STATE.view.x = (vw - w_px * STATE.view.scale) / 2; STATE.view.y = (vh - h_px * STATE.view.scale) / 2;
            updateTransform();
        }
        function updateTransform() { canvasContainer.style.transform = `translate(${STATE.view.x}px, ${STATE.view.y}px) scale(${STATE.view.scale})`; }

        function updateCanvasSize() {
            const w = parseFloat(document.getElementById('inp-canvas-w').value);
            const h = parseFloat(document.getElementById('inp-canvas-h').value);
            STATE.canvas.width = w; STATE.canvas.height = h;

            // 余白の値をSTATEに反映
            STATE.canvas.margin.top = parseFloat(document.getElementById('inp-margin-t').value) || 20;
            STATE.canvas.margin.bottom = parseFloat(document.getElementById('inp-margin-b').value) || 20;
            STATE.canvas.margin.left = parseFloat(document.getElementById('inp-margin-l').value) || 20;
            STATE.canvas.margin.right = parseFloat(document.getElementById('inp-margin-r').value) || 20;

            mainSvg.setAttribute('width', w * PX_PER_MM); mainSvg.setAttribute('height', h * PX_PER_MM);
            mainSvg.setAttribute('viewBox', `0 0 ${w * PX_PER_MM} ${h * PX_PER_MM}`);
            updateGridSettings(); renderMarginGuide(); renderBorder();
        }
        function updateGridSettings() {
            STATE.grid.show = document.getElementById('inp-layout-show').checked;
            STATE.grid.dan = parseInt(document.getElementById('inp-layout-dan').value);
            STATE.grid.charsPerDan = parseInt(document.getElementById('inp-layout-chars').value);
            STATE.grid.totalLines = parseInt(document.getElementById('inp-layout-lines').value);
            renderPaperGrid();
        }
        function renderMarginGuide() {
            const old = document.getElementById('margin-guide-rect'); if (old) old.remove();
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const ml = STATE.canvas.margin.left * PX_PER_MM;
            const w = STATE.canvas.width * PX_PER_MM;
            const h = STATE.canvas.height * PX_PER_MM;
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.id = 'margin-guide-rect';
            rect.setAttribute('x', ml); rect.setAttribute('y', mt);
            rect.setAttribute('width', w - ml - STATE.canvas.margin.right * PX_PER_MM);
            rect.setAttribute('height', h - mt - STATE.canvas.margin.bottom * PX_PER_MM);
            rect.setAttribute('class', 'margin-guide');
            layerUi.appendChild(rect);
        }
        function renderPaperGrid() {
            layerPaperGrid.innerHTML = '';

            // グリッド計算は常に実行（段間罫線のために必要）
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
            const validH = h_px - mt - STATE.canvas.margin.bottom * PX_PER_MM;
            const validW = w_px - STATE.canvas.margin.left * PX_PER_MM - STATE.canvas.margin.right * PX_PER_MM;
            const totalHUnits = (STATE.grid.charsPerDan * STATE.grid.dan) + (STATE.grid.dan - 1);
            const unitH = validH / totalHUnits;
            const danPitch = (STATE.grid.charsPerDan * unitH) + unitH;
            const fontSizeW = unitH / CHAR_SCALE_RATIO;
            const pitchX = fontSizeW + (STATE.grid.totalLines > 1 ? (validW - fontSizeW * STATE.grid.totalLines) / (STATE.grid.totalLines - 1) : 0);
            STATE.grid.computed = { charSizeW: fontSizeW, charSizeH: unitH, danHeight: unitH * STATE.grid.charsPerDan, danPitch, pitchX, lineGap: (pitchX - fontSizeW) };
            document.getElementById('grid-info').innerHTML = `文字サイズ: ${(fontSizeW / PX_PER_MM).toFixed(2)}mm`;

            // 段間罫線を描画（グリッド表示のON/OFFに関係なく）
            renderDanLines();

            // グリッド表示がOFFならここで終了
            if (!STATE.grid.show) return;

            // グリッド描画
            const mr = STATE.canvas.margin.right * PX_PER_MM;
            for (let l = 0; l < STATE.grid.totalLines; l++) {
                const lineX = (w_px - mr) - fontSizeW - (l * STATE.grid.computed.pitchX);
                for (let d = 0; d < STATE.grid.dan; d++) {
                    const startY = mt + (d * danPitch);
                    for (let c = 0; c < STATE.grid.charsPerDan; c++) {
                        const rect = document.createElementNS(SVG_NS, 'rect');
                        rect.setAttribute('x', lineX); rect.setAttribute('y', startY + (c * unitH));
                        rect.setAttribute('width', fontSizeW); rect.setAttribute('height', unitH);
                        rect.setAttribute('class', 'grid-rect');
                        layerPaperGrid.appendChild(rect);
                    }
                }
            }
        }

        // 段間罫線の描画
        function renderDanLines() {
            console.log('[renderDanLines] 呼び出し');
            const layerDanLines = document.getElementById('layer-dan-lines');
            if (!layerDanLines) {
                console.log('[renderDanLines] layer-dan-lines が見つからない');
                return;
            }
            layerDanLines.innerHTML = '';

            console.log('[renderDanLines] STATE.grid:', {
                dan: STATE.grid.dan,
                computed: STATE.grid.computed,
                hasDanPitch: STATE.grid.computed?.danPitch
            });

            // 段数が1以下の場合や計算値がない場合は描画しない
            if (STATE.grid.dan <= 1) {
                console.log('[renderDanLines] 段数が1以下でスキップ');
                return;
            }
            if (!STATE.grid.computed || !STATE.grid.computed.danPitch) {
                console.log('[renderDanLines] computed未計算でスキップ');
                return;
            }
            console.log('[renderDanLines] 描画実行');

            const danPitch = STATE.grid.computed.danPitch;
            const danHeight = STATE.grid.computed.danHeight;
            const mt = STATE.canvas.margin.top * PX_PER_MM;
            const ml = STATE.canvas.margin.left * PX_PER_MM;
            const w_px = STATE.canvas.width * PX_PER_MM;
            const validW = w_px - ml - STATE.canvas.margin.right * PX_PER_MM;

            const gap = danPitch - danHeight;
            const lineX1 = ml;
            const lineX2 = ml + validW;
            const strokeWidth = 0.4 * PX_PER_MM;

            // 段間罫線を描画（段数-1本）
            for (let i = 0; i < STATE.grid.dan - 1; i++) {
                const lineY = mt + (i + 1) * danHeight + (i + 0.5) * gap;

                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', lineX1);
                line.setAttribute('y1', lineY);
                line.setAttribute('x2', lineX2);
                line.setAttribute('y2', lineY);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('fill', 'none');
                line.setAttribute('pointer-events', 'none');
                layerDanLines.appendChild(line);
            }

            // レイヤーを明示的に可視化
            layerDanLines.style.visibility = 'visible';
            layerDanLines.style.opacity = '1';
            layerDanLines.style.display = '';
        }
        async function updateColors() {
            const paperC = document.getElementById('inp-paper-color').value;
            const inkC = document.getElementById('inp-ink-color').value;
            STATE.canvas.colors.paper = paperC; STATE.canvas.colors.ink = inkC;
            svgStyle.textContent = `
            .hit-rect { fill: #ffffff; fill-opacity: 0; pointer-events: all; }
            .ink-fill { fill: ${inkC}; } .ink-stroke { stroke: ${inkC}; }
            .paper-fill { fill: ${paperC}; } .paper-stroke { stroke: ${paperC}; }
            text { fill: ${inkC}; }
        `;
            renderBorder();

            // 全要素を再描画（画像は必要ならインク処理も再実行）
            for (const data of STATE.elements) {
                if (data.type === 'image' && data.colorMode === 'ink' && data._originalImageUrl) {
                    await applyImageColorMode(data);
                }
                renderElement(data);
            }
        }

        // --- ヘッダーテキスト更新関数 ---
        function updateHeaderText(position) {
            STATE.header[position].text = document.getElementById(`inp-header-${position}-text`).value;
            renderBorder();
        }

        function updateHeaderFont(position) {
            STATE.header[position].fontFamily = document.getElementById(`inp-header-${position}-font`).value;
            renderBorder();
        }

        function updateHeaderWeight(position) {
            STATE.header[position].fontWeight = parseInt(document.getElementById(`inp-header-${position}-weight`).value);
            renderBorder();
        }

        function updateHeaderSize(position) {
            STATE.header[position].fontSize = parseFloat(document.getElementById(`inp-header-${position}-size`).value);
            renderBorder();
        }

        function updateHeaderSpacing(position) {
            STATE.header[position].letterSpacing = parseFloat(document.getElementById(`inp-header-${position}-spacing`).value);
            renderBorder();
        }

        async function urlToBase64(url) {
            try {
                const res = await fetch(url); const blob = await res.blob();
                return new Promise(r => { const reader = new FileReader(); reader.onloadend = () => r(reader.result); reader.readAsDataURL(blob); });
            } catch { return null; }
        }
        async function getEmbeddableFontCss(cssUrl) {
            try {
                const res = await fetch(cssUrl); let cssText = await res.text();
                const urlRegex = /url\((['"]?)(https:\/\/[^'"\)]+)\1\)/g; let match; const replacements = [];
                while ((match = urlRegex.exec(cssText)) !== null) replacements.push({ original: match[0], url: match[2] });
                const uniqueUrls = [...new Set(replacements.map(r => r.url))];
                const base64Map = {};
                await Promise.all(uniqueUrls.map(async (url) => { const b64 = await urlToBase64(url); if (b64) base64Map[url] = b64; }));
                for (const rep of replacements) if (base64Map[rep.url]) cssText = cssText.split(rep.original).join(`url("${base64Map[rep.url]}")`);
                return cssText;
            } catch { return ''; }
        }
        async function exportCanvas(isRetry = false) {
            const btn = document.getElementById('btn-export');
            const originalText = btn.textContent;
            btn.textContent = "処理中..."; btn.disabled = true;
            layerUi.style.display = 'none'; layerPaperGrid.style.display = 'none';

            try {
                // クローンを作成し、不要なUI要素を削除
                const svgClone = mainSvg.cloneNode(true);
                svgClone.querySelectorAll('.hit-rect, #margin-guide-rect').forEach(el => el.remove());

                // font-family属性を簡素化（クォート削除）
                svgClone.querySelectorAll('[font-family]').forEach(el => {
                    let ff = el.getAttribute('font-family');
                    if (ff) {
                        ff = ff.replace(/['"]/g, '').split(',')[0].trim();
                        el.setAttribute('font-family', ff);
                        // style属性もあれば更新
                        if (el.style.fontFamily) {
                            el.style.fontFamily = ff;
                        }
                    }
                });

                // text要素のstyle属性（writing-mode, text-orientationなど）を保持
                svgClone.querySelectorAll('text').forEach(el => {
                    const writingMode = el.getAttribute('writing-mode');
                    const textOrientation = el.style.textOrientation;

                    // writing-modeが設定されている場合は保持
                    if (writingMode) {
                        el.style.writingMode = writingMode;
                    }

                    // text-orientationが設定されている場合は保持
                    if (textOrientation && textOrientation !== 'mixed') {
                        el.style.textOrientation = textOrientation;
                    }
                });

                // 動的なスタイル（色など）をインラインで埋め込む
                const inkC = STATE.canvas.colors.ink;
                const paperC = STATE.canvas.colors.paper;
                const dynamicCss = `
                .ink-fill { fill: ${inkC} !important; }
                .ink-stroke { stroke: ${inkC} !important; }
                .paper-fill { fill: ${paperC} !important; }
                .paper-stroke { stroke: ${paperC} !important; }
                text { fill: ${inkC} !important; }
            `;
                const dynamicStyleEl = document.createElementNS(SVG_NS, 'style');
                dynamicStyleEl.textContent = dynamicCss;
                svgClone.querySelector('defs').appendChild(dynamicStyleEl);

                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgDataUri = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);

                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    // 初回は書き出しをスキップして、2回目を自動実行
                    if (!isRetry) {
                        // 少し待ってから2回目を実行
                        setTimeout(() => {
                            exportCanvas(true);
                        }, 100);
                        return;
                    }

                    // 2回目は実際に書き出し
                    const currentW = parseFloat(mainSvg.getAttribute('width'));
                    const currentH = parseFloat(mainSvg.getAttribute('height'));
                    const canvas = document.createElement('canvas');
                    const scale = 4; // 高解像度化
                    canvas.width = currentW * scale;
                    canvas.height = currentH * scale;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.drawImage(img, 0, 0);

                    const a = document.createElement('a');
                    a.href = canvas.toDataURL('image/png');
                    a.download = 'newspaper.png';
                    a.click();

                    btn.textContent = originalText;
                    btn.disabled = false;
                    layerUi.style.display = 'block';
                    layerPaperGrid.style.display = 'block';
                };
                img.onerror = () => {
                    console.error("Image loading for export failed.");
                    btn.textContent = "エラー";
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 2000);
                    layerUi.style.display = 'block';
                    layerPaperGrid.style.display = 'block';
                };
                img.src = svgDataUri;

            } catch (e) {
                console.error("Export failed:", e);
                btn.textContent = originalText;
                btn.disabled = false;
                layerUi.style.display = 'block';
                layerPaperGrid.style.display = 'block';
            }
        }

        function setCanvasPreset(w, h) { document.getElementById('inp-canvas-w').value = w; document.getElementById('inp-canvas-h').value = h; updateCanvasSize(); fitView(); }
        function swapCanvasSize() { const w = document.getElementById('inp-canvas-w'); const h = document.getElementById('inp-canvas-h');[w.value, h.value] = [h.value, w.value]; updateCanvasSize(); }
        function getSvgPoint(clientX, clientY) {
            const vpRect = viewport.getBoundingClientRect();
            return { x: (clientX - vpRect.left - STATE.view.x) / STATE.view.scale, y: (clientY - vpRect.top - STATE.view.y) / STATE.view.scale };
        }

        // --- 初期化処理 ---
        window.addEventListener('load', async () => {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingText = loadingScreen.querySelector('.loading-text');
            const loadingSubtext = loadingScreen.querySelector('.loading-subtext');

            try {
                // 基本UIの初期化
                loadingText.textContent = '初期化中...';
                loadingSubtext.textContent = 'キャンバスを準備しています';
                updateCanvasSize();
                updateGridSettings();
                updateColors();
                fitView();

                // フォントを非同期で取得し、SVGに埋め込む
                loadingText.textContent = '読み込み中...';
                loadingSubtext.textContent = 'フォントデータを取得しています';

                const fontCssUrl = 'https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block';
                const embeddedCss = await getEmbeddableFontCss(fontCssUrl);

                if (embeddedCss) {
                    // 既存のスタイルに追記する
                    loadingSubtext.textContent = 'フォントを埋め込んでいます';
                    svgStyle.textContent += '\n' + embeddedCss;
                }

                // フォントの準備ができた後に要素をレンダリング
                loadingText.textContent = 'もうすぐ完了...';
                loadingSubtext.textContent = 'フォントの読み込みを待機中';

                if (document.fonts) {
                    await document.fonts.ready;
                }

                loadingSubtext.textContent = '要素をレンダリング中';
                STATE.elements.forEach(renderElement);
                if (STATE.selectedId) renderUi();

                setupImageDragAndDrop();

                // iPad/iOSデバイスの自動検出
                if (detectIpadDevice()) {
                    setIpadMode(true);
                }

                // Undo/Redoボタンの初期状態を更新
                updateHistoryButtons();

                // ローディング画面をフェードアウト
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';

                    // デバッグ: 段間罫線の状態を確認
                    const danLines = document.getElementById('layer-dan-lines');
                    console.log('[初期化完了] 段間罫線の状態:', {
                        exists: !!danLines,
                        childCount: danLines ? danLines.children.length : 0,
                        visibility: danLines ? danLines.style.visibility : 'N/A',
                        opacity: danLines ? danLines.style.opacity : 'N/A'
                    });
                }, 300);

            } catch (e) {
                console.error("Initialization failed:", e);
                loadingText.textContent = 'エラーが発生しました';
                loadingSubtext.textContent = e.message || '初期化に失敗しました';
            }
        });

        // 画像ドラッグ&ドロップのセットアップ
        function setupImageDragAndDrop() {
            // SVGキャンバスへのドロップ
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('image/')) return;

                // マウス座標からSVG座標を取得
                const rect = mainSvg.getBoundingClientRect();
                const svgX = (e.clientX - rect.left) / STATE.view.scale;
                const svgY = (e.clientY - rect.top) / STATE.view.scale;

                // その位置にある画像ボックスを探す
                let targetImage = null;
                for (let i = STATE.elements.length - 1; i >= 0; i--) {
                    const el = STATE.elements[i];
                    if (el.type === 'image' &&
                        svgX >= el.x && svgX <= el.x + el.width &&
                        svgY >= el.y && svgY <= el.y + el.height) {
                        targetImage = el;
                        break;
                    }
                }

                if (targetImage) {
                    loadImageToElement(file, targetImage);
                }
            });

            // プロパティパネルへのドロップ
            const propPanel = document.getElementById('prop-panel-image');
            propPanel.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            propPanel.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('image/')) return;

                const data = STATE.elements.find(el => el.id === STATE.selectedId);
                if (data && data.type === 'image') {
                    loadImageToElement(file, data);
                }
            });
        }

        // === 画像カラーモード変換関数 ===

        // 画像に透過ピクセル（アルファ<255）が含まれているかチェック
        function hasTransparency(imgElement) {
            const canvas = document.createElement('canvas');
            canvas.width = imgElement.width;
            canvas.height = imgElement.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(imgElement, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // アルファチャンネルをチェック（4バイト目ごと）
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] < 255) {
                    return true; // 透過ピクセルが見つかった
                }
            }
            return false; // 透過ピクセルなし
        }

        // RGB色を輝度値（0.0～1.0）に変換
        function getLuminance(r, g, b) {
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        // 16進数カラーコードをRGB配列に変換
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0];
        }

        // 2色の線形補間
        function lerpColor(color1, color2, t) {
            return [
                Math.round(color1[0] + (color2[0] - color1[0]) * t),
                Math.round(color1[1] + (color2[1] - color1[1]) * t),
                Math.round(color1[2] + (color2[2] - color1[2]) * t)
            ];
        }

        // 画像を圧縮（最大辺2400px、JPEG品質0.9）
        function compressImage(imgElement, maxSize = 2400, quality = 0.9) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                let width = imgElement.width;
                let height = imgElement.height;

                const maxDim = Math.max(width, height);
                if (maxDim > maxSize) {
                    const scale = maxSize / maxDim;
                    width *= scale;
                    height *= scale;
                }

                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0, width, height);

                canvas.toBlob(blob => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(blob);
                }, 'image/jpeg', quality);
            });
        }

        // インクモード変換：画像データを指定したインク色と紙色で再構成
        function convertImageToInk(imgElement, inkColor, paperColor, contrast = 1.0, brightness = 1.0) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = imgElement.width;
                canvas.height = imgElement.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                const ink = hexToRgb(inkColor);
                const paper = hexToRgb(paperColor);

                // インクと紙、どちらが明るいかを判定
                const inkLum = getLuminance(ink[0], ink[1], ink[2]) / 255;
                const paperLum = getLuminance(paper[0], paper[1], paper[2]) / 255;
                const inkIsDarker = inkLum < paperLum;

                // ピクセルごとに処理
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // 輝度を計算（0.0～1.0）
                    let lum = getLuminance(r, g, b) / 255;

                    // コントラストと明るさの補正
                    lum = (lum - 0.5) * contrast + 0.5;
                    lum = lum * brightness;
                    lum = Math.max(0, Math.min(1, lum));

                    // インクが暗い場合：黒→インク、白→紙
                    // インクが明るい場合：黒→紙、白→インク（反転）
                    let col;
                    if (inkIsDarker) {
                        col = lerpColor(ink, paper, lum);
                    } else {
                        col = lerpColor(paper, ink, lum);
                    }

                    data[i] = col[0];
                    data[i + 1] = col[1];
                    data[i + 2] = col[2];
                }

                ctx.putImageData(imageData, 0, 0);
                resolve(canvas.toDataURL('image/jpeg', 0.9));
            });
        }

        // 画像ファイルを要素に読み込む共通関数
        function loadImageToElement(file, data) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = async function () {
                    data._imageAspect = img.width / img.height;

                    // 透過チェック
                    data._hasTransparency = hasTransparency(img);

                    // 圧縮処理
                    const compressed = await compressImage(img);
                    data._originalImageUrl = compressed;

                    // カラーモードに応じて処理
                    await applyImageColorMode(data);

                    renderElement(data);
                    if (STATE.selectedId === data.id) {
                        renderUi();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // カラーモードを適用
        async function applyImageColorMode(data) {
            if (!data._originalImageUrl) {
                data.imageUrl = null;
                return;
            }

            const colorMode = data.colorMode || 'fullcolor';

            if (colorMode === 'fullcolor') {
                data.imageUrl = data._originalImageUrl;
            } else if (colorMode === 'ink') {
                // 全体設定のインク色・紙色を使用
                const inkColor = STATE.canvas.colors.ink || '#333333';
                const paperColor = STATE.canvas.colors.paper || '#ffffff';
                const contrast = (data.contrast || 100) / 100;
                const brightness = (data.brightness || 100) / 100;

                const img = new Image();
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = data._originalImageUrl;
                });

                data.imageUrl = await convertImageToInk(img, inkColor, paperColor, contrast, brightness);
            }
        }

        // ===== Undo/Redo履歴管理 =====
        function saveHistory() {
            // 現在のインデックス以降の履歴を削除
            STATE.history = STATE.history.slice(0, STATE.historyIndex + 1);

            // 現在の状態を深くコピーして保存
            const snapshot = JSON.parse(JSON.stringify(STATE.elements));
            STATE.history.push(snapshot);
            STATE.historyIndex++;

            // 履歴は最大50件まで
            if (STATE.history.length > 50) {
                STATE.history.shift();
                STATE.historyIndex--;
            }

            // ボタンの状態を更新
            updateHistoryButtons();

            // 操作が確定したのでオートセーブを実行
            autoSave(false);
        }

        function undo() {
            if (STATE.historyIndex <= 0) return;

            STATE.historyIndex--;
            const snapshot = STATE.history[STATE.historyIndex];
            STATE.elements = JSON.parse(JSON.stringify(snapshot));

            // 全要素を再描画
            document.querySelectorAll('.element-group').forEach(el => el.remove());
            STATE.elements.forEach(data => renderElement(data));

            // 選択をクリア
            selectElement(null);

            // ボタンの状態を更新
            updateHistoryButtons();
        }

        function redo() {
            if (STATE.historyIndex >= STATE.history.length - 1) return;

            STATE.historyIndex++;
            const snapshot = STATE.history[STATE.historyIndex];
            STATE.elements = JSON.parse(JSON.stringify(snapshot));

            // 全要素を再描画
            document.querySelectorAll('.element-group').forEach(el => el.remove());
            STATE.elements.forEach(data => renderElement(data));

            // 選択をクリア
            selectElement(null);

            // ボタンの状態を更新
            updateHistoryButtons();
        }

        // Undo/Redoボタンの有効/無効を更新
        function updateHistoryButtons() {
            const undoBtn = document.getElementById('btn-undo');
            const redoBtn = document.getElementById('btn-redo');

            if (undoBtn) {
                undoBtn.disabled = STATE.historyIndex <= 0;
            }
            if (redoBtn) {
                redoBtn.disabled = STATE.historyIndex >= STATE.history.length - 1;
            }
        }

        // ===== オートセーブ機能 =====
        const AUTOSAVE_KEY = 'newspaper-editor-autosave';
        const MAX_AUTOSAVE_SIZE = 4.5 * 1024 * 1024; // 4.5MB

        // 画像データを圧縮する関数
        async function compressImageData(imageUrl, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // JPEG形式で圧縮
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed);
                };
                img.onerror = () => resolve(imageUrl); // エラー時は元のURLを返す
                img.src = imageUrl;
            });
        }

        // 要素内の画像を圧縮
        async function compressElementImages(elements, quality = 0.8) {
            const compressed = JSON.parse(JSON.stringify(elements));
            for (const elem of compressed) {
                if (elem.type === 'image' && elem.imageUrl && elem.imageUrl.startsWith('data:')) {
                    elem.imageUrl = await compressImageData(elem.imageUrl, quality);
                }
            }
            return compressed;
        }

        // オートセーブインジケーター表示関数
        function showAutosaveIndicator(status = 'saving') {
            const indicator = document.getElementById('autosave-indicator');
            const text = document.getElementById('autosave-text');

            indicator.classList.remove('error');

            if (status === 'saving') {
                text.textContent = '保存中...';
                indicator.classList.add('show');
            } else if (status === 'success') {
                text.textContent = '保存完了';
                indicator.classList.add('show');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            } else if (status === 'error') {
                text.textContent = '保存失敗';
                indicator.classList.add('show', 'error');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 3000);
            }
        }

        async function autoSave(silent = false) {
            if (!silent) {
                showAutosaveIndicator('saving');
            }

            try {
                let elements = STATE.elements;
                let quality = 0.8;

                // まず通常の品質で試す
                let project = {
                    version: '1.0',
                    canvas: STATE.canvas,
                    grid: {
                        show: STATE.grid.show,
                        dan: STATE.grid.dan,
                        charsPerDan: STATE.grid.charsPerDan,
                        totalLines: STATE.grid.totalLines
                    },
                    header: STATE.header,
                    articleSnapMode: STATE.articleSnapMode,
                    elements: elements,
                    timestamp: new Date().toISOString()
                };

                let json = JSON.stringify(project);
                let size = new Blob([json]).size;

                // サイズが大きい場合は画像を圧縮
                if (size > MAX_AUTOSAVE_SIZE) {
                    console.log(`オートセーブサイズが大きいため画像を圧縮します (${(size / 1024 / 1024).toFixed(2)}MB)`);

                    // 段階的に品質を下げて圧縮
                    const qualities = [0.7, 0.6, 0.5, 0.4, 0.3];
                    for (const q of qualities) {
                        elements = await compressElementImages(STATE.elements, q);
                        project.elements = elements;
                        json = JSON.stringify(project);
                        size = new Blob([json]).size;

                        console.log(`品質${q}で圧縮: ${(size / 1024 / 1024).toFixed(2)}MB`);

                        if (size <= MAX_AUTOSAVE_SIZE) {
                            break;
                        }
                    }

                    if (size > MAX_AUTOSAVE_SIZE) {
                        console.warn(`圧縮後もサイズが大きいため、オートセーブをスキップします (${(size / 1024 / 1024).toFixed(2)}MB)`);
                        if (!silent) showAutosaveIndicator('error');
                        return;
                    }
                }

                localStorage.setItem(AUTOSAVE_KEY, json);
                if (!silent) showAutosaveIndicator('success');
                console.log(`オートセーブ完了 (${(size / 1024 / 1024).toFixed(2)}MB)`);
            } catch (e) {
                console.error('オートセーブに失敗しました:', e);
                if (!silent) showAutosaveIndicator('error');
            }
        }

        const BROKEN_AUTOSAVE_KEY = 'newspaper-editor-autosave-broken';

        function updateUiFromState() {
            document.getElementById('inp-canvas-w').value = STATE.canvas.width;
            document.getElementById('inp-canvas-h').value = STATE.canvas.height;
            document.getElementById('inp-margin-t').value = STATE.canvas.margin.top;
            document.getElementById('inp-margin-b').value = STATE.canvas.margin.bottom;
            document.getElementById('inp-margin-l').value = STATE.canvas.margin.left;
            document.getElementById('inp-margin-r').value = STATE.canvas.margin.right;
            document.getElementById('inp-paper-color').value = STATE.canvas.colors.paper;
            document.getElementById('inp-ink-color').value = STATE.canvas.colors.ink;
            document.getElementById('inp-layout-show').checked = STATE.grid.show;
            document.getElementById('inp-layout-dan').value = STATE.grid.dan;
            document.getElementById('inp-layout-chars').value = STATE.grid.charsPerDan;
            document.getElementById('inp-layout-lines').value = STATE.grid.totalLines;
            document.getElementById('inp-header-left-text').value = STATE.header.left.text;
            document.getElementById('inp-header-left-font').value = STATE.header.left.fontFamily;
            document.getElementById('inp-header-left-size').value = STATE.header.left.fontSize;
            document.getElementById('inp-header-left-weight').value = STATE.header.left.fontWeight;
            document.getElementById('inp-header-left-spacing').value = STATE.header.left.letterSpacing;
            document.getElementById('inp-header-center-text').value = STATE.header.center.text;
            document.getElementById('inp-header-center-font').value = STATE.header.center.fontFamily;
            document.getElementById('inp-header-center-size').value = STATE.header.center.fontSize;
            document.getElementById('inp-header-center-weight').value = STATE.header.center.fontWeight;
            document.getElementById('inp-header-center-spacing').value = STATE.header.center.letterSpacing;
            document.getElementById('inp-header-right-text').value = STATE.header.right.text;
            document.getElementById('inp-header-right-font').value = STATE.header.right.fontFamily;
            document.getElementById('inp-header-right-size').value = STATE.header.right.fontSize;
            document.getElementById('inp-header-right-weight').value = STATE.header.right.fontWeight;
            document.getElementById('inp-header-right-spacing').value = STATE.header.right.letterSpacing;
            document.getElementById('inp-snap-article').checked = STATE.articleSnapMode;
        }

        function loadAutoSave() {
            const json = localStorage.getItem(AUTOSAVE_KEY);

            if (!json) {
                const brokenJson = localStorage.getItem(BROKEN_AUTOSAVE_KEY);
                if (brokenJson) {
                    setTimeout(() => {
                        alert('以前に破損した自動保存データのバックアップが見つかりました。開発者にお問い合わせください。');
                    }, 1500);
                }
                return false;
            }

            try {
                const project = JSON.parse(json);
                if (!project || !project.version) {
                    throw new Error('Invalid project data structure');
                }
                
                const timestamp = project.timestamp ? new Date(project.timestamp).toLocaleString('ja-JP') : '不明';
                if (!confirm(`自動保存されたデータがあります。\n保存日時: ${timestamp}\n\n復元しますか？`)) {
                    return false;
                }

                // プロジェクト読み込み
                STATE.canvas = project.canvas;
                STATE.grid.show = project.grid.show;
                STATE.grid.dan = project.grid.dan;
                STATE.grid.charsPerDan = project.grid.charsPerDan;
                STATE.grid.totalLines = project.grid.totalLines;
                STATE.header = project.header;
                STATE.articleSnapMode = project.articleSnapMode !== undefined ? project.articleSnapMode : true;
                STATE.elements = project.elements;
                normalizeTextElements(STATE.elements);

                // UI更新と再描画
                updateUiFromState();
                updateCanvasSize();
                updateGridSettings();
                updateColors();
                renderHeaderTexts();
                document.querySelectorAll('.element-group').forEach(el => el.remove());
                document.getElementById('layer-content').innerHTML = '';
                document.getElementById('layer-ui').innerHTML = '';
                setIpadMode(STATE.ipadMode);
                renderDanLines();

                // 履歴リセット
                STATE.history = [];
                STATE.historyIndex = -1;
                saveHistory();
                
                alert("自動保存データを復元しました。");
                return true;

            } catch (e) {
                console.error('自動保存データの読み込みに失敗:', e);
                
                localStorage.setItem(BROKEN_AUTOSAVE_KEY, json);
                localStorage.removeItem(AUTOSAVE_KEY);
                
                alert('自動保存データが破損していたため読み込めませんでした。\n破損したデータはバックアップされました。\n新しいプロジェクトとして開始します。');
                
                return false;
            }
        }

        function clearAutoSave() {
            try {
                localStorage.removeItem(AUTOSAVE_KEY);
            } catch (e) {
                console.error('オートセーブのクリアに失敗しました:', e);
            }
        }

        // ページ読み込み時にオートセーブを復元
        window.addEventListener('load', () => {
            // まずオートセーブデータを読み込んでから定期保存を開始
            loadAutoSave();

            // オートセーブ読み込み後に初期履歴を保存
            // これによりUndo/Redoの初期状態が確保される
            saveHistory();

            // 定期的なオートセーブ (30秒ごと)
            // 最初の実行は30秒後なので、読み込み直後に上書きされることはない
            setInterval(() => {
                autoSave(false); // 必ずインジケーターを表示
            }, 30000);
        });

        // ブラウザを閉じる時に警告を表示
        window.addEventListener('beforeunload', (e) => {
            // 要素が存在する場合のみ警告
            if (STATE.elements.length > 0) {
                e.preventDefault();
                e.returnValue = ''; // Chrome requires returnValue to be set
            }
        });

        // ===== iPad対応モード =====
        // iPad/iOSデバイスを検出
        function detectIpadDevice() {
            const ua = navigator.userAgent || navigator.vendor || window.opera;

            // iPad検出
            const isIpad = /iPad/i.test(ua) ||
                          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            // iPhone検出
            const isIphone = /iPhone/i.test(ua);

            // iPod検出
            const isIpod = /iPod/i.test(ua);

            return isIpad || isIphone || isIpod;
        }

        function setIpadMode(enabled) {
            STATE.ipadMode = enabled;
            updateIpadModeIndicator();
            STATE.elements.forEach(data => renderElement(data));
            if (STATE.selectedId) {
                renderUi();
            }
        }

        // iPadモードの切り替え
        function toggleIpadMode() {
            setIpadMode(!STATE.ipadMode);
        }

        // iPadモードインジケーターの更新
        function updateIpadModeIndicator() {
            const btn = document.getElementById('btn-ipad-mode');
            if (STATE.ipadMode) {
                btn.classList.add('ipad-mode-active');
            } else {
                btn.classList.remove('ipad-mode-active');
            }
        }

        // ===== キーボードイベントハンドラー =====
        document.addEventListener('keydown', (e) => {
            // テキスト入力中は無視
            const target = e.target;
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') {
                return;
            }

            // Ctrl+Z: Undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }

            // Ctrl+Shift+Z または Ctrl+Y: Redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
                return;
            }

            // Delete または Backspace: 選択要素を削除
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                if (STATE.selectedId) {
                    deleteSelected();
                    saveHistory();
                }
                return;
            }

            // Escape: 選択解除
            if (e.key === 'Escape') {
                e.preventDefault();
                selectElement(null);
                return;
            }

            // ツール切り替えショートカット
            if (!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
                switch (e.key.toUpperCase()) {
                    case 'V':
                        e.preventDefault();
                        setMode('select');
                        break;
                    case 'H':
                        e.preventDefault();
                        setMode('hand');
                        break;
                    case 'T':
                        e.preventDefault();
                        setMode('text');
                        break;
                    case 'F':
                        e.preventDefault();
                        setMode('freetext');
                        break;
                    case 'M':
                        e.preventDefault();
                        setMode('masthead');
                        break;
                    case 'R':
                        e.preventDefault();
                        setMode('rect');
                        break;
                    case 'L':
                        e.preventDefault();
                        setMode('vline');
                        break;
                    case 'I':
                        e.preventDefault();
                        setMode('image');
                        break;
                }
            }
        });

        // 初期化: グリッドと段間罫線を描画
        renderPaperGrid();
        renderBorder();

        // ===== プロジェクト保存・読み込み =====
        function saveProject() {
            const project = {
                version: '1.0',
                canvas: STATE.canvas,
                grid: {
                    show: STATE.grid.show,
                    dan: STATE.grid.dan,
                    charsPerDan: STATE.grid.charsPerDan,
                    totalLines: STATE.grid.totalLines
                },
                header: STATE.header,
                articleSnapMode: STATE.articleSnapMode,
                elements: STATE.elements
            };

            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '新聞プロジェクト.json';
            a.click();
            URL.revokeObjectURL(url);

            // 保存後はオートセーブをクリア
            clearAutoSave();
        }

        function updateUiFromState() {
            document.getElementById('inp-canvas-w').value = STATE.canvas.width;
            document.getElementById('inp-canvas-h').value = STATE.canvas.height;
            document.getElementById('inp-margin-t').value = STATE.canvas.margin.top;
            document.getElementById('inp-margin-b').value = STATE.canvas.margin.bottom;
            document.getElementById('inp-margin-l').value = STATE.canvas.margin.left;
            document.getElementById('inp-margin-r').value = STATE.canvas.margin.right;
            document.getElementById('inp-paper-color').value = STATE.canvas.colors.paper;
            document.getElementById('inp-ink-color').value = STATE.canvas.colors.ink;
            document.getElementById('inp-layout-show').checked = STATE.grid.show;
            document.getElementById('inp-layout-dan').value = STATE.grid.dan;
            document.getElementById('inp-layout-chars').value = STATE.grid.charsPerDan;
            document.getElementById('inp-layout-lines').value = STATE.grid.totalLines;
            document.getElementById('inp-header-left-text').value = STATE.header.left.text;
            document.getElementById('inp-header-left-font').value = STATE.header.left.fontFamily;
            document.getElementById('inp-header-left-size').value = STATE.header.left.fontSize;
            document.getElementById('inp-header-left-weight').value = STATE.header.left.fontWeight;
            document.getElementById('inp-header-left-spacing').value = STATE.header.left.letterSpacing;
            document.getElementById('inp-header-center-text').value = STATE.header.center.text;
            document.getElementById('inp-header-center-font').value = STATE.header.center.fontFamily;
            document.getElementById('inp-header-center-size').value = STATE.header.center.fontSize;
            document.getElementById('inp-header-center-weight').value = STATE.header.center.fontWeight;
            document.getElementById('inp-header-center-spacing').value = STATE.header.center.letterSpacing;
            document.getElementById('inp-header-right-text').value = STATE.header.right.text;
            document.getElementById('inp-header-right-font').value = STATE.header.right.fontFamily;
            document.getElementById('inp-header-right-size').value = STATE.header.right.fontSize;
            document.getElementById('inp-header-right-weight').value = STATE.header.right.fontWeight;
            document.getElementById('inp-header-right-spacing').value = STATE.header.right.letterSpacing;
            document.getElementById('inp-snap-article').checked = STATE.articleSnapMode;
        }

        function loadProject(json, isAutoSave = false) {
            try {
                const project = JSON.parse(json);
                if (!project || !project.version) throw new Error('不正なプロジェクトファイルです。');

                if (isAutoSave) {
                    const timestamp = project.timestamp ? new Date(project.timestamp).toLocaleString('ja-JP') : '不明';
                    if (!confirm(`自動保存されたデータがあります。\n保存日時: ${timestamp}\n\n復元しますか？`)) {
                        return false;
                    }
                }

                STATE.canvas = project.canvas;
                STATE.grid.show = project.grid.show;
                STATE.grid.dan = project.grid.dan;
                STATE.grid.charsPerDan = project.grid.charsPerDan;
                STATE.grid.totalLines = project.grid.totalLines;
                STATE.header = project.header;
                STATE.articleSnapMode = project.articleSnapMode !== undefined ? project.articleSnapMode : true;
                STATE.elements = project.elements;
                
                normalizeTextElements(STATE.elements);
                updateUiFromState(); // この関数は後で追加される想定
                
                STATE.selectedId = null;
                updateCanvasSize();
                updateGridSettings();
                updateColors();
                renderHeaderTexts();
                document.querySelectorAll('.element-group').forEach(el => el.remove());
                document.getElementById('layer-content').innerHTML = '';
                document.getElementById('layer-ui').innerHTML = '';
                STATE.elements.forEach(data => renderElement(data));
                renderDanLines();
                
                STATE.history = [];
                STATE.historyIndex = -1;
                saveHistory();

                if (!isAutoSave) {
                    clearAutoSave();
                    alert('プロジェクトを読み込みました。');
                } else {
                    alert("自動保存データを復元しました。");
                }
                return true;

            } catch (e) {
                console.error(e);
                if (isAutoSave) {
                    console.error('オートセーブの復元に失敗しました。', e);
                    // 破損をユーザーに通知し、古い破損データをクリア
                    alert('自動保存データが破損しているため、復元できませんでした。');
                    localStorage.removeItem('newspaper-editor-autosave-broken'); // 試行済みの破損データを削除
                } else {
                    alert('プロジェクトの読み込みに失敗しました。\n' + e.message);
                }
                return false;
            }
        }

        function newProject() {
            if (!confirm('新規作成しますか？現在の内容は失われます。')) return;

            STATE.elements = [];
            STATE.selectedId = null;
            STATE.mode = 'select';
            STATE.articleSnapMode = true;
            STATE.linking = null;
            STATE.cropMode = false;
            STATE.cropEdge = null;
            STATE.canvas = { width: 297, height: 420, margin: { top: 20, bottom: 20, left: 20, right: 20 }, colors: { paper: '#ffffff', ink: '#333333' } };
            STATE.grid = { show: true, dan: 6, charsPerDan: 11, totalLines: 25, computed: { charSizeW: 0, charSizeH: 0, lineGap: 0, danHeight: 0, danPitch: 0, pitchX: 0 } };
            STATE.header = {
                left: { text: '20XX年（令和X年）XX月XX日', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 700, letterSpacing: 0 },
                center: { text: '空想新聞', fontFamily: '"Noto Serif JP", serif', fontSize: 6, fontWeight: 900, letterSpacing: 10 },
                right: { text: '○○について深く知る。', fontFamily: '"Noto Sans JP", sans-serif', fontSize: 4, fontWeight: 400, letterSpacing: 0 }
            };

            document.getElementById('inp-canvas-w').value = STATE.canvas.width;
            document.getElementById('inp-canvas-h').value = STATE.canvas.height;
            document.getElementById('inp-margin-t').value = STATE.canvas.margin.top;
            document.getElementById('inp-margin-b').value = STATE.canvas.margin.bottom;
            document.getElementById('inp-margin-l').value = STATE.canvas.margin.left;
            document.getElementById('inp-margin-r').value = STATE.canvas.margin.right;
            document.getElementById('inp-paper-color').value = STATE.canvas.colors.paper;
            document.getElementById('inp-ink-color').value = STATE.canvas.colors.ink;
            document.getElementById('inp-layout-show').checked = STATE.grid.show;
            document.getElementById('inp-layout-dan').value = STATE.grid.dan;
            document.getElementById('inp-layout-chars').value = STATE.grid.charsPerDan;
            document.getElementById('inp-layout-lines').value = STATE.grid.totalLines;
            document.getElementById('inp-header-left-text').value = STATE.header.left.text;
            document.getElementById('inp-header-left-font').value = STATE.header.left.fontFamily;
            document.getElementById('inp-header-left-size').value = STATE.header.left.fontSize;
            document.getElementById('inp-header-left-weight').value = STATE.header.left.fontWeight;
            document.getElementById('inp-header-left-spacing').value = STATE.header.left.letterSpacing;
            document.getElementById('inp-header-center-text').value = STATE.header.center.text;
            document.getElementById('inp-header-center-font').value = STATE.header.center.fontFamily;
            document.getElementById('inp-header-center-size').value = STATE.header.center.fontSize;
            document.getElementById('inp-header-center-weight').value = STATE.header.center.fontWeight;
            document.getElementById('inp-header-center-spacing').value = STATE.header.center.letterSpacing;
            document.getElementById('inp-header-right-text').value = STATE.header.right.text;
            document.getElementById('inp-header-right-font').value = STATE.header.right.fontFamily;
            document.getElementById('inp-header-right-size').value = STATE.header.right.fontSize;
            document.getElementById('inp-header-right-weight').value = STATE.header.right.fontWeight;
            document.getElementById('inp-header-right-spacing').value = STATE.header.right.letterSpacing;
            document.getElementById('inp-snap-article').checked = STATE.articleSnapMode;

            // 既存の要素をすべて削除
            document.querySelectorAll('.element-group').forEach(el => el.remove());
            document.getElementById('layer-content').innerHTML = '';
            document.getElementById('layer-ui').innerHTML = '';

            // キャンバスと設定を更新
            updateCanvasSize();
            updateColors();
            renderHeaderTexts();
            renderDanLines();

            // 履歴をリセット
            STATE.history = [];
            STATE.historyIndex = -1;
            saveHistory();
            setMode('select');

            // 新規作成時はオートセーブをクリア
            clearAutoSave();
        }

        function openProjectFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => loadProject(event.target.result);
                reader.readAsText(file);
            };
            input.click();
        }

        // ドラッグ&ドロップ
        const dropOverlay = document.createElement('div');
        dropOverlay.innerHTML = '<div style="font-size:32px;color:white;font-weight:bold;text-align:center;padding:40px;background:rgba(0,0,0,0.3);border-radius:20px;">📄 JSONファイルをドロップして読み込み</div>';
        dropOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(33,150,243,0.9);display:none;justify-content:center;align-items:center;z-index:10000;pointer-events:none;';
        document.body.appendChild(dropOverlay);

        let dragCounter = 0;
        document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; if (dragCounter === 1) dropOverlay.style.display = 'flex'; });
        document.addEventListener('dragleave', (e) => { e.preventDefault(); dragCounter--; if (dragCounter === 0) dropOverlay.style.display = 'none'; });
        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.style.display = 'none';
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (event) => loadProject(event.target.result);
                reader.readAsText(files[0]);
            } else {
                alert('JSONファイルのみ読み込めます。');
            }
        });


    </script>
</body>

</html>
