<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SVG Newspaper Tool Core</title>
<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block" rel="stylesheet">

<style>
    :root {
        --ui-bg: #f5f5f5;
        --panel-bg: #ffffff;
        --border-col: #ddd;
        --primary: #2196f3;
        --text: #333;
    }
    body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
        font-family: "Noto Sans JP", sans-serif;
        background: var(--ui-bg);
        color: var(--text);
        user-select: none;
    }

    /* Â∑¶„Çµ„Ç§„Éâ„Éê„Éº */
    .toolbar {
        width: 60px;
        background: var(--panel-bg);
        border-right: 1px solid var(--border-col);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
        z-index: 100;
    }
    .tool-btn {
        width: 40px; height: 40px;
        margin-bottom: 10px;
        border: 1px solid var(--border-col);
        background: #fff;
        cursor: pointer;
        border-radius: 4px;
        display: flex; justify-content: center; align-items: center;
        font-size: 20px;
        transition: 0.2s;
    }
    .tool-btn:hover { background: #eee; }
    .tool-btn.active { background: var(--primary); color: #fff; border-color: var(--primary); }

    /* „É°„Ç§„É≥„Ç®„É™„Ç¢ */
    .viewport {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #e0e0e0;
        background-image: radial-gradient(#ccc 1px, transparent 1px);
        background-size: 20px 20px;
        cursor: default;
    }
    .viewport.hand-mode { cursor: grab; }
    .viewport.hand-mode:active { cursor: grabbing; }

    /* SVGÁî®Á¥ô„Ç≥„É≥„ÉÜ„Éä */
    #canvas-container {
        transform-origin: 0 0;
        position: absolute;
        top: 0; left: 0;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }

    /* SVGÁî®Á¥ô */
    #main-svg {
        background: transparent;
        display: block; 
        transition: width 0.3s, height 0.3s;
        shape-rendering: geometricPrecision;
        text-rendering: geometricPrecision;
    }

    /* Âè≥„Çµ„Ç§„Éâ„Éê„Éº */
    .properties {
        width: 280px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border-col);
        padding: 15px;
        box-sizing: border-box;
        overflow-y: auto;
        z-index: 100;
    }
    .prop-group { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
    .prop-group:last-child { border-bottom: none; }
    .prop-label { font-size: 12px; font-weight: bold; margin-bottom: 5px; display: block; color: #555; }
    .prop-row { display: flex; gap: 5px; margin-bottom: 8px; align-items: center; }
    
    .prop-input, .prop-select, .prop-textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 6px;
        border: 1px solid var(--border-col);
        margin-bottom: 8px;
        font-size: 14px;
        font-family: inherit;
    }
    .prop-textarea { resize: vertical; min-height: 100px; }
    
    .btn-primary {
        width: 100%; padding: 8px;
        background: var(--primary); color: white;
        border: none; border-radius: 4px; cursor: pointer;
    }
    .btn-primary:hover { opacity: 0.9; }

    .btn-secondary {
        flex: 1; padding: 6px;
        background: #f0f0f0; color: #333;
        border: 1px solid var(--border-col);
        border-radius: 4px; cursor: pointer;
        font-size: 12px;
        text-align: center;
    }
    .btn-secondary:hover { background: #e0e0e0; }

    /* SVGÂÜÖ UI„Çπ„Çø„Ç§„É´ */
    .selection-rect {
        fill: none;
        stroke: var(--primary);
        stroke-width: 2px;
        stroke-dasharray: 4 2;
        pointer-events: none; 
        vector-effect: non-scaling-stroke;
    }
    .resize-handle {
        fill: white;
        stroke: var(--primary);
        stroke-width: 1.5px;
        cursor: pointer;
        vector-effect: non-scaling-stroke;
        r: 5px;
    }
    .resize-handle:hover {
        fill: var(--primary);
    }
    .cursor-nw { cursor: nw-resize; }
    .cursor-ne { cursor: ne-resize; }
    .cursor-sw { cursor: sw-resize; }
    .cursor-se { cursor: se-resize; }

    .margin-guide {
        fill: none;
        stroke: #00bcd4;
        stroke-width: 1px;
        stroke-dasharray: 5 5;
        pointer-events: none;
        vector-effect: non-scaling-stroke;
    }
    
    text { user-select: none; }
    
    .grid-line { stroke: #b3e5fc; stroke-width: 0.5px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
    .grid-rect { stroke: #b3e5fc; stroke-width: 0.5px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
    .grid-dan-border { stroke: #81d4fa; stroke-width: 1px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
</style>
</head>
<body>

<div class="toolbar">
    <button class="tool-btn active" id="btn-select" title="ÈÅ∏Êäû (V)">üëÜ</button>
    <button class="tool-btn" id="btn-text" title="Ë®ò‰∫ã (T)">T</button>
    <button class="tool-btn" id="btn-rect" title="Áü©ÂΩ¢ (R)">‚¨ú</button>
    <div style="flex:1"></div>
    <button class="tool-btn" onclick="fitView()" title="ÂÖ®‰ΩìË°®Á§∫">üîç</button>
</div>

<div class="viewport" id="viewport">
    <div id="canvas-container">
        <svg id="main-svg" width="297" height="420" viewBox="0 0 297 420" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style id="svg-style">
                    .ink-fill { fill: #333333; }
                    .ink-stroke { stroke: #333333; }
                </style>
            </defs>
            <rect id="paper-bg" x="0" y="0" width="100%" height="100%" fill="#ffffff"></rect>
            <g id="layer-paper-grid"></g>
            <g id="layer-grid"></g>
            <g id="layer-content"></g>
            <g id="layer-ui"></g>
        </svg>
    </div>
</div>

<div class="properties">
    <div class="prop-group" id="prop-panel-none">
        <div class="prop-label">Áî®Á¥ô„Çµ„Ç§„Ç∫ (mm)</div>
        <div class="prop-row">
            <input type="number" id="inp-canvas-w" class="prop-input" value="297" onchange="updateCanvasSize()">
            <span style="font-size:12px;">√ó</span>
            <input type="number" id="inp-canvas-h" class="prop-input" value="420" onchange="updateCanvasSize()">
        </div>
        <div class="prop-row">
            <button class="btn-secondary" onclick="setCanvasPreset(210, 297)">A4</button>
            <button class="btn-secondary" onclick="setCanvasPreset(297, 420)">A3</button>
            <button class="btn-secondary" onclick="setCanvasPreset(257, 364)">B4</button>
            <button class="btn-secondary" onclick="swapCanvasSize()">Á∏¶Ê®™ÂÖ•Êõø</button>
        </div>

        <div class="prop-label" style="margin-top:15px;">„Ç´„É©„ÉºË®≠ÂÆö</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">Á¥ô„ÅÆËâ≤</span>
            <input type="color" id="inp-paper-color" value="#ffffff" onchange="updateColors()" style="height:24px;">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">„Ç§„É≥„ÇØ„ÅÆËâ≤</span>
            <input type="color" id="inp-ink-color" value="#333333" onchange="updateColors()" style="height:24px;">
        </div>

        <div class="prop-label" style="margin-top:15px;">„Éû„Éº„Ç∏„É≥ (mm)</div>
        <div class="prop-row">
            <span style="font-size:11px; width:15px;">‰∏ä</span>
            <input type="number" id="inp-margin-t" class="prop-input" value="20" onchange="updateMargins()">
            <span style="font-size:11px; width:15px;">‰∏ã</span>
            <input type="number" id="inp-margin-b" class="prop-input" value="20" onchange="updateMargins()">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; width:15px;">Â∑¶</span>
            <input type="number" id="inp-margin-l" class="prop-input" value="20" onchange="updateMargins()">
            <span style="font-size:11px; width:15px;">Âè≥</span>
            <input type="number" id="inp-margin-r" class="prop-input" value="20" onchange="updateMargins()">
        </div>

        <div class="prop-label" style="margin-top:15px; color:#2196f3;">Á¥ôÈù¢Ââ≤‰ªò</div>
        <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee;">
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">Á∏¶„ÅÆÊÆµÊï∞</span>
                <input type="number" id="inp-layout-dan" class="prop-input" style="flex:0.6" value="6" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">1ÊÆµ„ÅÆÊñáÂ≠óÊï∞</span>
                <input type="number" id="inp-layout-chars" class="prop-input" style="flex:0.6" value="11" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">ÂÖ®‰Ωì„ÅÆË°åÊï∞</span>
                <input type="number" id="inp-layout-lines" class="prop-input" style="flex:0.6" value="25" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center;">
                    <input type="checkbox" id="inp-layout-show" checked onchange="updateGridSettings()" style="margin-right:5px;"> „Ç∞„É™„ÉÉ„ÉâË°®Á§∫
                </label>
            </div>
            <div id="grid-info" style="font-size:10px; color:#666; margin-top:5px;"></div>
        </div>

        <div class="prop-label" style="margin-top:20px;">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</div>
        <button class="btn-primary" id="btn-export" onclick="exportCanvas()">ÁîªÂÉè„Å®„Åó„Å¶Êõ∏„ÅçÂá∫„Åó</button>
    </div>

    <div class="prop-group" id="prop-panel-text" style="display:none;">
        <div class="prop-label">Ë®ò‰∫ã„Éú„ÉÉ„ÇØ„ÇπÁ∑®ÈõÜ</div>
        <textarea id="inp-text" class="prop-textarea" oninput="updateSelectedText()"></textarea>
        
        <div class="prop-label">„Éï„Ç©„É≥„ÉàË®≠ÂÆö</div>
        <select id="inp-fontfamily" class="prop-select" onchange="updateSelectedStyle()">
            <option value='"BIZ UDMincho", serif'>BIZ UDÊòéÊúù (Ê®ôÊ∫ñ)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
            <option value='"Yuji Syuku", serif'>‰ΩëÂ≠ó ÂÆø (Á≠ÜÊñáÂ≠ó)</option>
        </select>

        <div class="prop-row">
            <div style="flex:1; opacity:0.5; pointer-events:none;">
                <span class="prop-label">„Çµ„Ç§„Ç∫(px) [Ëá™Âãï]</span>
                <input type="number" id="inp-fontsize" class="prop-input" readonly>
            </div>
            <div style="flex:1; opacity:0.5; pointer-events:none;">
                <span class="prop-label">Ë°åÈñì(em) [Ëá™Âãï]</span>
                <input type="number" id="inp-lineheight" class="prop-input" readonly>
            </div>
        </div>
        
        <div class="prop-label">Êõ∏Â≠óÊñπÂêë</div>
        <select id="inp-writingmode" class="prop-select" onchange="updateSelectedStyle()">
            <option value="vertical-rl">Á∏¶Êõ∏„Åç</option>
            <option value="horizontal-tb">Ê®™Êõ∏„Åç</option>
        </select>

        <div class="prop-label" style="margin-top:10px;">Ë°®Á§∫„Ç™„Éó„Ç∑„Éß„É≥</div>
        <label style="display:flex; align-items:center; font-size:14px; cursor:pointer;">
            <input type="checkbox" id="inp-showgrid" onchange="updateSelectedStyle()" style="margin-right:5px;"> ÂÄãÂà•„Éû„ÇπÁõÆ
        </label>
        
        <button class="btn-primary" style="background:#e53935; margin-top:20px;" onclick="deleteSelected()">ÂâäÈô§</button>
    </div>
</div>

<script>
    const PX_PER_MM = 2.834645;
    const CHAR_SCALE_RATIO = 0.85;

    const STATE = {
        mode: 'select',
        canvas: {
            width: 297,
            height: 420,
            margin: { top: 20, bottom: 20, left: 20, right: 20 },
            colors: { paper: '#ffffff', ink: '#333333' }
        },
        grid: {
            show: true,
            dan: 6,
            charsPerDan: 11,
            totalLines: 25,
            computed: {
                charSizeW: 0, 
                charSizeH: 0,
                lineGap: 0,
                danHeight: 0,
                danPitch: 0,
                pitchX: 0
            }
        },
        view: { x: 0, y: 0, scale: 1.0 },
        isSpacePressed: false,
        isPanning: false,
        panStart: { x: 0, y: 0 },
        selectedId: null,
        isDragging: false,
        isResizing: false,
        resizeDir: null,
        dragStart: { x: 0, y: 0 },
        elemStart: { x: 0, y: 0 },
        elements: [] 
    };

    const SVG_NS = "http://www.w3.org/2000/svg";
    const mainSvg = document.getElementById('main-svg');
    const canvasContainer = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const layerPaperGrid = document.getElementById('layer-paper-grid');
    const layerContent = document.getElementById('layer-content');
    const layerUi = document.getElementById('layer-ui');
    const paperBg = document.getElementById('paper-bg');
    const svgStyle = document.getElementById('svg-style');

    // „ÉÑ„Éº„É´Âàá„ÇäÊõø„Åà
    document.getElementById('btn-select').onclick = () => setMode('select');
    document.getElementById('btn-text').onclick = () => createTextObject(); 
    document.getElementById('btn-rect').onclick = () => createRectObject();

    function setMode(mode) {
        STATE.mode = mode;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if(mode === 'select') document.getElementById('btn-select').classList.add('active');
        if(mode !== 'select') setTimeout(() => setMode('select'), 200); 
    }

    // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁîüÊàê
    function createID() { return 'el_' + Math.random().toString(36).substr(2, 9); }

    function createTextObject() {
        const vw = viewport.clientWidth; const vh = viewport.clientHeight;
        const svgX = (vw/2 - STATE.view.x) / STATE.view.scale;
        const svgY = (vh/2 - STATE.view.y) / STATE.view.scale;
        
        const cGrid = STATE.grid.computed;
        const initFontSize = cGrid.charSizeW > 0 ? cGrid.charSizeW : 24;
        const initLineHeight = cGrid.charSizeW > 0 ? (cGrid.lineGap / cGrid.charSizeW) + 1 : 1.5;

        const id = createID();
        const data = {
            id: id, type: 'text',
            x: Math.round(svgX - 100), y: Math.round(svgY - 150),
            width: 200, height: 300,
            text: "„Åì„Åì„Å´Ë®ò‰∫ã„ÇíÂÖ•Âäõ\nËÉåÊôØ„Ç∞„É™„ÉÉ„Éâ„Å´\n„Éî„ÉÉ„Çø„É™Âêà„ÅÑ„Åæ„Åô",
            fontSize: initFontSize, 
            lineHeight: initLineHeight,
            writingMode: 'vertical-rl',
            fontFamily: '"BIZ UDMincho", serif',
            charScale: 85, 
            showGrid: false 
        };
        STATE.elements.push(data);
        renderElement(data);
        selectElement(id);
        setMode('select');
    }

    function createRectObject() {
        const vw = viewport.clientWidth; const vh = viewport.clientHeight;
        const svgX = (vw/2 - STATE.view.x) / STATE.view.scale;
        const svgY = (vh/2 - STATE.view.y) / STATE.view.scale;
        const id = createID();
        const data = {
            id: id, type: 'rect',
            x: Math.round(svgX - 50), y: Math.round(svgY - 50),
            width: 100, height: 100,
            fill: 'none', stroke: STATE.canvas.colors.ink 
        };
        STATE.elements.push(data);
        renderElement(data);
        selectElement(id);
        setMode('select');
    }

    // Ë®≠ÂÆöÊõ¥Êñ∞Á≥ª
    function updateCanvasSize() {
        const w_mm = parseFloat(document.getElementById('inp-canvas-w').value);
        const h_mm = parseFloat(document.getElementById('inp-canvas-h').value);
        if (isNaN(w_mm) || isNaN(h_mm)) return;

        STATE.canvas.width = w_mm;
        STATE.canvas.height = h_mm;

        const w_px = Math.round(w_mm * PX_PER_MM);
        const h_px = Math.round(h_mm * PX_PER_MM);

        mainSvg.setAttribute('width', w_px);
        mainSvg.setAttribute('height', h_px);
        mainSvg.setAttribute('viewBox', `0 0 ${w_px} ${h_px}`);
        
        updateMargins();
    }

    function updateMargins() {
        STATE.canvas.margin.top = parseFloat(document.getElementById('inp-margin-t').value) || 0;
        STATE.canvas.margin.bottom = parseFloat(document.getElementById('inp-margin-b').value) || 0;
        STATE.canvas.margin.left = parseFloat(document.getElementById('inp-margin-l').value) || 0;
        STATE.canvas.margin.right = parseFloat(document.getElementById('inp-margin-r').value) || 0;

        renderMarginGuide();
        updateGridSettings(); 
    }

    function updateColors() {
        const paperC = document.getElementById('inp-paper-color').value;
        const inkC = document.getElementById('inp-ink-color').value;
        STATE.canvas.colors.paper = paperC;
        STATE.canvas.colors.ink = inkC;
        paperBg.setAttribute('fill', paperC);
        svgStyle.textContent = `.ink-fill { fill: ${inkC}; } .ink-stroke { stroke: ${inkC}; } text { fill: ${inkC}; }`;
    }

    function updateGridSettings() {
        STATE.grid.show = document.getElementById('inp-layout-show').checked;
        STATE.grid.dan = parseInt(document.getElementById('inp-layout-dan').value) || 1;
        STATE.grid.charsPerDan = parseInt(document.getElementById('inp-layout-chars').value) || 1;
        STATE.grid.totalLines = parseInt(document.getElementById('inp-layout-lines').value) || 1;

        renderPaperGrid();
        syncAllTextElements();
    }

    function swapCanvasSize() {
        const wInput = document.getElementById('inp-canvas-w');
        const hInput = document.getElementById('inp-canvas-h');
        const temp = wInput.value;
        wInput.value = hInput.value;
        hInput.value = temp;
        updateCanvasSize();
    }

    function setCanvasPreset(w, h) {
        document.getElementById('inp-canvas-w').value = w;
        document.getElementById('inp-canvas-h').value = h;
        updateCanvasSize();
        fitView();
    }

    // „Ç∞„É™„ÉÉ„ÉâÊèèÁîª
    function renderPaperGrid() {
        layerPaperGrid.innerHTML = ''; 
        
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const mb = STATE.canvas.margin.bottom * PX_PER_MM;
        const ml = STATE.canvas.margin.left * PX_PER_MM;
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        
        const w_px = STATE.canvas.width * PX_PER_MM;
        const h_px = STATE.canvas.height * PX_PER_MM;
        
        const validW = w_px - ml - mr;
        const validH = h_px - mt - mb;

        const danCount = STATE.grid.dan;
        const charsPerDan = STATE.grid.charsPerDan; 
        const totalLines = STATE.grid.totalLines;

        // Ë®àÁÆó: Á∏¶ÊñπÂêë
        const totalHUnits = (charsPerDan * danCount) + (danCount - 1);
        const cellHeight = validH / totalHUnits; 
        const danPitch = (charsPerDan * cellHeight) + cellHeight;

        // Ë®àÁÆó: Ê®™ÊñπÂêë
        const fontSizeW = cellHeight / CHAR_SCALE_RATIO;
        const totalCharW = fontSizeW * totalLines;
        
        let lineGap = 0;
        if (totalLines > 1) {
            lineGap = (validW - totalCharW) / (totalLines - 1);
        }

        // ‰øùÂ≠ò
        STATE.grid.computed.charSizeW = fontSizeW;
        STATE.grid.computed.charSizeH = cellHeight;
        STATE.grid.computed.lineGap = lineGap;
        STATE.grid.computed.danHeight = cellHeight * charsPerDan;
        STATE.grid.computed.danPitch = danPitch;
        STATE.grid.computed.pitchX = fontSizeW + lineGap;

        // ÊÉÖÂ†±Ë°®Á§∫
        const fontSizeMm = (fontSizeW / PX_PER_MM).toFixed(2);
        const gapMm = (lineGap / PX_PER_MM).toFixed(2);
        document.getElementById('grid-info').innerHTML = `ÊñáÂ≠ó„Çµ„Ç§„Ç∫: ${fontSizeMm}mm / Ë°åÈñì: ${gapMm}mm`;

        if (!STATE.grid.show) return;

        // ÊèèÁîª
        for (let l = 0; l < totalLines; l++) {
            const lineX = (w_px - mr) - fontSizeW - (l * (fontSizeW + lineGap));
            
            for (let d = 0; d < danCount; d++) {
                const startY = mt + (d * danPitch);
                for (let c = 0; c < charsPerDan; c++) {
                    const charY = startY + (c * cellHeight);
                    const rect = document.createElementNS(SVG_NS, 'rect');
                    rect.setAttribute('x', lineX);
                    rect.setAttribute('y', charY);
                    rect.setAttribute('width', fontSizeW);
                    rect.setAttribute('height', cellHeight);
                    rect.setAttribute('class', 'grid-rect');
                    layerPaperGrid.appendChild(rect);
                }
            }
        }
        // ÊÆµÈñìÁ∑ö
        for (let d = 0; d < danCount - 1; d++) {
            const y = mt + (d * danPitch) + (charsPerDan * cellHeight) + (cellHeight / 2);
            const line = document.createElementNS(SVG_NS, 'line');
            line.setAttribute('x1', ml); line.setAttribute('x2', w_px - mr);
            line.setAttribute('y1', y); line.setAttribute('y2', y);
            line.setAttribute('class', 'grid-dan-border');
            layerPaperGrid.appendChild(line);
        }
    }

    function renderMarginGuide() {
        const oldGuide = document.getElementById('margin-guide-rect');
        if (oldGuide) oldGuide.remove();

        const w_px = STATE.canvas.width * PX_PER_MM;
        const h_px = STATE.canvas.height * PX_PER_MM;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const mb = STATE.canvas.margin.bottom * PX_PER_MM;
        const ml = STATE.canvas.margin.left * PX_PER_MM;
        const mr = STATE.canvas.margin.right * PX_PER_MM;

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.id = 'margin-guide-rect';
        rect.setAttribute('x', ml); rect.setAttribute('y', mt);
        rect.setAttribute('width', Math.max(0, w_px - ml - mr));
        rect.setAttribute('height', Math.max(0, h_px - mt - mb));
        rect.setAttribute('class', 'margin-guide');
        layerUi.appendChild(rect);
    }

    function syncAllTextElements() {
        const cGrid = STATE.grid.computed;
        if (cGrid.charSizeW <= 0) return;
        const newFontSize = cGrid.charSizeW;
        const newLineHeight = (cGrid.charSizeW + cGrid.lineGap) / cGrid.charSizeW;

        STATE.elements.forEach(data => {
            if (data.type === 'text') {
                data.fontSize = newFontSize;
                data.lineHeight = newLineHeight;
                data.writingMode = 'vertical-rl';
                data.charScale = 85;
                renderElement(data);
            }
        });
        if(STATE.selectedId) renderUi();
    }

    // Ë¶ÅÁ¥†„É¨„É≥„ÉÄ„É™„É≥„Ç∞
    function renderElement(data) {
        let group = document.getElementById(data.id);
        if (!group) {
            group = document.createElementNS(SVG_NS, 'g');
            group.id = data.id;
            group.addEventListener('mousedown', (e) => onElemMouseDown(e, data.id));
            layerContent.appendChild(group);
        }

        const scaleVal = (data.charScale || 85) / 100;
        
        if (data.type === 'text') {
            group.setAttribute('transform', `translate(${data.x}, ${data.y}) scale(1, ${scaleVal})`);
        } else {
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);
        }
        group.innerHTML = '';
        
        if (data.type === 'text') {
            const cGrid = STATE.grid.computed;
            let drawFontSize = data.fontSize;
            let drawPitchX = data.fontSize * data.lineHeight;
            if (cGrid.charSizeW > 0) {
                drawFontSize = cGrid.charSizeW;
                drawPitchX = cGrid.pitchX; 
            }

            const effW = data.width;
            const effH = data.height / scaleVal;

            const textEl = document.createElementNS(SVG_NS, 'text');
            textEl.setAttribute('font-family', data.fontFamily);
            textEl.setAttribute('font-size', drawFontSize);
            textEl.setAttribute('writing-mode', data.writingMode);
            textEl.setAttribute('dominant-baseline', 'central'); 
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('class', 'ink-fill'); 
            textEl.style.fontFamily = data.fontFamily;
            
            const lines = data.text.split('\n');
            lines.forEach((lineText, i) => {
                const chars = lineText.split('');
                chars.forEach((char, j) => {
                    const tspan = document.createElementNS(SVG_NS, 'tspan');
                    tspan.textContent = char;
                    
                    const centerX = effW - (drawFontSize / 2) - (i * drawPitchX);
                    const centerY = (j * drawFontSize) + (drawFontSize / 2);
                    
                    tspan.setAttribute('x', centerX); tspan.setAttribute('y', centerY);
                    textEl.appendChild(tspan);
                });
            });
            group.appendChild(textEl);

            if (data.showGrid) {
                const gridGroup = document.createElementNS(SVG_NS, 'g');
                gridGroup.style.pointerEvents = 'none';
                
                const cols = Math.floor(effW / drawPitchX);
                const rows = Math.floor(effH / drawFontSize);
                for (let c = 0; c < cols; c++) {
                    const centerX = effW - (drawFontSize / 2) - (c * drawPitchX);
                    const cellX = centerX - (drawFontSize / 2);
                    for (let r = 0; r < rows; r++) {
                        const centerY = (r * drawFontSize) + (drawFontSize / 2);
                        const cellY = centerY - (drawFontSize / 2);
                        const rect = document.createElementNS(SVG_NS, 'rect');
                        rect.setAttribute('x', cellX); rect.setAttribute('y', cellY);
                        rect.setAttribute('width', drawFontSize); rect.setAttribute('height', drawFontSize);
                        rect.setAttribute('class', 'grid-rect');
                        gridGroup.appendChild(rect);
                    }
                }
                group.prepend(gridGroup);
            }

        } else if (data.type === 'rect') {
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', 0); rect.setAttribute('y', 0);
            rect.setAttribute('width', data.width); 
            rect.setAttribute('height', data.height);
            rect.setAttribute('fill', data.fill); 
            rect.setAttribute('stroke', STATE.canvas.colors.ink); 
            rect.setAttribute('class', 'ink-stroke'); 
            group.appendChild(rect);
        }
    }

    // UIÊõ¥Êñ∞
    function renderUi() {
        layerUi.innerHTML = ''; 
        renderMarginGuide();

        if (!STATE.selectedId) {
            document.getElementById('prop-panel-none').style.display = 'block';
            document.getElementById('prop-panel-text').style.display = 'none';
            return;
        }

        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if (!data) return;

        document.getElementById('prop-panel-none').style.display = 'none';
        if (data.type === 'text') {
            document.getElementById('prop-panel-text').style.display = 'block';
            if (document.activeElement.id !== 'inp-text') document.getElementById('inp-text').value = data.text;
            
            const cGrid = STATE.grid.computed;
            if(cGrid.charSizeW > 0) {
                document.getElementById('inp-fontsize').value = Math.round(cGrid.charSizeW);
                document.getElementById('inp-lineheight').value = (cGrid.pitchX / cGrid.charSizeW).toFixed(2);
            } else {
                document.getElementById('inp-fontsize').value = data.fontSize;
                document.getElementById('inp-lineheight').value = data.lineHeight;
            }
            
            document.getElementById('inp-fontfamily').value = data.fontFamily || '"BIZ UDMincho", serif';
            document.getElementById('inp-showgrid').checked = data.showGrid || false;
        }

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
        rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
        rect.setAttribute('class', 'selection-rect');
        layerUi.appendChild(rect);
        
        createHandle(data.x, data.y, 'nw');
        createHandle(data.x + data.width, data.y, 'ne');
        createHandle(data.x, data.y + data.height, 'sw');
        createHandle(data.x + data.width, data.y + data.height, 'se');
    }

    function createHandle(x, y, dir) {
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', x); circle.setAttribute('cy', y);
        circle.setAttribute('class', `resize-handle cursor-${dir}`);
        circle.addEventListener('mousedown', (e) => onHandleMouseDown(e, dir));
        layerUi.appendChild(circle);
    }

    function selectElement(id) {
        STATE.selectedId = id;
        renderUi();
    }
    
    function deleteSelected() {
        if (!STATE.selectedId) return;
        document.getElementById(STATE.selectedId).remove(); 
        STATE.elements = STATE.elements.filter(e => e.id !== STATE.selectedId);
        STATE.selectedId = null;
        renderUi();
    }

    function onElemMouseDown(e, id) {
        if (STATE.isSpacePressed) return;
        e.stopPropagation();
        selectElement(id);
        STATE.isDragging = true;
        const pt = getSvgPoint(e);
        STATE.dragStart = { x: pt.x, y: pt.y };
        const data = STATE.elements.find(el => el.id === id);
        STATE.elemStart = { x: data.x, y: data.y };
    }

    function onHandleMouseDown(e, dir) {
        if (STATE.isSpacePressed) return;
        e.stopPropagation();
        STATE.isResizing = true;
        STATE.resizeDir = dir;
        const pt = getSvgPoint(e);
        STATE.dragStart = { x: pt.x, y: pt.y };
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        STATE.elemStart = { x: data.x, y: data.y, w: data.width, h: data.height };
    }

    function getSvgPoint(e) {
        const vpRect = viewport.getBoundingClientRect();
        const vx = e.clientX - vpRect.left - STATE.view.x;
        const vy = e.clientY - vpRect.top - STATE.view.y;
        return { x: vx / STATE.view.scale, y: vy / STATE.view.scale };
    }

    window.addEventListener('mousemove', (e) => {
        if (STATE.isPanning) {
            STATE.view.x = STATE.viewStart.x + (e.clientX - STATE.panStart.x);
            STATE.view.y = STATE.viewStart.y + (e.clientY - STATE.panStart.y);
            updateTransform();
            return;
        }
        
        const pt = getSvgPoint(e);
        const dx = pt.x - STATE.dragStart.x;
        const dy = pt.y - STATE.dragStart.y;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);

        if (STATE.isDragging && data) {
            let newX = STATE.elemStart.x + dx;
            let newY = STATE.elemStart.y + dy;
            
            if (data.type === 'text') {
                const cGrid = STATE.grid.computed;
                if (cGrid.charSizeW > 0) {
                    const mr = STATE.canvas.margin.right * PX_PER_MM;
                    const w_px = STATE.canvas.width * PX_PER_MM;
                    const rightEdge = w_px - mr;
                    const pitchX = cGrid.pitchX; 
                    
                    const currentRight = newX + data.width;
                    const colIndex = Math.round((rightEdge - currentRight) / pitchX);
                    const snappedRight = rightEdge - (colIndex * pitchX);
                    newX = snappedRight - data.width;

                    const mt = STATE.canvas.margin.top * PX_PER_MM;
                    const relY = newY - mt;
                    const danIndex = Math.floor(relY / cGrid.danPitch);
                    const danStart = mt + (danIndex * cGrid.danPitch);
                    const relYInDan = newY - danStart;
                    const charIndexInDan = Math.round(relYInDan / cGrid.charSizeH);
                    newY = danStart + (charIndexInDan * cGrid.charSizeH);
                }
            }
            data.x = newX;
            data.y = newY;
            renderElement(data);
            renderUi();

        } else if (STATE.isResizing && data) {
            const dir = STATE.resizeDir;
            let newX = STATE.elemStart.x;
            let newY = STATE.elemStart.y;
            let newW = STATE.elemStart.w;
            let newH = STATE.elemStart.h;

            if (dir.includes('e')) newW = Math.max(10, STATE.elemStart.w + dx);
            if (dir.includes('s')) newH = Math.max(10, STATE.elemStart.h + dy);
            if (dir.includes('w')) {
                const w = Math.max(10, STATE.elemStart.w - dx);
                newX = STATE.elemStart.x + (STATE.elemStart.w - w);
                newW = w;
            }
            if (dir.includes('n')) {
                const h = Math.max(10, STATE.elemStart.h - dy);
                newY = STATE.elemStart.y + (STATE.elemStart.h - h);
                newH = h;
            }

            if (data.type === 'text') {
                const cGrid = STATE.grid.computed;
                if (cGrid.charSizeW > 0) {
                    const mr = STATE.canvas.margin.right * PX_PER_MM;
                    const w_px = STATE.canvas.width * PX_PER_MM;
                    const rightEdge = w_px - mr;
                    const pitchX = cGrid.pitchX;
                    const mt = STATE.canvas.margin.top * PX_PER_MM;

                    if (dir.includes('w')) {
                        const currentRight = newX + newW;
                        const colN = Math.round((rightEdge - cGrid.charSizeW - newX) / pitchX);
                        const snappedX = rightEdge - (colN * pitchX) - cGrid.charSizeW;
                        newW = currentRight - snappedX;
                        newX = snappedX;
                    }
                    if (dir.includes('e')) {
                        const currentLeft = newX;
                        const currentRight = newX + newW;
                        const colN = Math.round((rightEdge - currentRight) / pitchX);
                        const snappedRight = rightEdge - (colN * pitchX);
                        newW = snappedRight - currentLeft;
                    }
                    if (dir.includes('n')) {
                        const currentBottom = newY + newH;
                        const rowN = Math.round((newY - mt) / cGrid.charSizeH);
                        const snappedY = mt + (rowN * cGrid.charSizeH);
                        newH = currentBottom - snappedY;
                        newY = snappedY;
                    }
                    if (dir.includes('s')) {
                        const currentTop = newY;
                        const currentBottom = newY + newH;
                        const rowN = Math.round((currentBottom - mt) / cGrid.charSizeH);
                        const snappedBottom = mt + (rowN * cGrid.charSizeH);
                        newH = snappedBottom - currentTop;
                    }
                }
            }
            if(newW < 10) newW = 10;
            if(newH < 10) newH = 10;
            data.x = newX; data.y = newY; data.width = newW; data.height = newH;
            renderElement(data);
            renderUi();
        }
    });

    mainSvg.addEventListener('mousedown', (e) => {
        if (STATE.isSpacePressed) return;
        if (e.target === mainSvg) {
            STATE.selectedId = null;
            renderUi();
        }
    });

    viewport.addEventListener('mousedown', (e) => {
        if (STATE.isSpacePressed || e.button === 1) {
            e.preventDefault();
            STATE.isPanning = true;
            STATE.panStart = { x: e.clientX, y: e.clientY };
            STATE.viewStart = { x: STATE.view.x, y: STATE.view.y };
        }
    });
    window.addEventListener('mouseup', () => {
        STATE.isPanning = false; 
        STATE.isDragging = false; 
        STATE.isResizing = false;
    });
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.altKey || e.ctrlKey) {
            const zoomFactor = 0.05;
            const delta = -Math.sign(e.deltaY);
            let newScale = STATE.view.scale * (1 + delta * zoomFactor);
            newScale = Math.max(0.1, Math.min(newScale, 10.0));
            const rect = viewport.getBoundingClientRect();
            const offsetX = (e.clientX - rect.left) - STATE.view.x;
            const offsetY = (e.clientY - rect.top) - STATE.view.y;
            STATE.view.x -= offsetX * (newScale / STATE.view.scale - 1);
            STATE.view.y -= offsetY * (newScale / STATE.view.scale - 1);
            STATE.view.scale = newScale;
        } else {
            STATE.view.x -= e.deltaX;
            STATE.view.y -= e.deltaY;
        }
        updateTransform();
    }, { passive: false });
    window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
        if (e.code === 'Space' && !STATE.isSpacePressed) {
            STATE.isSpacePressed = true;
            viewport.classList.add('hand-mode');
        }
        if ((e.key === 'Delete' || e.key === 'Backspace') && STATE.selectedId) deleteSelected();
        if (!e.ctrlKey && !e.metaKey && !STATE.isSpacePressed) {
            if (e.key === 'v') setMode('select');
            if (e.key === 't') createTextObject();
            if (e.key === 'r') createRectObject();
            if (e.key === '0' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); fitView(); }
        }
    });
    window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            STATE.isSpacePressed = false;
            STATE.isPanning = false;
            viewport.classList.remove('hand-mode');
        }
    });

    function updateTransform() {
        canvasContainer.style.transform = `translate(${STATE.view.x}px, ${STATE.view.y}px) scale(${STATE.view.scale})`;
    }
    
    // „Éò„É´„Éë„Éº: URL„Åã„ÇâBlob„ÇíÂèñÂæó„ÅóBase64„Å´Â§âÊèõ
    async function urlToBase64(url) {
        try {
            const res = await fetch(url);
            const blob = await res.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        } catch (e) {
            console.warn('Font fetch failed:', url, e);
            return null;
        }
    }

    // „Éò„É´„Éë„Éº: Google Fonts CSSÂÜÖ„ÅÆURL„ÇíBase64Âåñ
    async function getEmbeddableFontCss(cssUrl) {
        try {
            const res = await fetch(cssUrl);
            let cssText = await res.text();
            
            const urlRegex = /url\((['"]?)(https:\/\/[^'"\)]+)\1\)/g;
            let match;
            const replacements = [];

            while ((match = urlRegex.exec(cssText)) !== null) {
                replacements.push({
                    original: match[0],
                    url: match[2]
                });
            }

            const uniqueUrls = [...new Set(replacements.map(r => r.url))];
            const base64Map = {};
            
            await Promise.all(uniqueUrls.map(async (url) => {
                const base64 = await urlToBase64(url);
                if (base64) base64Map[url] = base64;
            }));

            for (const rep of replacements) {
                if (base64Map[rep.url]) {
                    cssText = cssText.split(rep.original).join(`url("${base64Map[rep.url]}")`);
                }
            }
            return cssText;
        } catch (e) {
            console.warn('CSS processing failed:', e);
            return '';
        }
    }

    async function exportCanvas() {
        // UIÈùûË°®Á§∫ (‰∏ÄÊôÇÁöÑ)
        layerUi.style.display = 'none';
        layerPaperGrid.style.display = 'none';
        
        const btn = document.getElementById('btn-export');
        const originalText = btn.textContent;
        btn.textContent = "ÁîüÊàê‰∏≠...";
        btn.disabled = true;

        try {
            const currentW = parseFloat(mainSvg.getAttribute('width'));
            const currentH = parseFloat(mainSvg.getAttribute('height'));
            
            // „ÇØ„É≠„Éº„É≥‰ΩúÊàê
            const svgClone = mainSvg.cloneNode(true);
            
            // „Éï„Ç©„É≥„ÉàÂüã„ÇÅËæº„Åø
            const fontCssUrl = 'https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block';
            const embeddedCss = await getEmbeddableFontCss(fontCssUrl);
            
            const styleEl = document.createElementNS(SVG_NS, 'style');
            const existingStyle = document.getElementById('svg-style').textContent;
            styleEl.textContent = embeddedCss + '\n' + existingStyle;
            
            let defs = svgClone.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS(SVG_NS, 'defs');
                svgClone.prepend(defs);
            }
            defs.appendChild(styleEl);

            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const scale = 4;
                canvas.width = currentW * scale; 
                canvas.height = currentH * scale;
                const ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);
                
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = 'newspaper_export.png';
                a.click();
                URL.revokeObjectURL(url);
                
                // ÂÖÉ„Å´Êàª„Åô
                layerUi.style.display = 'block';
                layerPaperGrid.style.display = 'block';
                btn.textContent = originalText;
                btn.disabled = false;
            };
            img.src = url;
        } catch(e) {
            console.error(e);
            alert("„Ç®„ÇØ„Çπ„Éù„Éº„Éà‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü");
            layerUi.style.display = 'block';
            layerPaperGrid.style.display = 'block';
            btn.textContent = originalText;
            btn.disabled = false;
        }
    }

    function updateSelectedText() {
        if (!STATE.selectedId) return;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        data.text = document.getElementById('inp-text').value;
        renderElement(data);
    }

    function updateSelectedStyle() {
        if (!STATE.selectedId) return;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        data.fontFamily = document.getElementById('inp-fontfamily').value;
        data.showGrid = document.getElementById('inp-showgrid').checked;
        renderElement(data);
        renderUi(); 
    }

    function fitView() {
        const vw = viewport.clientWidth;
        const vh = viewport.clientHeight;
        const w_px = STATE.canvas.width * PX_PER_MM;
        const h_px = STATE.canvas.height * PX_PER_MM;
        const margin = 40;
        const scale = Math.min((vw - margin*2) / w_px, (vh - margin*2) / h_px);
        STATE.view.scale = Math.max(0.1, Math.min(scale, 5.0));
        STATE.view.x = (vw - w_px * STATE.view.scale) / 2;
        STATE.view.y = (vh - h_px * STATE.view.scale) / 2;
        updateTransform();
    }

    window.addEventListener('load', () => {
        updateCanvasSize();
        updateGridSettings(); 
        updateColors(); 
        fitView();
    });
</script>
</body>
</html>