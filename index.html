<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SVG Newspaper Tool Core</title>
<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block" rel="stylesheet">

<style>
    :root {
        --ui-bg: #f5f5f5;
        --panel-bg: #ffffff;
        --border-col: #ddd;
        --primary: #2196f3;
        --text: #333;
    }
    body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
        font-family: "Noto Sans JP", sans-serif;
        background: var(--ui-bg);
        color: var(--text);
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
    }

    /* Â∑¶„Çµ„Ç§„Éâ„Éê„Éº */
    .toolbar {
        width: 60px;
        background: var(--panel-bg);
        border-right: 1px solid var(--border-col);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
        z-index: 100;
    }
    .tool-btn {
        width: 40px; height: 40px;
        margin-bottom: 10px;
        border: 1px solid var(--border-col);
        background: #fff;
        cursor: pointer;
        border-radius: 4px;
        display: flex; justify-content: center; align-items: center;
        font-size: 20px;
        transition: 0.2s;
    }
    .tool-btn:hover { background: #eee; }
    .tool-btn.active { background: var(--primary); color: #fff; border-color: var(--primary); }

    /* „É°„Ç§„É≥„Ç®„É™„Ç¢ */
    .viewport {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #e0e0e0;
        background-image: radial-gradient(#ccc 1px, transparent 1px);
        background-size: 20px 20px;
        cursor: default;
        touch-action: none;
    }
    .viewport.mode-create { cursor: crosshair; }
    .viewport.hand-mode { cursor: grab; }
    .viewport.hand-mode:active { cursor: grabbing; }

    /* SVGÁî®Á¥ô„Ç≥„É≥„ÉÜ„Éä */
    #canvas-container {
        transform-origin: 0 0;
        position: absolute;
        top: 0; left: 0;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
        will-change: transform;
    }

    /* SVGÁî®Á¥ô */
    #main-svg {
        background: transparent;
        display: block; 
        transition: width 0.3s, height 0.3s;
        shape-rendering: geometricPrecision;
        text-rendering: geometricPrecision;
        overflow: visible;
    }

    /* Âè≥„Çµ„Ç§„Éâ„Éê„Éº */
    .properties {
        width: 280px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border-col);
        padding: 15px;
        box-sizing: border-box;
        overflow-y: auto;
        z-index: 100;
    }
    .prop-group { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
    .prop-group:last-child { border-bottom: none; }
    .prop-label { font-size: 12px; font-weight: bold; margin-bottom: 5px; display: block; color: #555; }
    .prop-row { display: flex; gap: 5px; margin-bottom: 8px; align-items: center; }
    
    .prop-input, .prop-select, .prop-textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 6px;
        border: 1px solid var(--border-col);
        margin-bottom: 8px;
        font-size: 14px;
        font-family: inherit;
    }
    .prop-textarea { resize: vertical; min-height: 100px; }
    
    .btn-primary {
        width: 100%; padding: 8px;
        background: var(--primary); color: white;
        border: none; border-radius: 4px; cursor: pointer;
    }
    .btn-primary:hover { opacity: 0.9; }

    .btn-secondary {
        flex: 1; padding: 6px;
        background: #f0f0f0; color: #333;
        border: 1px solid var(--border-col);
        border-radius: 4px; cursor: pointer;
        font-size: 12px;
        text-align: center;
    }
    .btn-secondary:hover { background: #e0e0e0; }

    /* SVGÂÜÖ UI„Çπ„Çø„Ç§„É´ */
    .selection-rect {
        fill: none;
        stroke: var(--primary);
        stroke-width: 2px;
        stroke-dasharray: 4 2;
        pointer-events: none; 
        vector-effect: non-scaling-stroke;
    }
    
    /* ÁîüÊàê‰∏≠„ÅÆ„Éó„É¨„Éì„É•„ÉºÁü©ÂΩ¢ */
    .creation-preview-rect {
        fill: rgba(33, 150, 243, 0.2);
        stroke: var(--primary);
        stroke-width: 1px;
        stroke-dasharray: 4 2;
        pointer-events: none;
        vector-effect: non-scaling-stroke;
    }

    /* „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´ */
    .resize-handle {
        fill: white;
        stroke: var(--primary);
        stroke-width: 2px;
        cursor: pointer;
        vector-effect: non-scaling-stroke;
        pointer-events: all !important; /* ÊúÄÈáçË¶Å */
    }
    .resize-handle:hover, .resize-handle:active {
        fill: var(--primary);
    }
    .cursor-nw { cursor: nw-resize; }
    .cursor-ne { cursor: ne-resize; }
    .cursor-sw { cursor: sw-resize; }
    .cursor-se { cursor: se-resize; }

    .margin-guide {
        fill: none;
        stroke: #00bcd4;
        stroke-width: 1px;
        stroke-dasharray: 5 5;
        pointer-events: none;
        vector-effect: non-scaling-stroke;
    }
    
    text { user-select: none; pointer-events: none; }
    
    .grid-line { stroke: #b3e5fc; stroke-width: 0.5px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
    .grid-rect { stroke: #b3e5fc; stroke-width: 0.5px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
    .grid-dan-border { stroke: #81d4fa; stroke-width: 1px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
    
    /* „Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Éí„ÉÉ„Éà„Ç®„É™„Ç¢Áî® (ÈÄèÊòé„Å†„Åå„Ç§„Éô„É≥„Éà„ÅØÂèó„Åë„Çã) */
    .hit-rect {
        fill: #ffffff;
        fill-opacity: 0;
        cursor: move;
        pointer-events: all;
    }
</style>
</head>
<body>

<div class="toolbar">
    <button class="tool-btn active" id="btn-select" title="ÈÅ∏Êäû (V)" onclick="setMode('select')">üëÜ</button>
    <button class="tool-btn" id="btn-text" title="Ë®ò‰∫ã (T)" onclick="setMode('text')">T</button>
    <button class="tool-btn" id="btn-rect" title="Áü©ÂΩ¢ (R)" onclick="setMode('rect')">‚¨ú</button>
    <div style="flex:1"></div>
    <button class="tool-btn" onclick="fitView()" title="ÂÖ®‰ΩìË°®Á§∫">üîç</button>
</div>

<div class="viewport" id="viewport">
    <div id="canvas-container">
        <svg id="main-svg" width="297" height="420" viewBox="0 0 297 420" xmlns="http://www.w3.org/2000/svg" overflow="visible">
            <defs>
                <style id="svg-style">
                    .ink-fill { fill: #333333; }
                    .ink-stroke { stroke: #333333; }
                </style>
            </defs>
            <rect id="paper-bg" x="0" y="0" width="100%" height="100%" fill="#ffffff"></rect>
            <g id="layer-paper-grid"></g>
            <g id="layer-grid"></g>
            <g id="layer-content"></g>
            <g id="layer-ui"></g>
        </svg>
    </div>
</div>

<div class="properties">
    <!-- Ë®≠ÂÆö„Éë„Éç„É´ -->
    <div class="prop-group" id="prop-panel-none">
        <div class="prop-label">Áî®Á¥ô„Çµ„Ç§„Ç∫ (mm)</div>
        <div class="prop-row">
            <input type="number" id="inp-canvas-w" class="prop-input" value="297" onchange="updateCanvasSize()">
            <span style="font-size:12px;">√ó</span>
            <input type="number" id="inp-canvas-h" class="prop-input" value="420" onchange="updateCanvasSize()">
        </div>
        <div class="prop-row">
            <button class="btn-secondary" onclick="setCanvasPreset(210, 297)">A4</button>
            <button class="btn-secondary" onclick="setCanvasPreset(297, 420)">A3</button>
            <button class="btn-secondary" onclick="setCanvasPreset(257, 364)">B4</button>
            <button class="btn-secondary" onclick="swapCanvasSize()">Á∏¶Ê®™ÂÖ•Êõø</button>
        </div>

        <div class="prop-label" style="margin-top:15px;">„Ç´„É©„ÉºË®≠ÂÆö</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">Á¥ô„ÅÆËâ≤</span>
            <input type="color" id="inp-paper-color" value="#ffffff" onchange="updateColors()" style="height:24px;">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">„Ç§„É≥„ÇØ„ÅÆËâ≤</span>
            <input type="color" id="inp-ink-color" value="#333333" onchange="updateColors()" style="height:24px;">
        </div>

        <div class="prop-label" style="margin-top:15px;">„Éû„Éº„Ç∏„É≥ (mm)</div>
        <div class="prop-row">
            <span style="font-size:11px; width:15px;">‰∏ä</span>
            <input type="number" id="inp-margin-t" class="prop-input" value="20" onchange="updateMargins()">
            <span style="font-size:11px; width:15px;">‰∏ã</span>
            <input type="number" id="inp-margin-b" class="prop-input" value="20" onchange="updateMargins()">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; width:15px;">Â∑¶</span>
            <input type="number" id="inp-margin-l" class="prop-input" value="20" onchange="updateMargins()">
            <span style="font-size:11px; width:15px;">Âè≥</span>
            <input type="number" id="inp-margin-r" class="prop-input" value="20" onchange="updateMargins()">
        </div>

        <div class="prop-label" style="margin-top:15px; color:#2196f3;">Á¥ôÈù¢Ââ≤‰ªò</div>
        <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee;">
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">Á∏¶„ÅÆÊÆµÊï∞</span>
                <input type="number" id="inp-layout-dan" class="prop-input" style="flex:0.6" value="6" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">1ÊÆµ„ÅÆÊñáÂ≠óÊï∞</span>
                <input type="number" id="inp-layout-chars" class="prop-input" style="flex:0.6" value="11" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">ÂÖ®‰Ωì„ÅÆË°åÊï∞</span>
                <input type="number" id="inp-layout-lines" class="prop-input" style="flex:0.6" value="25" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center;">
                    <input type="checkbox" id="inp-layout-show" checked onchange="updateGridSettings()" style="margin-right:5px;"> „Ç∞„É™„ÉÉ„ÉâË°®Á§∫
                </label>
            </div>
            <div id="grid-info" style="font-size:10px; color:#666; margin-top:5px;"></div>
        </div>

        <div class="prop-label" style="margin-top:20px;">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</div>
        <button class="btn-primary" id="btn-export" onclick="exportCanvas()">ÁîªÂÉè„Å®„Åó„Å¶Êõ∏„ÅçÂá∫„Åó</button>
    </div>

    <div class="prop-group" id="prop-panel-text" style="display:none;">
        <div class="prop-label">Ë®ò‰∫ã„Éú„ÉÉ„ÇØ„ÇπÁ∑®ÈõÜ</div>
        <textarea id="inp-text" class="prop-textarea" oninput="updateSelectedText()"></textarea>
        
        <div class="prop-label">„Éï„Ç©„É≥„ÉàË®≠ÂÆö</div>
        <select id="inp-fontfamily" class="prop-select" onchange="updateSelectedStyle()">
            <option value='"BIZ UDMincho", serif'>BIZ UDÊòéÊúù (Ê®ôÊ∫ñ)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
            <option value='"Yuji Syuku", serif'>‰ΩëÂ≠ó ÂÆø (Á≠ÜÊñáÂ≠ó)</option>
        </select>

        <div class="prop-row">
            <div style="flex:1; opacity:0.5; pointer-events:none;">
                <span class="prop-label">„Çµ„Ç§„Ç∫(px) [Ëá™Âãï]</span>
                <input type="number" id="inp-fontsize" class="prop-input" readonly>
            </div>
            <div style="flex:1; opacity:0.5; pointer-events:none;">
                <span class="prop-label">Ë°åÈñì(em) [Ëá™Âãï]</span>
                <input type="number" id="inp-lineheight" class="prop-input" readonly>
            </div>
        </div>
        
        <div class="prop-label">Êõ∏Â≠óÊñπÂêë</div>
        <select id="inp-writingmode" class="prop-select" onchange="updateSelectedStyle()">
            <option value="vertical-rl">Á∏¶Êõ∏„Åç</option>
            <option value="horizontal-tb">Ê®™Êõ∏„Åç</option>
        </select>

        <div class="prop-label" style="margin-top:10px;">Ë°®Á§∫„Ç™„Éó„Ç∑„Éß„É≥</div>
        <label style="display:flex; align-items:center; font-size:14px; cursor:pointer;">
            <input type="checkbox" id="inp-showgrid" onchange="updateSelectedStyle()" style="margin-right:5px;"> ÂÄãÂà•„Éû„ÇπÁõÆ
        </label>
        
        <button class="btn-primary" style="background:#e53935; margin-top:20px;" onclick="deleteSelected()">ÂâäÈô§</button>
    </div>
</div>

<script>
    const PX_PER_MM = 2.834645;
    const CHAR_SCALE_RATIO = 0.85;

    const STATE = {
        mode: 'select',
        canvas: { width: 297, height: 420, margin: { top: 20, bottom: 20, left: 20, right: 20 }, colors: { paper: '#ffffff', ink: '#333333' } },
        grid: { show: true, dan: 6, charsPerDan: 11, totalLines: 25, computed: { charSizeW: 0, charSizeH: 0, lineGap: 0, danHeight: 0, danPitch: 0, pitchX: 0 } },
        view: { x: 0, y: 0, scale: 1.0 },
        activePointerId: null,
        interactionType: null, // 'pan', 'drag', 'resize', 'create'
        selectedId: null,
        resizeDir: null,
        pointerStart: { x: 0, y: 0 },
        elemStart: { x: 0, y: 0, w: 0, h: 0 },
        viewStart: { x: 0, y: 0, scale: 1 },
        touchStartDist: 0,
        touchStartCenter: { x: 0, y: 0 },
        pinchStartCanvas: { x: 0, y: 0 },
        resizeAnchor: { x: 0, y: 0 },
        elements: [] 
    };

    const SVG_NS = "http://www.w3.org/2000/svg";
    const mainSvg = document.getElementById('main-svg');
    const canvasContainer = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const layerPaperGrid = document.getElementById('layer-paper-grid');
    const layerContent = document.getElementById('layer-content');
    const layerUi = document.getElementById('layer-ui');
    const paperBg = document.getElementById('paper-bg');
    const svgStyle = document.getElementById('svg-style');

    // --- Events ---
    viewport.addEventListener('pointerdown', onPointerDown);
    viewport.addEventListener('pointermove', onPointerMove);
    viewport.addEventListener('pointerup', onPointerUp);
    viewport.addEventListener('pointercancel', onPointerUp);
    viewport.addEventListener('touchstart', onTouchStart, { passive: false });
    viewport.addEventListener('touchmove', onTouchMove, { passive: false });
    viewport.addEventListener('touchend', onTouchEnd);
    viewport.addEventListener('wheel', onWheel, { passive: false });

    document.getElementById('btn-select').onclick = () => setMode('select');
    document.getElementById('btn-text').onclick = () => setMode('text');
    document.getElementById('btn-rect').onclick = () => setMode('rect');
    document.getElementById('btn-export').onclick = exportCanvas;

    // --- Handlers ---
    function onPointerDown(e) {
        if (!e.isPrimary) return; 
        if (STATE.touchStartDist > 0) return; 

        const target = e.target;
        const pt = getSvgPoint(e.clientX, e.clientY);
        
        STATE.activePointerId = e.pointerId;
        STATE.pointerStart = { x: e.clientX, y: e.clientY };
        STATE.viewStart = { ...STATE.view };

        // 1. Resize Handle
        if (target.classList.contains('resize-handle')) {
            e.preventDefault();
            target.setPointerCapture(e.pointerId);
            STATE.interactionType = 'resize';
            const classes = target.getAttribute('class');
            if(classes.includes('cursor-nw')) STATE.resizeDir = 'nw';
            if(classes.includes('cursor-ne')) STATE.resizeDir = 'ne';
            if(classes.includes('cursor-sw')) STATE.resizeDir = 'sw';
            if(classes.includes('cursor-se')) STATE.resizeDir = 'se';
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            STATE.elemStart = { x: data.x, y: data.y, w: data.width, h: data.height };
            if (STATE.resizeDir === 'nw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y + data.height };
            if (STATE.resizeDir === 'ne') STATE.resizeAnchor = { x: data.x, y: data.y + data.height };
            if (STATE.resizeDir === 'sw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y };
            if (STATE.resizeDir === 'se') STATE.resizeAnchor = { x: data.x, y: data.y };
            return;
        }

        // 2. Element Hit (Drag)
        let hitElementId = null;
        if (target.classList.contains('hit-rect')) {
            hitElementId = target.parentNode.id;
        }

        if (STATE.mode === 'select') {
            if (hitElementId) {
                e.preventDefault();
                target.setPointerCapture(e.pointerId);
                STATE.selectedId = hitElementId;
                STATE.interactionType = 'drag';
                const data = STATE.elements.find(el => el.id === hitElementId);
                STATE.elemStart = { x: data.x, y: data.y };
                renderUi(); 
            } else {
                STATE.interactionType = 'pan';
                STATE.selectedId = null; 
                renderUi();
                viewport.setPointerCapture(e.pointerId); 
            }
        } else {
            // 3. Create
            e.preventDefault();
            viewport.setPointerCapture(e.pointerId);
            STATE.interactionType = 'create';
            STATE.elemStart = { x: pt.x, y: pt.y };
            if(STATE.mode === 'text' && STATE.grid.computed.charSizeW > 0) {
                STATE.elemStart.x = snapX(pt.x, false); 
                STATE.elemStart.y = snapY(pt.y, true); 
            }
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.id = 'creation-preview';
            rect.setAttribute('x', STATE.elemStart.x);
            rect.setAttribute('y', STATE.elemStart.y);
            rect.setAttribute('width', 0);
            rect.setAttribute('height', 0);
            rect.setAttribute('class', 'creation-preview-rect');
            layerUi.appendChild(rect);
        }
    }

    function onPointerMove(e) {
        if (e.pointerId !== STATE.activePointerId) return;
        const pt = getSvgPoint(e.clientX, e.clientY);
        
        if (STATE.interactionType === 'pan') {
            const dx = e.clientX - STATE.pointerStart.x;
            const dy = e.clientY - STATE.pointerStart.y;
            STATE.view.x = STATE.viewStart.x + dx;
            STATE.view.y = STATE.viewStart.y + dy;
            updateTransform();
        } else if (STATE.interactionType === 'drag') {
            const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
            const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data) {
                let newX = STATE.elemStart.x + dx;
                let newY = STATE.elemStart.y + dy;
                if (data.type === 'text' && STATE.grid.computed.charSizeW > 0) {
                     newX = snapX(newX + data.width, false) - data.width;
                     newY = snapY(newY, true);
                }
                data.x = newX; data.y = newY;
                updateElementTransform(data);
                updateUiPositions(data);
            }
        } else if (STATE.interactionType === 'resize') {
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if(data) {
                const anchor = STATE.resizeAnchor;
                let targetX = pt.x;
                let targetY = pt.y;
                if (data.type === 'text' && STATE.grid.computed.charSizeW > 0) {
                    if(STATE.resizeDir.includes('w')) targetX = snapX(targetX, true);
                    if(STATE.resizeDir.includes('e')) targetX = snapX(targetX, false);
                    if(STATE.resizeDir.includes('n')) targetY = snapY(targetY, true);
                    if(STATE.resizeDir.includes('s')) targetY = snapY(targetY, false);
                }
                let newW = Math.abs(targetX - anchor.x);
                let newH = Math.abs(targetY - anchor.y);
                let newX = Math.min(targetX, anchor.x);
                let newY = Math.min(targetY, anchor.y);
                if(newW < 10) newW = 10; if(newH < 10) newH = 10;
                data.x = newX; data.y = newY; data.width = newW; data.height = newH;
                updateElementTransform(data);
                updateUiPositions(data);
            }
        } else if (STATE.interactionType === 'create') {
            const preview = document.getElementById('creation-preview');
            if(preview) {
                let currentX = pt.x;
                let currentY = pt.y;
                if(STATE.mode === 'text' && STATE.grid.computed.charSizeW > 0) {
                    currentX = snapX(currentX, true); 
                    currentY = snapY(currentY, false); 
                }
                const w = Math.abs(currentX - STATE.elemStart.x);
                const h = Math.abs(currentY - STATE.elemStart.y);
                const x = Math.min(currentX, STATE.elemStart.x);
                const y = Math.min(currentY, STATE.elemStart.y);
                preview.setAttribute('x', x); preview.setAttribute('y', y);
                preview.setAttribute('width', w); preview.setAttribute('height', h);
            }
        }
    }

    function onPointerUp(e) {
        if (e.pointerId !== STATE.activePointerId) return;
        
        if (STATE.interactionType === 'drag' || STATE.interactionType === 'resize') {
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data) {
                renderElement(data); 
                renderUi();
            }
        } else if (STATE.interactionType === 'create') {
            const preview = document.getElementById('creation-preview');
            if(preview) {
                const w = parseFloat(preview.getAttribute('width'));
                const h = parseFloat(preview.getAttribute('height'));
                const x = parseFloat(preview.getAttribute('x'));
                const y = parseFloat(preview.getAttribute('y'));
                if (w > 10 && h > 10) {
                    createObjectFromRect({x, y, w, h});
                }
                preview.remove();
            }
        }
        STATE.activePointerId = null;
        STATE.interactionType = null;
        try { e.target.releasePointerCapture(e.pointerId); } catch(err){}
    }

    // --- Touch (Pinch Zoom) ---
    function onTouchStart(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            STATE.activePointerId = null; 
            STATE.interactionType = null;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            STATE.touchStartDist = Math.sqrt(dx * dx + dy * dy);
            const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            STATE.viewStart = { ...STATE.view };
            const rect = viewport.getBoundingClientRect();
            const vx = cx - rect.left; const vy = cy - rect.top;
            STATE.pinchStartCanvas = { x: (vx - STATE.viewStart.x) / STATE.viewStart.scale, y: (vy - STATE.viewStart.y) / STATE.viewStart.scale };
        }
    }
    function onTouchMove(e) {
        if (e.touches.length === 2 && STATE.touchStartDist > 0) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const currentDist = Math.sqrt(dx * dx + dy * dy);
            const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            const zoomFactor = currentDist / STATE.touchStartDist;
            let newScale = STATE.viewStart.scale * zoomFactor;
            newScale = Math.max(0.1, Math.min(newScale, 10.0));
            const rect = viewport.getBoundingClientRect();
            const vx = cx - rect.left; const vy = cy - rect.top;
            const newX = vx - (STATE.pinchStartCanvas.x * newScale);
            const newY = vy - (STATE.pinchStartCanvas.y * newScale);
            STATE.view.scale = newScale; STATE.view.x = newX; STATE.view.y = newY;
            updateTransform();
        }
    }
    function onTouchEnd(e) { if (e.touches.length < 2) STATE.touchStartDist = 0; }
    function onWheel(e) {
        e.preventDefault();
        if (e.altKey || e.ctrlKey) {
            const zoomFactor = 0.05;
            const delta = -Math.sign(e.deltaY);
            let newScale = STATE.view.scale * (1 + delta * zoomFactor);
            newScale = Math.max(0.1, Math.min(newScale, 10.0));
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            const newX = mouseX - (mouseX - STATE.view.x) * (newScale / STATE.view.scale);
            const newY = mouseY - (mouseY - STATE.view.y) * (newScale / STATE.view.scale);
            STATE.view.scale = newScale; STATE.view.x = newX; STATE.view.y = newY;
        } else { STATE.view.x -= e.deltaX; STATE.view.y -= e.deltaY; }
        updateTransform();
    }

    // --- Core Logic ---
    function setMode(mode) {
        STATE.mode = mode;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if(mode === 'select') document.getElementById('btn-select').classList.add('active');
        if(mode === 'text') document.getElementById('btn-text').classList.add('active');
        if(mode === 'rect') document.getElementById('btn-rect').classList.add('active');
        viewport.className = 'viewport';
        if(mode === 'text' || mode === 'rect') viewport.classList.add('mode-create');
        if(mode !== 'select') { STATE.selectedId = null; renderUi(); }
    }

    function createObjectFromRect(rect) {
        const id = createID();
        const cGrid = STATE.grid.computed;
        const initFontSize = cGrid.charSizeW > 0 ? cGrid.charSizeW : 24;
        const initLineHeight = cGrid.charSizeW > 0 ? (cGrid.lineGap / cGrid.charSizeW) + 1 : 1.5;
        let data;
        if (STATE.mode === 'text') {
            data = {
                id: id, type: 'text',
                x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                text: "Êñ∞Ë¶èË®ò‰∫ã",
                fontSize: initFontSize,
                lineHeight: initLineHeight,
                writingMode: 'vertical-rl',
                fontFamily: '"BIZ UDMincho", serif',
                charScale: 85,
                showGrid: false
            };
        } else {
            data = {
                id: id, type: 'rect',
                x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                fill: 'none', stroke: STATE.canvas.colors.ink
            };
        }
        STATE.elements.push(data);
        renderElement(data);
        setMode('select');
        selectElement(id);
    }
    
    function updateElementTransform(data) {
        const group = document.getElementById(data.id);
        if(!group) return;
        const scaleVal = (data.charScale || 85) / 100;
        let trans = `translate(${data.x}, ${data.y})`;
        if (data.type === 'text' && data.writingMode === 'vertical-rl') trans += ` scale(1, ${scaleVal})`;
        group.setAttribute('transform', trans);
        const hitRect = group.querySelector('.hit-rect');
        if (hitRect) {
            let effW = data.width; let effH = data.height;
            if (data.type === 'text' && data.writingMode === 'vertical-rl') effH = data.height / scaleVal;
            hitRect.setAttribute('width', effW); hitRect.setAttribute('height', effH);
        }
    }

    function renderElement(data) {
        let group = document.getElementById(data.id);
        if (!group) {
            group = document.createElementNS(SVG_NS, 'g');
            group.id = data.id;
            layerContent.appendChild(group);
        }
        const scaleVal = (data.charScale || 85) / 100;
        let trans = `translate(${data.x}, ${data.y})`;
        if (data.type === 'text') {
             if (data.writingMode === 'vertical-rl') trans += ` scale(1, ${scaleVal})`;
             else trans += ` scale(${scaleVal}, 1)`;
        }
        group.setAttribute('transform', trans);
        group.innerHTML = '';
        
        let effW = data.width; let effH = data.height;
        if (data.type === 'text' && data.writingMode === 'vertical-rl') effH = data.height / scaleVal;

        // Hit Rect (Transparent white for capture)
        const hitRect = document.createElementNS(SVG_NS, 'rect');
        hitRect.setAttribute('class', 'hit-rect');
        hitRect.setAttribute('x', 0); hitRect.setAttribute('y', 0);
        hitRect.setAttribute('width', effW); hitRect.setAttribute('height', effH);
        group.appendChild(hitRect);

        if (data.type === 'text') {
            const cGrid = STATE.grid.computed;
            let drawFontSize = data.fontSize;
            let drawPitchX = data.fontSize * data.lineHeight;
            if (cGrid.charSizeW > 0) { drawFontSize = cGrid.charSizeW; drawPitchX = cGrid.pitchX; }
            
            const textEl = document.createElementNS(SVG_NS, 'text');
            textEl.setAttribute('font-family', data.fontFamily);
            textEl.setAttribute('font-size', drawFontSize);
            textEl.setAttribute('writing-mode', data.writingMode);
            textEl.setAttribute('dominant-baseline', 'central'); 
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('class', 'ink-fill'); 
            textEl.style.fontFamily = data.fontFamily;
            textEl.style.pointerEvents = 'none'; 
            
            const lines = data.text.split('\n');
            lines.forEach((lineText, i) => {
                const chars = lineText.split('');
                chars.forEach((char, j) => {
                    const tspan = document.createElementNS(SVG_NS, 'tspan');
                    tspan.textContent = char;
                    const centerX = effW - (drawFontSize / 2) - (i * drawPitchX);
                    const centerY = (j * drawFontSize) + (drawFontSize / 2);
                    tspan.setAttribute('x', centerX); tspan.setAttribute('y', centerY);
                    textEl.appendChild(tspan);
                });
            });
            group.appendChild(textEl);
             if (data.showGrid) {
                const gridGroup = document.createElementNS(SVG_NS, 'g');
                gridGroup.style.pointerEvents = 'none';
                // Grid logic same as before...
                group.prepend(gridGroup);
            }
        } else {
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('width', data.width); 
            rect.setAttribute('height', data.height);
            rect.setAttribute('fill', data.fill); 
            rect.setAttribute('stroke', STATE.canvas.colors.ink); 
            rect.setAttribute('class', 'ink-stroke');
            rect.style.pointerEvents = 'none';
            group.appendChild(rect);
        }
    }

    function renderUi() {
        renderMarginGuide();
        const handles = layerUi.querySelectorAll('.selection-rect, .resize-handle');
        handles.forEach(el => el.remove());

        if (!STATE.selectedId) {
            document.getElementById('prop-panel-none').style.display = 'block';
            document.getElementById('prop-panel-text').style.display = 'none';
            return;
        }

        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if (!data) return;

        document.getElementById('prop-panel-none').style.display = 'none';
        if (data.type === 'text') {
            document.getElementById('prop-panel-text').style.display = 'block';
            if (document.activeElement.id !== 'inp-text') document.getElementById('inp-text').value = data.text;
            const cGrid = STATE.grid.computed;
            if(cGrid.charSizeW > 0) {
                document.getElementById('inp-fontsize').value = Math.round(cGrid.charSizeW);
                document.getElementById('inp-lineheight').value = (cGrid.pitchX / cGrid.charSizeW).toFixed(2);
            }
        }
        
        if (STATE.interactionType === 'resize' || STATE.interactionType === 'drag') {
            updateUiPositions(data);
            return;
        }

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.id = 'ui-selection-rect';
        rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
        rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
        rect.setAttribute('class', 'selection-rect');
        layerUi.appendChild(rect);
        createHandle(data.x, data.y, 'nw');
        createHandle(data.x + data.width, data.y, 'ne');
        createHandle(data.x, data.y + data.height, 'sw');
        createHandle(data.x + data.width, data.y + data.height, 'se');
    }
    
    function updateUiPositions(data) {
        const rect = document.getElementById('ui-selection-rect');
        if(rect) {
            rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
            rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
        }
        const setPos = (sel, x, y) => {
            const el = layerUi.querySelector(sel);
            if(el) { el.setAttribute('cx', x); el.setAttribute('cy', y); }
        };
        setPos('.cursor-nw', data.x, data.y);
        setPos('.cursor-ne', data.x + data.width, data.y);
        setPos('.cursor-sw', data.x, data.y + data.height);
        setPos('.cursor-se', data.x + data.width, data.y + data.height);
    }

    function createHandle(x, y, dir) {
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', x); circle.setAttribute('cy', y);
        circle.setAttribute('r', 15); 
        circle.setAttribute('class', `resize-handle cursor-${dir}`);
        layerUi.appendChild(circle);
    }

    // --- Helpers (Snap, Grid, etc. same as before) ---
    function snapX(rawX, isLeftEdge) {
        const cGrid = STATE.grid.computed;
        if (cGrid.charSizeW <= 0) return rawX;
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        const w_px = STATE.canvas.width * PX_PER_MM;
        const rightEdge = w_px - mr;
        const pitchX = cGrid.pitchX;
        if (isLeftEdge) {
            const col = Math.round((rightEdge - cGrid.charSizeW - rawX) / pitchX);
            return rightEdge - (col * pitchX) - cGrid.charSizeW;
        } else {
            const col = Math.round((rightEdge - rawX) / pitchX);
            return rightEdge - (col * pitchX);
        }
    }
    function snapY(rawY, isTopEdge) {
        const cGrid = STATE.grid.computed;
        if (cGrid.charSizeH <= 0) return rawY;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const relY = rawY - mt;
        const danIndex = Math.floor(relY / cGrid.danPitch);
        const danStart = mt + (danIndex * cGrid.danPitch);
        const relYInDan = rawY - danStart;
        const charIndex = Math.round(relYInDan / cGrid.charSizeH);
        return danStart + (charIndex * cGrid.charSizeH);
    }
    
    function getSvgPoint(clientX, clientY) {
        const vpRect = viewport.getBoundingClientRect();
        const vx = clientX - vpRect.left - STATE.view.x;
        const vy = clientY - vpRect.top - STATE.view.y;
        return { x: vx / STATE.view.scale, y: vy / STATE.view.scale };
    }
    
    // --- Other helpers ---
    function updateSelectedText() {
        if (!STATE.selectedId) return;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        data.text = document.getElementById('inp-text').value;
        renderElement(data);
    }
    function updateSelectedStyle() {
        if (!STATE.selectedId) return;
        const data = STATE.elements.find(el => el.id === STATE.selectedId);
        data.fontFamily = document.getElementById('inp-fontfamily').value;
        data.showGrid = document.getElementById('inp-showgrid').checked;
        renderElement(data); renderUi();
    }
    function createID() { return 'el_' + Math.random().toString(36).substr(2, 9); }
    function selectElement(id) { STATE.selectedId = id; renderUi(); }
    function deleteSelected() { if (!STATE.selectedId) return; document.getElementById(STATE.selectedId).remove(); STATE.elements = STATE.elements.filter(e => e.id !== STATE.selectedId); STATE.selectedId = null; renderUi(); }
    function fitView() {
        const vw = viewport.clientWidth; const vh = viewport.clientHeight;
        const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
        const margin = 40;
        const scale = Math.min((vw - margin*2) / w_px, (vh - margin*2) / h_px);
        STATE.view.scale = Math.max(0.1, Math.min(scale, 5.0));
        STATE.view.x = (vw - w_px * STATE.view.scale) / 2; STATE.view.y = (vh - h_px * STATE.view.scale) / 2;
        updateTransform();
    }
    function updateTransform() { canvasContainer.style.transform = `translate(${STATE.view.x}px, ${STATE.view.y}px) scale(${STATE.view.scale})`; }
    function updateCanvasSize() {
        const w = parseFloat(document.getElementById('inp-canvas-w').value);
        const h = parseFloat(document.getElementById('inp-canvas-h').value);
        STATE.canvas.width = w; STATE.canvas.height = h;
        mainSvg.setAttribute('width', w * PX_PER_MM); mainSvg.setAttribute('height', h * PX_PER_MM);
        mainSvg.setAttribute('viewBox', `0 0 ${w * PX_PER_MM} ${h * PX_PER_MM}`);
        updateMargins();
    }
    function updateMargins() {
        STATE.canvas.margin.top = parseFloat(document.getElementById('inp-margin-t').value);
        STATE.canvas.margin.bottom = parseFloat(document.getElementById('inp-margin-b').value);
        STATE.canvas.margin.left = parseFloat(document.getElementById('inp-margin-l').value);
        STATE.canvas.margin.right = parseFloat(document.getElementById('inp-margin-r').value);
        renderMarginGuide(); updateGridSettings();
    }
    function updateGridSettings() { 
        STATE.grid.show = document.getElementById('inp-layout-show').checked;
        STATE.grid.dan = parseInt(document.getElementById('inp-layout-dan').value);
        STATE.grid.charsPerDan = parseInt(document.getElementById('inp-layout-chars').value);
        STATE.grid.totalLines = parseInt(document.getElementById('inp-layout-lines').value);
        renderPaperGrid(); syncAllTextElements();
    }
    function renderMarginGuide() {
        const old = document.getElementById('margin-guide-rect'); if(old) old.remove();
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const ml = STATE.canvas.margin.left * PX_PER_MM;
        const w = STATE.canvas.width * PX_PER_MM;
        const h = STATE.canvas.height * PX_PER_MM;
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.id = 'margin-guide-rect';
        rect.setAttribute('x', ml); rect.setAttribute('y', mt);
        rect.setAttribute('width', w - ml - STATE.canvas.margin.right*PX_PER_MM);
        rect.setAttribute('height', h - mt - STATE.canvas.margin.bottom*PX_PER_MM);
        rect.setAttribute('class', 'margin-guide');
        layerUi.appendChild(rect);
    }
    function renderPaperGrid() {
        layerPaperGrid.innerHTML = '';
        if(!STATE.grid.show) return;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
        const validH = h_px - mt - STATE.canvas.margin.bottom * PX_PER_MM;
        const validW = w_px - STATE.canvas.margin.left * PX_PER_MM - STATE.canvas.margin.right * PX_PER_MM;
        
        const totalHUnits = (STATE.grid.charsPerDan * STATE.grid.dan) + (STATE.grid.dan - 1);
        const unitH = validH / totalHUnits;
        const danPitch = (STATE.grid.charsPerDan * unitH) + unitH;
        
        const fontSizeW = unitH / CHAR_SCALE_RATIO;
        const totalCharW = fontSizeW * STATE.grid.totalLines;
        let lineGap = 0; if(STATE.grid.totalLines > 1) lineGap = (validW - totalCharW) / (STATE.grid.totalLines - 1);
        
        STATE.grid.computed = { charSizeW: fontSizeW, charSizeH: unitH, lineGap, danHeight: unitH * STATE.grid.charsPerDan, danPitch, pitchX: fontSizeW + lineGap };
        document.getElementById('grid-info').innerHTML = `ÊñáÂ≠ó„Çµ„Ç§„Ç∫: ${(fontSizeW / PX_PER_MM).toFixed(2)}mm`;

        const mr = STATE.canvas.margin.right * PX_PER_MM;
        for(let l=0; l<STATE.grid.totalLines; l++) {
            const lineX = (w_px - mr) - fontSizeW - (l * STATE.grid.computed.pitchX);
            for(let d=0; d<STATE.grid.dan; d++) {
                const startY = mt + (d * danPitch);
                for(let c=0; c<STATE.grid.charsPerDan; c++) {
                    const rect = document.createElementNS(SVG_NS, 'rect');
                    rect.setAttribute('x', lineX); rect.setAttribute('y', startY + (c * unitH));
                    rect.setAttribute('width', fontSizeW); rect.setAttribute('height', unitH);
                    rect.setAttribute('class', 'grid-rect');
                    layerPaperGrid.appendChild(rect);
                }
            }
        }
    }
    function updateColors() { 
        const paperC = document.getElementById('inp-paper-color').value;
        const inkC = document.getElementById('inp-ink-color').value;
        STATE.canvas.colors.paper = paperC; STATE.canvas.colors.ink = inkC;
        paperBg.setAttribute('fill', paperC);
        // Force SVG text content update logic in export (no live CSS var here for export safety)
    }
    
    // Export (re-added)
    async function urlToBase64(url) {
        try { const res = await fetch(url); const blob = await res.blob();
            return new Promise(r => { const reader = new FileReader(); reader.onloadend = () => r(reader.result); reader.readAsDataURL(blob); });
        } catch { return null; }
    }
    async function getEmbeddableFontCss(cssUrl) {
        try { const res = await fetch(cssUrl); let cssText = await res.text();
            const urlRegex = /url\((['"]?)(https:\/\/[^'"\)]+)\1\)/g; let match; const replacements = [];
            while ((match = urlRegex.exec(cssText)) !== null) replacements.push({ original: match[0], url: match[2] });
            const uniqueUrls = [...new Set(replacements.map(r => r.url))];
            const base64Map = {};
            await Promise.all(uniqueUrls.map(async (url) => { const b64 = await urlToBase64(url); if(b64) base64Map[url] = b64; }));
            for (const rep of replacements) if (base64Map[rep.url]) cssText = cssText.split(rep.original).join(`url("${base64Map[rep.url]}")`);
            return cssText;
        } catch { return ''; }
    }
    async function exportCanvas() {
        const btn = document.getElementById('btn-export');
        const originalText = btn.textContent;
        btn.textContent = "ÁîüÊàê‰∏≠..."; btn.disabled = true;
        
        // Hide UI layers and hit-rects
        layerUi.style.display = 'none'; layerPaperGrid.style.display = 'none';
        const hitStyle = document.createElementNS(SVG_NS, 'style');
        hitStyle.textContent = '.hit-rect { display: none; }';
        mainSvg.prepend(hitStyle);

        try {
            const currentW = parseFloat(mainSvg.getAttribute('width'));
            const currentH = parseFloat(mainSvg.getAttribute('height'));
            const svgClone = mainSvg.cloneNode(true);
            const fontCssUrl = 'https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block';
            const embeddedCss = await getEmbeddableFontCss(fontCssUrl);
            
            // Reconstruct CSS for export based on STATE
            const inkC = STATE.canvas.colors.ink;
            const dynamicCss = `.ink-fill { fill: ${inkC}; } .ink-stroke { stroke: ${inkC}; } text { fill: ${inkC}; }`;
            
            const styleEl = document.createElementNS(SVG_NS, 'style');
            styleEl.textContent = embeddedCss + '\n' + dynamicCss;
            let defs = svgClone.querySelector('defs');
            if(!defs) { defs = document.createElementNS(SVG_NS, 'defs'); svgClone.prepend(defs); }
            defs.appendChild(styleEl);
            
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const scale = 4;
                canvas.width = currentW * scale; canvas.height = currentH * scale;
                const ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = 'newspaper.png';
                a.click();
                URL.revokeObjectURL(url);
                hitStyle.remove();
                layerUi.style.display = 'block'; layerPaperGrid.style.display = 'block';
                btn.textContent = originalText; btn.disabled = false;
            };
            img.src = url;
        } catch(e) {
            console.error(e);
            hitStyle.remove();
            layerUi.style.display = 'block'; layerPaperGrid.style.display = 'block';
            btn.textContent = originalText; btn.disabled = false;
        }
    }
    function setCanvasPreset(w, h) { document.getElementById('inp-canvas-w').value = w; document.getElementById('inp-canvas-h').value = h; updateCanvasSize(); fitView(); }
    function swapCanvasSize() { const w = document.getElementById('inp-canvas-w'); const h = document.getElementById('inp-canvas-h'); [w.value, h.value] = [h.value, w.value]; updateCanvasSize(); }

    window.addEventListener('load', () => { updateCanvasSize(); updateGridSettings(); updateColors(); fitView(); });

</script>
</body>
</html>


