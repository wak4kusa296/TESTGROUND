
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SVG Newspaper Tool</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block" rel="stylesheet">

<style>
    :root {
        --ui-bg: #f5f5f5;
        --panel-bg: #ffffff;
        --border-col: #ddd;
        --primary: #2196f3;
        --accent: #ff9800;
        --masthead: #d32f2f; /* é¡Œå­—ç”¨ã‚«ãƒ©ãƒ¼ */
        --link-col: #9c27b0;
        --text: #333;
    }
    body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
        font-family: "Noto Sans JP", sans-serif;
        background: var(--ui-bg);
        color: var(--text);
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
    }

    /* å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
    .toolbar {
        width: 60px;
        background: var(--panel-bg);
        border-right: 1px solid var(--border-col);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
        z-index: 100;
    }
    .tool-btn {
        width: 40px; height: 40px;
        margin-bottom: 10px;
        border: 1px solid var(--border-col);
        background: #fff;
        cursor: pointer;
        border-radius: 4px;
        display: flex; justify-content: center; align-items: center;
        font-size: 20px;
        transition: 0.2s;
        position: relative;
    }
    .tool-btn:hover { background: #eee; }
    .tool-btn.active { background: var(--primary); color: #fff; border-color: var(--primary); }
    .tool-btn.active.btn-heading { background: var(--accent); border-color: var(--accent); }
    .tool-btn.active.btn-masthead { background: var(--masthead); border-color: var(--masthead); }

    .tool-label { font-size: 10px; position: absolute; bottom: 1px; line-height: 1; }

    /* ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ */
    .viewport {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #e0e0e0;
        background-image: radial-gradient(#ccc 1px, transparent 1px);
        background-size: 20px 20px;
        cursor: default;
        touch-action: none;
    }
    .viewport.mode-create { cursor: crosshair; }

    /* SVGç”¨ç´™ã‚³ãƒ³ãƒ†ãƒŠ */
    #canvas-container {
        transform-origin: 0 0;
        position: absolute;
        top: 0; left: 0;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }

    /* SVGç”¨ç´™ */
    #main-svg {
        background: transparent;
        display: block; 
        shape-rendering: geometricPrecision;
        text-rendering: geometricPrecision;
        overflow: visible;
    }

    /* å³ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
    .properties {
        width: 280px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border-col);
        padding: 15px;
        box-sizing: border-box;
        overflow-y: auto;
        z-index: 100;
    }
    .prop-group { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
    .prop-group:last-child { border-bottom: none; }
    .prop-label { font-size: 12px; font-weight: bold; margin-bottom: 5px; display: block; color: #555; }
    .prop-row { display: flex; gap: 5px; margin-bottom: 8px; align-items: center; }
    
    .prop-input, .prop-select, .prop-textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 6px;
        border: 1px solid var(--border-col);
        margin-bottom: 8px;
        font-size: 14px;
        font-family: inherit;
    }
    .prop-textarea { resize: vertical; min-height: 100px; }
    
    /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ */
    input[type=range] {
        -webkit-appearance: none; background: transparent; margin: 0; vertical-align: middle; cursor: pointer;
    }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
        background: var(--primary); cursor: pointer; margin-top: -6px;
        border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 4px; background: #e0e0e0; border-radius: 2px;
    }
    .heading-slider::-webkit-slider-thumb { background: var(--accent); }
    .masthead-slider::-webkit-slider-thumb { background: var(--masthead); }

    .btn-primary {
        width: 100%; padding: 8px; background: var(--primary); color: white;
        border: none; border-radius: 4px; cursor: pointer;
    }
    .btn-primary:hover { opacity: 0.9; }
    .btn-delete { background: #e53935; margin-top:20px; }

    .btn-secondary {
        flex: 1; padding: 6px; background: #f0f0f0; color: #333;
        border: 1px solid var(--border-col); border-radius: 4px; cursor: pointer;
        font-size: 12px; text-align: center;
    }
    .btn-secondary:hover { background: #e0e0e0; }

    /* UIã‚¹ã‚¿ã‚¤ãƒ« */
    .selection-rect {
        fill: none; stroke: var(--primary); stroke-width: 2px; stroke-dasharray: 4 2;
        pointer-events: none; vector-effect: non-scaling-stroke;
    }
    .selection-rect.heading-select { stroke: var(--accent); }
    .selection-rect.masthead-select { stroke: var(--masthead); }
    
    .creation-preview-rect {
        fill: rgba(33, 150, 243, 0.2); stroke: var(--primary); stroke-width: 1px; stroke-dasharray: 4 2;
        pointer-events: none; vector-effect: non-scaling-stroke;
    }

    /* ãƒãƒ³ãƒ‰ãƒ« */
    .handle-group { cursor: pointer; }
    .resize-handle-visual {
        fill: white; stroke: var(--primary); stroke-width: 2px; vector-effect: non-scaling-stroke; pointer-events: none; 
    }
    .resize-handle-hit {
        fill: #ffffff; fill-opacity: 0; cursor: pointer; pointer-events: all;
    }
    .handle-group:hover .resize-handle-visual { fill: var(--primary); }
    .handle-group.heading-handle .resize-handle-visual { stroke: var(--accent); }
    .handle-group.heading-handle:hover .resize-handle-visual { fill: var(--accent); }
    .handle-group.masthead-handle .resize-handle-visual { stroke: var(--masthead); }
    .handle-group.masthead-handle:hover .resize-handle-visual { fill: var(--masthead); }

    /* ãƒªãƒ³ã‚¯ãƒãƒ³ãƒ‰ãƒ« (å››è§’) */
    .link-handle-rect {
        fill: #fff; stroke: var(--link-col); stroke-width: 2px; cursor: pointer; vector-effect: non-scaling-stroke;
    }
    .link-handle-rect.connected { fill: var(--link-col); }
    .link-handle-hit { fill: transparent; cursor: pointer; pointer-events: all; }
    
    .link-line-preview {
        stroke: var(--link-col); stroke-width: 2px; stroke-dasharray: 4 2; fill: none; pointer-events: none;
    }

    .cursor-nw { cursor: nw-resize; }
    .cursor-ne { cursor: ne-resize; }
    .cursor-sw { cursor: sw-resize; }
    .cursor-se { cursor: se-resize; }

    .margin-guide {
        fill: none; stroke: #00bcd4; stroke-width: 1px; stroke-dasharray: 5 5; pointer-events: none; vector-effect: non-scaling-stroke;
    }
    
    /* ãƒãƒ³ãƒ‰ãƒ„ãƒ¼ãƒ«æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ« */
    .viewport.mode-select { cursor: grab; }
    .viewport.mode-select:active { cursor: grabbing; }

    text { user-select: none; pointer-events: none; }
    .grid-line, .grid-rect { stroke: #b3e5fc; stroke-width: 0.5px; fill: none; pointer-events: none; vector-effect: non-scaling-stroke; }
    .hit-rect { fill: #ffffff; fill-opacity: 0; cursor: move; pointer-events: all; }
    
    /* è‰²åˆ¶å¾¡ç”¨ã‚¯ãƒ©ã‚¹ */
    .ink-fill { fill: #333; }
    .ink-stroke { stroke: #333; }
    .paper-fill { fill: #fff; }
    .paper-stroke { stroke: #fff; }

    /* ãƒªãƒ³ã‚¯æ¥ç¶šå€™è£œï¼ˆãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã«æ ç·šã ã‘è¡¨ç¤ºï¼‰ */
    .link-candidate .hit-rect {
        stroke: var(--link-col);
        stroke-width: 2px;
        stroke-dasharray: 4 4;
        fill: none; /* å¡—ã‚Šã¤ã¶ã—ãªã— */
    }

    /* ãƒªãƒ³ã‚¯æ¥ç¶šå¯¾è±¡ï¼ˆãƒ›ãƒãƒ¼æ™‚ãƒ»å¼·èª¿ï¼‰ */
    .highlight-target .hit-rect {
        stroke: var(--link-col);
        stroke-width: 3px;
        stroke-dasharray: 4 4;
        fill: rgba(156, 39, 176, 0.2) !important;
        fill-opacity: 1 !important;
    }
</style>
</head>
<body>

<div class="toolbar">
    <!-- ã‚¢ã‚¤ã‚³ãƒ³ã‚’ã€Œæ‰‹ã€ã«å¤‰æ›´ -->
    <button class="tool-btn active" id="btn-select" title="ç§»å‹• (H)" onclick="setMode('select')">âœ‹</button>
    <button class="tool-btn" id="btn-text" title="è¨˜äº‹ (T)" onclick="setMode('text')">T<span class="tool-label">è¨˜äº‹</span></button>
    <button class="tool-btn" id="btn-freetext" title="è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ (F)" onclick="setMode('freetext')">A<span class="tool-label">è‡ªç”±</span></button>
    <button class="tool-btn btn-heading" id="btn-heading" title="è¦‹å‡ºã— (H)" onclick="setMode('heading')">H<span class="tool-label" style="font-weight:bold;">è¦‹å‡º</span></button>
    <button class="tool-btn btn-masthead" id="btn-masthead" title="é¡Œå­— (M)" onclick="setMode('masthead')">é¡Œ<span class="tool-label">é¡Œå­—</span></button>
    <button class="tool-btn" id="btn-rect" title="å¡—ã‚Šã¤ã¶ã— (R)" onclick="setMode('rect')">â– <span class="tool-label">å¡—æ½°</span></button>
    <button class="tool-btn" id="btn-image" title="ç”»åƒ (I)" onclick="setMode('image')">ğŸ–¼<span class="tool-label">ç”»åƒ</span></button>
    <div style="flex:1"></div>
    <button class="tool-btn" onclick="fitView()" title="å…¨ä½“è¡¨ç¤º">ğŸ”</button>
</div>

<div class="viewport" id="viewport">
    <div id="canvas-container">
        <svg id="main-svg" width="297" height="420" viewBox="0 0 297 420" xmlns="http://www.w3.org/2000/svg" overflow="visible">
            <defs>
                <style id="svg-style">
                    .hit-rect { fill: #ffffff; fill-opacity: 0; pointer-events: all; }
                    .ink-fill { fill: #333333; } .ink-stroke { stroke: #333333; }
                    .paper-fill { fill: #ffffff; } .paper-stroke { stroke: #ffffff; }
                    text { fill: #333333; }
                </style>
            </defs>
            <rect id="paper-bg" class="paper-fill" x="0" y="0" width="100%" height="100%"></rect>

            <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åº: æ®µé–“ç½«ç·š < ã‚°ãƒªãƒƒãƒ‰ < ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ < UI < æ ç·š -->
            <g id="layer-dan-lines"></g>
            <g id="layer-paper-grid"></g>
            <g id="layer-content"></g>
            <g id="layer-ui"></g>
            <g id="layer-border"></g>
        </svg>
    </div>
</div>

<div class="properties">
    <!-- è¨­å®šãƒ‘ãƒãƒ«: æœªé¸æŠ -->
    <div class="prop-group" id="prop-panel-none">
        <div class="prop-label">ç”¨ç´™ã‚µã‚¤ã‚º (mm)</div>
        <div class="prop-row">
            <input type="number" id="inp-canvas-w" class="prop-input" value="297" onchange="updateCanvasSize()">
            <span>Ã—</span>
            <input type="number" id="inp-canvas-h" class="prop-input" value="420" onchange="updateCanvasSize()">
        </div>
        <div class="prop-row">
            <button class="btn-secondary" onclick="setCanvasPreset(210, 297)">A4</button>
            <button class="btn-secondary" onclick="setCanvasPreset(297, 420)">A3</button>
            <button class="btn-secondary" onclick="swapCanvasSize()">ç¸¦æ¨ªå…¥æ›¿</button>
        </div>

        <div class="prop-label" style="margin-top:15px;">ã‚«ãƒ©ãƒ¼è¨­å®š</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">ç´™ã®è‰²</span>
            <input type="color" id="inp-paper-color" value="#ffffff" onchange="updateColors()" style="height:24px;">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">ã‚¤ãƒ³ã‚¯ã®è‰²</span>
            <input type="color" id="inp-ink-color" value="#333333" onchange="updateColors()" style="height:24px;">
        </div>

        <div class="prop-label" style="margin-top:15px; color:#2196f3;">ç´™é¢å‰²ä»˜</div>
        <div style="background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #eee;">
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">ç¸¦ã®æ®µæ•°</span>
                <input type="number" id="inp-layout-dan" class="prop-input" style="flex:0.6" value="6" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">1æ®µã®æ–‡å­—æ•°</span>
                <input type="number" id="inp-layout-chars" class="prop-input" style="flex:0.6" value="11" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <span style="font-size:11px; flex:1;">å…¨ä½“ã®è¡Œæ•°</span>
                <input type="number" id="inp-layout-lines" class="prop-input" style="flex:0.6" value="25" onchange="updateGridSettings()">
            </div>
            <div class="prop-row">
                <label style="font-size:11px; display:flex; align-items:center;">
                    <input type="checkbox" id="inp-layout-show" checked onchange="updateGridSettings()" style="margin-right:5px;"> ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
                </label>
            </div>
            <div id="grid-info" style="font-size:10px; color:#666; margin-top:5px;"></div>
        </div>

        <div class="prop-label" style="margin-top:15px;">è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹è¨­å®š</div>
        <div class="prop-row">
            <label style="font-size:11px; display:flex; align-items:center; cursor:pointer;">
                <input type="checkbox" id="inp-snap-article" checked onchange="updateSnapMode()" style="margin-right:5px;"> è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰ (æ®µã‚¹ãƒŠãƒƒãƒ—)
            </label>
        </div>

        <div class="prop-label" style="margin-top:20px;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</div>
        <button class="btn-primary" id="btn-export" onclick="exportCanvas()">ç”»åƒã¨ã—ã¦æ›¸ãå‡ºã—</button>
    </div>

    <!-- è¨­å®šãƒ‘ãƒãƒ«: è¨˜äº‹ -->
    <div class="prop-group" id="prop-panel-text" style="display:none;">
        <div class="prop-label">è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹ç·¨é›†</div>
        <textarea id="inp-text" class="prop-textarea" oninput="updateSelectedText()"></textarea>

        <div id="text-char-info" style="font-size:11px; color:#666; margin-top:5px; margin-bottom:10px;">
            ç¾åœ¨: <span id="char-current">0</span>æ–‡å­— /
            æœ€å¤§: <span id="char-capacity">0</span>æ–‡å­— /
            ã‚ãµã‚Œ: <span id="char-overflow" style="color:#f44336;">0</span>æ–‡å­—
        </div>

        <div class="prop-row">
            <label style="font-size:11px; display:flex; align-items:center; cursor:pointer; width:100%;">
                <input type="checkbox" id="inp-snap-article-txt" checked onchange="updateSnapMode()" style="margin-right:5px;"> è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰ (æ®µã‚¹ãƒŠãƒƒãƒ—)
            </label>
        </div>

        <div class="prop-label">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
        <select id="inp-fontfamily" class="prop-select" onchange="updateSelectedStyle()">
            <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ æ¨™æº–)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
            <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿ ç­†æ–‡å­—)</option>
        </select>
        <div style="font-size:11px; color:#777; margin-bottom:10px;">
            è¡¨ç¤ºä¸­ã®ãƒ•ã‚©ãƒ³ãƒˆã¯ Google Fonts ã§ã®æ­£å¼åç§° (BIZ UDMincho / Yuji Syuku) ã‚’ãã®ã¾ã¾è¨˜è¼‰ã—ã¦ã„ã¾ã™ã€‚
        </div>
        
        <div id="text-link-info" style="font-size:11px; color:#9c27b0; margin-bottom:10px; display:none;">
            â€»ã“ã®ãƒœãƒƒã‚¯ã‚¹ã¯ãƒªãƒ³ã‚¯æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™ã€‚<br>æ–‡å­—ã¯å‰ã®ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰æµã—è¾¼ã¾ã‚Œã¾ã™ã€‚
        </div>

        <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>

    <!-- è¨­å®šãƒ‘ãƒãƒ«: è¦‹å‡ºã— -->
    <div class="prop-group" id="prop-panel-heading" style="display:none;">
        <div class="prop-label" style="color:var(--accent);">è¦‹å‡ºã—ç·¨é›†</div>
        <input type="text" id="inp-heading-text" class="prop-input" oninput="updateHeadingProp('text')">
        
        <div class="prop-row" style="margin-top:10px;">
            <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                <input type="checkbox" id="inp-heading-inverted" onchange="updateHeadingProp('inverted')" style="margin-right:5px;"> ç™½é»’åè»¢ (åº§å¸ƒå›£)
            </label>
        </div>

        <div class="prop-label" style="margin-top:10px;">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
        <select id="inp-heading-font" class="prop-select" onchange="updateHeadingProp('fontFamily')">
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP (ã‚´ã‚·ãƒƒã‚¯)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP (æ˜æœ)</option>
            <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ)</option>
            <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿)</option>
        </select>
        <div class="prop-label">ä½™ç™½è¨­å®š (mm)</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:0.8;">å·¦å³</span>
            <input type="range" id="inp-heading-ph-slider" class="heading-slider" min="0" max="50" step="0.5" value="5" oninput="updateHeadingProp('padding', 'h', this.value)" style="flex:2;">
            <input type="number" id="inp-heading-ph" class="prop-input" style="flex:0.8; margin-bottom:0;" value="5" onchange="updateHeadingProp('padding', 'h', this.value)">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:0.8;">å¤©åœ°</span>
            <input type="range" id="inp-heading-pv-slider" class="heading-slider" min="0" max="50" step="0.5" value="5" oninput="updateHeadingProp('padding', 'v', this.value)" style="flex:2;">
            <input type="number" id="inp-heading-pv" class="prop-input" style="flex:0.8; margin-bottom:0;" value="5" onchange="updateHeadingProp('padding', 'v', this.value)">
        </div>
        <div style="font-size:11px; color:#666; margin-top:10px;">
            â€»å·¦å³ã«è¡Œé–“åˆ†ã®ç´™è‰²ã‚·ãƒ£ãƒ‰ã‚¦ãŒã¤ãã¾ã™ã€‚<br>
            â€»æ–‡å­—ã¯å¸¸æ™‚æœ€å¤§å¤ªã•(900)ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
        </div>
        <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>

    <!-- è¨­å®šãƒ‘ãƒãƒ«: é¡Œå­— -->
    <div class="prop-group" id="prop-panel-masthead" style="display:none;">
        <div class="prop-label" style="color:var(--masthead);">é¡Œå­—ç·¨é›†</div>
        <input type="text" id="inp-masthead-text" class="prop-input" oninput="updateMastheadProp('text')">
        
        <div class="prop-row" style="margin-top:10px;">
            <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                <input type="checkbox" id="inp-masthead-inverted" onchange="updateMastheadProp('inverted')" style="margin-right:5px;"> æ–‡å­—è‰²åè»¢ (ç™½æŠœã)
            </label>
        </div>

        <div class="prop-label" style="margin-top:10px;">ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š (mm)</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">å¤–æ ã®å¤ªã•</span>
            <input type="range" id="inp-masthead-bo-slider" class="masthead-slider" min="0.5" max="5.0" step="0.1" value="1.0" oninput="updateMastheadProp('borderWidthOuter', this.value)" style="flex:1.5;">
            <input type="number" id="inp-masthead-bo" class="prop-input" style="flex:0.8;" value="1.0" onchange="updateMastheadProp('borderWidthOuter', this.value)">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">å†…æ ã®å¤ªã•</span>
            <input type="range" id="inp-masthead-bi-slider" class="masthead-slider" min="0.1" max="3.0" step="0.1" value="0.3" oninput="updateMastheadProp('borderWidthInner', this.value)" style="flex:1.5;">
            <input type="number" id="inp-masthead-bi" class="prop-input" style="flex:0.8;" value="0.3" onchange="updateMastheadProp('borderWidthInner', this.value)">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">åœ°ç´‹ç·šã®å¤ªã•</span>
            <input type="range" id="inp-masthead-pl-slider" class="masthead-slider" min="0.1" max="1.0" step="0.1" value="0.4" oninput="updateMastheadProp('patternLineHeight', this.value)" style="flex:1.5;">
            <input type="number" id="inp-masthead-pl" class="prop-input" style="flex:0.8;" value="0.4" onchange="updateMastheadProp('patternLineHeight', this.value)">
        </div>
        
        <div class="prop-row">
            <span style="font-size:11px; flex:1;">æ–‡å­—ç¸å–ã‚Š</span>
            <input type="range" id="inp-masthead-ts-slider" class="masthead-slider" min="0" max="20" step="0.5" value="4" oninput="updateMastheadProp('textStrokeWidth', this.value)" style="flex:1.5;">
            <input type="number" id="inp-masthead-ts" class="prop-input" style="flex:0.8;" value="4" onchange="updateMastheadProp('textStrokeWidth', this.value)">
        </div>

        <div class="prop-label">ä½™ç™½è¨­å®š (mm)</div>
        <div class="prop-row">
            <span style="font-size:11px; flex:0.8;">å·¦å³</span>
            <input type="range" id="inp-masthead-ph-slider" class="masthead-slider" min="0" max="50" step="0.5" value="0" oninput="updateMastheadProp('paddingH', this.value)" style="flex:2;">
            <input type="number" id="inp-masthead-ph" class="prop-input" style="flex:0.8; margin-bottom:0;" value="0" onchange="updateMastheadProp('paddingH', this.value)">
        </div>
        <div class="prop-row">
            <span style="font-size:11px; flex:0.8;">å¤©åœ°</span>
            <input type="range" id="inp-masthead-pv-slider" class="masthead-slider" min="0" max="50" step="0.5" value="0" oninput="updateMastheadProp('paddingV', this.value)" style="flex:2;">
            <input type="number" id="inp-masthead-pv" class="prop-input" style="flex:0.8; margin-bottom:0;" value="0" onchange="updateMastheadProp('paddingV', this.value)">
        </div>

        <div class="prop-label">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
        <select id="inp-masthead-font" class="prop-select" onchange="updateMastheadProp('fontFamily')">
            <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ æ¨™æº–)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP (æ˜æœ)</option>
            <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿ ç­†æ–‡å­—)</option>
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP (ã‚´ã‚·ãƒƒã‚¯)</option>
        </select>

        <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>

    <!-- è¨­å®šãƒ‘ãƒãƒ«: å¡—ã‚Šã¤ã¶ã— -->
    <div class="prop-group" id="prop-panel-rect" style="display:none;">
        <div class="prop-label">å¡—ã‚Šã¤ã¶ã—è¨­å®š</div>
        <div class="prop-row">
            <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                <input type="checkbox" id="inp-rect-ink" onchange="updateRectProp()"> ã‚¤ãƒ³ã‚¯è‰²ã§å¡—ã‚Šã¤ã¶ã™
            </label>
        </div>
        <div style="font-size:11px; color:#666; margin-bottom:10px;">
            â€»OFFã®å ´åˆã¯ç´™è‰²ã§å¡—ã‚Šã¤ã¶ã•ã‚Œã¾ã™ã€‚
        </div>
        
        <div class="prop-label">æ ç·šè¨­å®š</div>
        <select id="inp-rect-border-style" class="prop-select" onchange="updateRectProp()">
            <option value="none">ãªã—</option>
            <option value="solid">å®Ÿç·š</option>
            <option value="dotted">ç‚¹ç·š</option>
            <option value="double">äºŒé‡ç·š</option>
        </select>
        
        <div class="prop-row">
            <span style="font-size:11px; flex:0.8;">å¤ªã•(mm)</span>
            <input type="range" id="inp-rect-border-w-slider" min="0.1" max="3.0" step="0.1" value="0.5" oninput="updateRectProp('width', this.value)" style="flex:2;">
            <input type="number" id="inp-rect-border-w" class="prop-input" style="flex:0.8; margin-bottom:0;" value="0.5" onchange="updateRectProp('width', this.value)">
        </div>
        <div style="font-size:11px; color:#666; margin-top:5px;">
            â€»ã‚¤ãƒ³ã‚¯å¡—ã‚Šã¤ã¶ã—æ™‚ã¯ã€æ ç·šãŒç™½æŠœãã«ãªã‚Š1mmå†…å´ã«é…ç½®ã•ã‚Œã¾ã™ã€‚
        </div>

        <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>

    <div class="prop-group" id="prop-panel-image" style="display:none;">
        <div class="prop-label">ç”»åƒè¨­å®š</div>
        <div class="prop-row" style="flex-direction: column; gap: 8px;">
            <input type="file" id="inp-image-file" accept="image/*" onchange="loadImageFile(this)" style="font-size: 11px;">
            <div id="image-info" style="font-size:11px; color:#666;"></div>
        </div>

        <div class="prop-label" style="margin-top: 15px;">ãƒˆãƒªãƒŸãƒ³ã‚°</div>
        <button class="btn-primary" id="btn-crop-mode" onclick="toggleCropMode()" style="margin-bottom: 10px;">ãƒˆãƒªãƒŸãƒ³ã‚°èª¿æ•´</button>
        <div style="font-size:11px; color:#666; margin-bottom:10px;">
            â€»ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ç”»åƒä¸Šã§ç›´æ¥ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãƒˆãƒªãƒŸãƒ³ã‚°ã§ãã¾ã™
        </div>

        <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>

    <div class="prop-group" id="prop-panel-freetext" style="display:none;">
        <div class="prop-label">è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†</div>
        <textarea id="inp-freetext" class="prop-input" oninput="updateFreeTextProp('text')" style="min-height:80px; resize:vertical;"></textarea>

        <div class="prop-label" style="margin-top:10px;">æ–‡å­—æ–¹å‘</div>
        <div class="prop-row">
            <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                <input type="radio" name="freetext-direction" value="vertical" onchange="updateFreeTextProp('direction')" style="margin-right:5px;"> ç¸¦æ›¸ã
            </label>
            <label style="display:flex; align-items:center; font-size:12px; cursor:pointer; flex:1;">
                <input type="radio" name="freetext-direction" value="horizontal" onchange="updateFreeTextProp('direction')" style="margin-right:5px;"> æ¨ªæ›¸ã
            </label>
        </div>

        <div class="prop-label" style="margin-top:10px;">æƒãˆä½ç½®</div>
        <div class="prop-row" style="flex-wrap:wrap; gap:5px;">
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="start-start" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> å³ä¸Š
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="start-center" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> å³ä¸­
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="start-end" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> å³ä¸‹
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="center-start" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> ä¸­ä¸Š
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="center-center" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> ä¸­å¤®
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="center-end" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> ä¸­ä¸‹
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="end-start" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> å·¦ä¸Š
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="end-center" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> å·¦ä¸­
            </label>
            <label style="display:flex; align-items:center; font-size:11px; cursor:pointer;">
                <input type="radio" name="freetext-align" value="end-end" onchange="updateFreeTextProp('align')" style="margin-right:3px;"> å·¦ä¸‹
            </label>
        </div>

        <div class="prop-label" style="margin-top:10px;">ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</div>
        <select id="inp-freetext-font" class="prop-select" onchange="updateFreeTextProp('fontFamily')">
            <option value='"BIZ UDMincho", serif'>BIZ UDMincho (BIZ UDæ˜æœ æ¨™æº–)</option>
            <option value='"Noto Serif JP", serif'>Noto Serif JP</option>
            <option value='"Noto Sans JP", sans-serif'>Noto Sans JP</option>
            <option value='"Yuji Syuku", serif'>Yuji Syuku (ä½‘å­— å®¿ ç­†æ–‡å­—)</option>
        </select>

        <div class="prop-label" style="margin-top:10px;">æ–‡å­—ã‚µã‚¤ã‚º (mm)</div>
        <div class="prop-row">
            <input type="range" id="inp-freetext-size-slider" min="2" max="50" step="0.5" value="12" oninput="updateFreeTextProp('fontSize')" style="flex:2;">
            <input type="number" id="inp-freetext-size" class="prop-input" style="flex:0.8; margin-bottom:0;" value="12" onchange="updateFreeTextProp('fontSize')">
        </div>

        <button class="btn-primary btn-delete" onclick="deleteSelected()">å‰Šé™¤</button>
    </div>
</div>

<script>
    const PX_PER_MM = 2.834645;
    const CHAR_SCALE_RATIO = 0.85;

    const STATE = {
        mode: 'select',
        articleSnapMode: true,
        canvas: { width: 297, height: 420, margin: { top: 20, bottom: 20, left: 20, right: 20 }, colors: { paper: '#ffffff', ink: '#333333' } },
        grid: { show: true, dan: 6, charsPerDan: 11, totalLines: 25, computed: { charSizeW: 0, charSizeH: 0, lineGap: 0, danHeight: 0, danPitch: 0, pitchX: 0 } },
        view: { x: 0, y: 0, scale: 1.0 },
        activePointerId: null, interactionType: null, selectedId: null, resizeDir: null,
        pointerStart: { x: 0, y: 0 }, elemStart: { x: 0, y: 0, w: 0, h: 0 }, viewStart: { x: 0, y: 0, scale: 1 },
        touchStartDist: 0, pinchStartCanvas: { x: 0, y: 0 }, resizeAnchor: { x: 0, y: 0 },
        elements: [],
        linking: null, // { sourceId, lineEl }
        cropMode: false, // ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰
        cropEdge: null // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒˆãƒªãƒŸãƒ³ã‚°è¾º
    };

    const SVG_NS = "http://www.w3.org/2000/svg";
    const mainSvg = document.getElementById('main-svg');
    const canvasContainer = document.getElementById('canvas-container');
    const viewport = document.getElementById('viewport');
    const layerPaperGrid = document.getElementById('layer-paper-grid');
    const layerContent = document.getElementById('layer-content');
    const layerUi = document.getElementById('layer-ui');
    const svgStyle = document.getElementById('svg-style');

    // Init Events
    viewport.addEventListener('pointerdown', onPointerDown);
    viewport.addEventListener('pointermove', onPointerMove);
    viewport.addEventListener('pointerup', onPointerUp);
    viewport.addEventListener('pointercancel', onPointerUp);
    viewport.addEventListener('touchstart', onTouchStart, { passive: false });
    viewport.addEventListener('touchmove', onTouchMove, { passive: false });
    viewport.addEventListener('touchend', onTouchEnd);
    viewport.addEventListener('wheel', onWheel, { passive: false });

    // --- Handlers ---
    function onPointerDown(e) {
        if (!e.isPrimary) return; 
        if (STATE.touchStartDist > 0) return; 

        STATE.activePointerId = e.pointerId;
        STATE.pointerStart = { x: e.clientX, y: e.clientY };
        STATE.viewStart = { ...STATE.view };

        const target = e.target;
        const pt = getSvgPoint(e.clientX, e.clientY);

        // 0. Link Handle Interaction
        if (target.classList.contains('link-handle-hit')) {
            e.preventDefault();
            const sourceId = STATE.selectedId;
            if (!sourceId) return;
            const data = STATE.elements.find(el => el.id === sourceId);

            if (data.next) {
                disconnectBlock(sourceId);
                return;
            }

            STATE.interactionType = 'linking';
            const line = document.createElementNS(SVG_NS, 'line');
            line.setAttribute('x1', data.x + data.width / 2);
            line.setAttribute('y1', data.y + data.height);
            line.setAttribute('x2', pt.x);
            line.setAttribute('y2', pt.y);
            line.setAttribute('class', 'link-line-preview');
            layerUi.appendChild(line);
            STATE.linking = { sourceId: sourceId, lineEl: line };

            showLinkCandidates(sourceId);
            viewport.setPointerCapture(e.pointerId);
            return;
        }

        // 1. Resize Handle
        if (target.classList.contains('resize-handle-hit') || target.parentNode.classList.contains('handle-group')) {
            e.preventDefault();
            const group = target.classList.contains('handle-group') ? target : target.parentNode;
            group.setPointerCapture(e.pointerId);
            STATE.interactionType = 'resize';

            const classes = group.getAttribute('class');
            if(classes.includes('cursor-nw')) STATE.resizeDir = 'nw';
            if(classes.includes('cursor-ne')) STATE.resizeDir = 'ne';
            if(classes.includes('cursor-sw')) STATE.resizeDir = 'sw';
            if(classes.includes('cursor-se')) STATE.resizeDir = 'se';

            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            STATE.elemStart = { x: data.x, y: data.y, w: data.width, h: data.height };

            if (STATE.resizeDir === 'nw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y + data.height };
            if (STATE.resizeDir === 'ne') STATE.resizeAnchor = { x: data.x, y: data.y + data.height };
            if (STATE.resizeDir === 'sw') STATE.resizeAnchor = { x: data.x + data.width, y: data.y };
            if (STATE.resizeDir === 'se') STATE.resizeAnchor = { x: data.x, y: data.y };
            return;
        }

        // 1.5 Image Scale Handle Hit
        if (target.classList.contains('image-scale-handle')) {
            e.preventDefault();
            target.setPointerCapture(e.pointerId);
            STATE.interactionType = 'image-scale';
            STATE.scaleCorner = target.getAttribute('data-scale-corner');
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            STATE.elemStart = {
                scale: data.imageScale || 1.0,
                offsetX: data.imageOffsetX || 0,
                offsetY: data.imageOffsetY || 0
            };
            return;
        }

        // 1.6 Image Drag Area Hit
        if (target.classList.contains('image-drag-area')) {
            e.preventDefault();
            target.setPointerCapture(e.pointerId);
            STATE.interactionType = 'image-drag';
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            STATE.elemStart = {
                offsetX: data.imageOffsetX || 0,
                offsetY: data.imageOffsetY || 0
            };
            return;
        }

        // 2. Element Hit Logic
        let hitElementId = null;
        if (target.classList.contains('hit-rect')) {
            // hit-rectã®è¦ªè¦ç´ ã®IDã‚’å–å¾—ã€‚è¦ªãŒIDã‚’æŒãŸãªã„å ´åˆã¯ã€ã•ã‚‰ã«è¦ªã‚’æ¢ã™
            let parent = target.parentNode;
            while (parent && !parent.id && parent !== layerContent) {
                parent = parent.parentNode;
            }
            hitElementId = parent ? parent.id : null;
        }

        if (hitElementId) {
            e.preventDefault();
            target.setPointerCapture(e.pointerId);
            STATE.selectedId = hitElementId;

            // ã‚¯ãƒ­ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ç”»åƒã‚’ç§»å‹•
            const data = STATE.elements.find(el => el.id === hitElementId);
            if (STATE.cropMode && data && data.type === 'image') {
                STATE.interactionType = 'image-drag';
                STATE.elemStart = {
                    offsetX: data.imageOffsetX || 0,
                    offsetY: data.imageOffsetY || 0
                };
                renderUi();
                return;
            }

            STATE.interactionType = 'drag';
            STATE.elemStart = { x: data.x, y: data.y };
            renderUi();
        } else {
            // 3. Create or Pan (select mode)
            if (STATE.mode === 'select') {
                // Select mode: pan if no element hit
                e.preventDefault();
                if (STATE.selectedId) {
                    STATE.selectedId = null;
                    renderUi();
                }
                STATE.interactionType = 'pan';
                viewport.setPointerCapture(e.pointerId);
            } else {
                // Other modes: create new element
                e.preventDefault();
                if (STATE.selectedId) {
                    STATE.selectedId = null;
                    renderUi();
                }
                viewport.setPointerCapture(e.pointerId);
                STATE.interactionType = 'create';
                STATE.elemStart = { x: pt.x, y: pt.y };
            }
        }
    }

    function onPointerMove(e) {
        if (e.pointerId !== STATE.activePointerId) return;
        const pt = getSvgPoint(e.clientX, e.clientY);
        
        if (STATE.interactionType === 'pan') {
            const dx = e.clientX - STATE.pointerStart.x;
            const dy = e.clientY - STATE.pointerStart.y;
            STATE.view.x = STATE.viewStart.x + dx;
            STATE.view.y = STATE.viewStart.y + dy;
            updateTransform();

        } else if (STATE.interactionType === 'linking') {
            if (STATE.linking && STATE.linking.lineEl) {
                STATE.linking.lineEl.setAttribute('x2', pt.x);
                STATE.linking.lineEl.setAttribute('y2', pt.y);

                let targetId = null;
                for (const el of STATE.elements) {
                    if (el.id === STATE.linking.sourceId) continue;
                    if (el.type !== 'text') continue;
                    if (el.next || el.prev) continue;

                    if (pt.x >= el.x && pt.x <= el.x + el.width && pt.y >= el.y && pt.y <= el.y + el.height) {
                        targetId = el.id;
                        break;
                    }
                }
                updateLinkHighlight(targetId);
            }
        } else if (STATE.interactionType === 'drag') {
            const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
            const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data) {
                let newX = STATE.elemStart.x + dx;
                let newY = STATE.elemStart.y + dy;
                
                if ((data.type === 'text' || data.type === 'heading' || data.type === 'rect' || data.type === 'masthead' || data.type === 'image') && STATE.grid.computed.charSizeW > 0) {
                      newX = getClosestColumnLeftEdge(newX);
                      const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
                      if ((data.type === 'text' || data.type === 'rect') && useSnapMode) {
                          // ç§»å‹•æ™‚ã‚‚Gapã«å…¥ã‚‰ãªã„ã‚ˆã†ã«å³æ ¼ã‚¹ãƒŠãƒƒãƒ—
                          newY = snapY_StrictGap(newY);
                      } else {
                          // ç”»åƒãƒœãƒƒã‚¯ã‚¹ã¯ãƒã‚¹ç›®ã‚¹ãƒŠãƒƒãƒ—
                          newY = snapY(newY, true);
                      }
                }
                
                data.x = newX; data.y = newY;
                if(data.type === 'text') {
                    renderElement(data); 
                } else {
                    updateElementTransform(data);
                }
                updateUiPositions(data);
            }

        } else if (STATE.interactionType === 'resize') {
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if(data) {
                const anchor = STATE.resizeAnchor;
                let targetX = pt.x; let targetY = pt.y;
                let effAnchorX = anchor.x;
                let effAnchorY = anchor.y;
                
                const cGrid = STATE.grid.computed;
                
                if ((data.type === 'text' || data.type === 'heading' || data.type === 'rect' || data.type === 'masthead' || data.type === 'image') && cGrid.charSizeW > 0) {

                    if (STATE.resizeDir.includes('e')) {
                        if (targetX >= anchor.x) {
                            effAnchorX = anchor.x; targetX = getClosestColumnRightEdge(targetX);
                        } else {
                            effAnchorX = anchor.x - cGrid.lineGap; targetX = getClosestColumnLeftEdge(targetX);
                        }
                    } else if (STATE.resizeDir.includes('w')) {
                        if (targetX <= anchor.x) {
                            effAnchorX = anchor.x; targetX = getClosestColumnLeftEdge(targetX);
                        } else {
                            effAnchorX = anchor.x + cGrid.lineGap; targetX = getClosestColumnRightEdge(targetX);
                        }
                    } else {
                        targetX = getClosestColumnLeftEdge(data.x);
                    }

                    const gapY = cGrid.danPitch - cGrid.danHeight;
                    const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
                    if(STATE.resizeDir.includes('n')) {
                        if (targetY <= anchor.y) {
                            effAnchorY = anchor.y;
                            // ãƒªã‚µã‚¤ã‚º(Top)æ™‚: è¨˜äº‹ãƒ»å¡—ã‚Šã¤ã¶ã—ã¯Gapå›é¿ã€ç”»åƒã¯ãƒã‚¹ç›®ã‚¹ãƒŠãƒƒãƒ—
                            targetY = ((data.type === 'text' || data.type === 'rect') && useSnapMode) ? snapY_StrictGap(targetY) : snapY(targetY, true);
                        } else {
                            effAnchorY = anchor.y + gapY;
                            targetY = ((data.type === 'text' || data.type === 'rect') && useSnapMode) ? snapY_StrictGap(targetY) : snapY(targetY, false);
                        }
                    } else if(STATE.resizeDir.includes('s')) {
                        if (targetY >= anchor.y) {
                            effAnchorY = anchor.y;
                            // ãƒªã‚µã‚¤ã‚º(Bottom)æ™‚: è¨˜äº‹ãƒ»å¡—ã‚Šã¤ã¶ã—ã¯æ®µã®ä¸‹ç«¯ã€ç”»åƒã¯ãƒã‚¹ç›®ã‚¹ãƒŠãƒƒãƒ—
                            targetY = ((data.type === 'text' || data.type === 'rect') && useSnapMode) ? snapY_StrictGap_Bottom(targetY) : snapY(targetY, false);
                        } else {
                            effAnchorY = anchor.y - gapY;
                            targetY = ((data.type === 'text' || data.type === 'rect') && useSnapMode) ? snapY_StrictGap_Bottom(targetY) : snapY(targetY, true);
                        }
                    }
                }
                
                let newW = Math.abs(targetX - effAnchorX);
                let newH = Math.abs(targetY - effAnchorY);
                let newX = Math.min(targetX, effAnchorX);
                let newY = Math.min(targetY, effAnchorY);
                if(newW < 1) newW = 1; if(newH < 1) newH = 1;

                data.x = newX; data.y = newY; data.width = newW; data.height = newH;

                if(data.type === 'text') {
                    const head = findChainHead(data);
                    updateTextChain(head);
                } else if(data.type === 'image') {
                    // ç”»åƒãƒœãƒƒã‚¯ã‚¹ã®ãƒªã‚µã‚¤ã‚ºæ™‚ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´ã—ã¦ä½™ç™½ãŒè¦‹ãˆãªã„ã‚ˆã†ã«ã™ã‚‹
                    if (data._imageAspect) {
                        const boxAspect = data.width / data.height;
                        const imgAspect = data._imageAspect;
                        const scale = data.imageScale || 1.0;
                        let baseW, baseH;
                        if (imgAspect > boxAspect) {
                            baseH = data.height;
                            baseW = baseH * imgAspect;
                        } else {
                            baseW = data.width;
                            baseH = baseW / imgAspect;
                        }

                        const scaledW = baseW * scale;
                        const scaledH = baseH * scale;
                        const maxOffsetX = (scaledW - data.width) / 2;
                        const maxOffsetY = (scaledH - data.height) / 2;

                        // ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åˆ¶é™å†…ã«åã‚ã‚‹
                        const currentOffsetX = data.imageOffsetX || 0;
                        const currentOffsetY = data.imageOffsetY || 0;
                        data.imageOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, currentOffsetX));
                        data.imageOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, currentOffsetY));
                    }

                    renderElement(data);
                    updateUiPositions(data);
                } else {
                    if (data.type === 'heading' || data.type === 'masthead') {
                        renderElement(data); // Re-render for new size
                    } else {
                        updateElementTransform(data);
                    }
                    updateUiPositions(data);
                }
            }

        } else if (STATE.interactionType === 'crop') {
            // ... (crop code same)
        } else if (STATE.interactionType === 'image-drag') {
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data && data.type === 'image' && data._imageAspect) {
                const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;

                // ã‚«ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒˆåŸºæº–ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                const boxAspect = data.width / data.height;
                const imgAspect = data._imageAspect;
                const scale = data.imageScale || 1.0;
                let baseW, baseH;
                if (imgAspect > boxAspect) {
                    baseH = data.height;
                    baseW = baseH * imgAspect;
                } else {
                    baseW = data.width;
                    baseH = baseW / imgAspect;
                }

                // ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨å¾Œã®ç”»åƒã‚µã‚¤ã‚º
                const scaledW = baseW * scale;
                const scaledH = baseH * scale;

                // ã‚ªãƒ•ã‚»ãƒƒãƒˆã®åˆ¶é™ï¼ˆç”»åƒã®ç«¯ãŒã‚¯ãƒªãƒƒãƒ—ã®ç«¯ã«æ¥ã‚‹ã¾ã§ï¼‰
                const maxOffsetX = (scaledW - data.width) / 2;
                const maxOffsetY = (scaledH - data.height) / 2;

                const newOffsetX = STATE.elemStart.offsetX + dx;
                const newOffsetY = STATE.elemStart.offsetY + dy;

                data.imageOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, newOffsetX));
                data.imageOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, newOffsetY));

                renderElement(data);
                renderUi();
            }

        } else if (STATE.interactionType === 'image-scale') {
             // ... (image-scale code same)
             const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data && data.type === 'image' && data._imageAspect) {
                const dx = (e.clientX - STATE.pointerStart.x) / STATE.view.scale;
                const dy = (e.clientY - STATE.pointerStart.y) / STATE.view.scale;

                // ã‚«ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒˆåŸºæº–ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                const boxAspect = data.width / data.height;
                const imgAspect = data._imageAspect;
                let baseW, baseH;
                if (imgAspect > boxAspect) {
                    baseH = data.height;
                    baseW = baseH * imgAspect;
                } else {
                    baseW = data.width;
                    baseH = baseW / imgAspect;
                }

                // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¿œã˜ã¦ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
                const corner = STATE.scaleCorner;
                let scaleChange = 0;

                if (corner === 'nw') {
                    scaleChange = -(dx + dy) / Math.max(baseW, baseH);
                } else if (corner === 'ne') {
                    scaleChange = (dx - dy) / Math.max(baseW, baseH);
                } else if (corner === 'sw') {
                    scaleChange = (-dx + dy) / Math.max(baseW, baseH);
                } else if (corner === 'se') {
                    scaleChange = (dx + dy) / Math.max(baseW, baseH);
                }

                // ç”»åƒã®çŸ­è¾ºãŒã‚¯ãƒªãƒƒãƒ—ã®çŸ­è¾ºä»¥ä¸Šã«ãªã‚‹ã‚ˆã†ã«æœ€å°ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—
                const minScaleX = data.width / baseW;
                const minScaleY = data.height / baseH;
                const minScale = Math.max(minScaleX, minScaleY, 0.1);

                // æ–°ã—ã„ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
                data.imageScale = Math.max(minScale, Math.min(10, STATE.elemStart.scale + scaleChange));

                renderElement(data);
                renderUi();
            }
        } else if (STATE.interactionType === 'create') {
            // ... (create code same)
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦ç´ ã®æº–å‚™
            let preview = null;

            if (STATE.mode === 'image') {
                // ç”»åƒãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                let previewGroup = document.getElementById('creation-preview-group');
                if (!previewGroup) {
                    previewGroup = document.createElementNS(SVG_NS, 'g');
                    previewGroup.id = 'creation-preview-group';
                    layerUi.appendChild(previewGroup);
                }
                // å˜ä¸€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
                const singlePreview = document.getElementById('creation-preview');
                if (singlePreview) singlePreview.remove();
            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰: å˜ä¸€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦ç´ 
                preview = document.getElementById('creation-preview');
                if (!preview) {
                      preview = document.createElementNS(SVG_NS, 'rect');
                      preview.id = 'creation-preview';
                      preview.setAttribute('class', 'creation-preview-rect');
                      layerUi.appendChild(preview);
                }
                // ä¸è¦ãªã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚Œã°å‰Šé™¤
                const group = document.getElementById('creation-preview-group');
                if(group) group.remove();
            }
            
            let currentX = pt.x; let currentY = pt.y;
            let effStartX = STATE.elemStart.x;
            let effStartY = STATE.elemStart.y;
            const cGrid = STATE.grid.computed;

            if((STATE.mode === 'text' || STATE.mode === 'heading' || STATE.mode === 'rect' || STATE.mode === 'masthead' || STATE.mode === 'image') && cGrid.charSizeW > 0) {
                // ç‰¹æ®Šå‡¦ç†: è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰ã®ã¨ã
                if (STATE.articleSnapMode && STATE.mode === 'text') {
                    const sX = getClosestColumnRightEdge(STATE.elemStart.x);
                    const cX = getClosestColumnLeftEdge(currentX);
                    const rawTop = Math.min(STATE.elemStart.y, currentY);
                    const rawBottom = Math.max(STATE.elemStart.y, currentY);
                    const snappedTop = snapY_DanTop(rawTop);
                    const snappedBottom = snapY_DanBottom(rawBottom);
                    
                    const x = Math.min(sX, cX);
                    const width = Math.abs(sX - cX);
                    const y = snappedTop;
                    const height = snappedBottom - snappedTop;
                    
                    if (width < 1 || height < 1) {
                        if (preview) preview.remove();
                        return;
                    }

                    if (preview) {
                        preview.setAttribute('x', x);
                        preview.setAttribute('y', y);
                        preview.setAttribute('width', width);
                        preview.setAttribute('height', height);

                        if (!preview.parentNode) layerUi.appendChild(preview);
                    }
                    return;

                } else {
                    // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                    if (currentX >= STATE.elemStart.x) {
                        effStartX = getClosestColumnLeftEdge(STATE.elemStart.x); currentX = getClosestColumnRightEdge(currentX);
                    } else {
                        effStartX = getClosestColumnRightEdge(STATE.elemStart.x); currentX = getClosestColumnLeftEdge(currentX);
                    }
                    if (currentY >= STATE.elemStart.y) {
                        effStartY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanTop(STATE.elemStart.y) : snapY(STATE.elemStart.y, true);
                        currentY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanBottom(currentY) : snapY(currentY, false);
                    } else {
                        effStartY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanBottom(STATE.elemStart.y) : snapY(STATE.elemStart.y, false);
                        currentY = (STATE.mode === 'text' && STATE.articleSnapMode) ? snapY_DanTop(currentY) : snapY(currentY, true);
                    }
                }
            }
            
            const w = Math.abs(currentX - effStartX);
            const h = Math.abs(currentY - effStartY);
            const x = Math.min(currentX, effStartX);
            const y = Math.min(currentY, effStartY);

            if (STATE.mode === 'image') {
                const previewGroup = document.getElementById('creation-preview-group');
                if (!previewGroup) return;

                previewGroup.innerHTML = '';

                const gap = (cGrid.lineGap && cGrid.lineGap > 0) ? cGrid.lineGap : 5;

                // ãƒœãƒƒã‚¯ã‚¹ã‚·ãƒ£ãƒ‰ã‚¦ï¼ˆå·¦å³ã®ã¿ï¼‰
                const shadowRect = document.createElementNS(SVG_NS, 'rect');
                shadowRect.setAttribute('x', x - gap);
                shadowRect.setAttribute('y', y);
                shadowRect.setAttribute('width', w + gap * 2);
                shadowRect.setAttribute('height', h);
                shadowRect.setAttribute('class', 'paper-fill');
                shadowRect.setAttribute('opacity', '0.5');
                previewGroup.appendChild(shadowRect);

                // ãƒ¡ã‚¤ãƒ³ãƒœãƒƒã‚¯ã‚¹
                const mainRect = document.createElementNS(SVG_NS, 'rect');
                mainRect.setAttribute('x', x);
                mainRect.setAttribute('y', y);
                mainRect.setAttribute('width', w);
                mainRect.setAttribute('height', h);
                mainRect.setAttribute('class', 'creation-preview-rect');
                previewGroup.appendChild(mainRect);
            } else {
                if (preview) {
                    preview.setAttribute('x', x); preview.setAttribute('y', y);
                    preview.setAttribute('width', w); preview.setAttribute('height', h);
                    if (!preview.parentNode) layerUi.appendChild(preview);
                }
            }
        }
    }

    function onPointerUp(e) {
        if (e.pointerId !== STATE.activePointerId) return;
        const wasInteracting = (STATE.interactionType === 'drag' || STATE.interactionType === 'resize');

        if (STATE.interactionType === 'linking') {
            const pt = getSvgPoint(e.clientX, e.clientY);
            let targetId = null;
            for (const el of STATE.elements) {
                if (el.id === STATE.linking.sourceId) continue;
                if (el.type !== 'text') continue;
                if (el.next || el.prev) continue;

                if (pt.x >= el.x && pt.x <= el.x + el.width && pt.y >= el.y && pt.y <= el.y + el.height) {
                    targetId = el.id;
                    break;
                }
            }
            if (targetId) {
                connectBlocks(STATE.linking.sourceId, targetId);
            }
            if (STATE.linking.lineEl) STATE.linking.lineEl.remove();
            STATE.linking = null;
            
            clearLinkCandidates();
            renderUi();
        }

        if (STATE.interactionType === 'create') {
            const preview = document.getElementById('creation-preview');
            const group = document.getElementById('creation-preview-group');

            let x, y, w, h;

            // ç”»åƒãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯ã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰ã€ãã‚Œä»¥å¤–ã¯previewã‹ã‚‰åº§æ¨™å–å¾—
            if (group) {
                // ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®ãƒ¡ã‚¤ãƒ³ãƒœãƒƒã‚¯ã‚¹ï¼ˆ2ç•ªç›®ã®å­è¦ç´ ï¼‰ã‹ã‚‰åº§æ¨™å–å¾—
                const mainRect = group.children[1];
                if (mainRect) {
                    w = parseFloat(mainRect.getAttribute('width'));
                    h = parseFloat(mainRect.getAttribute('height'));
                    x = parseFloat(mainRect.getAttribute('x'));
                    y = parseFloat(mainRect.getAttribute('y'));
                    if (w > 5 && h > 5) createObjectFromRect({x, y, w, h});
                }
                group.remove();
            } else if(preview) {
                w = parseFloat(preview.getAttribute('width'));
                h = parseFloat(preview.getAttribute('height'));
                x = parseFloat(preview.getAttribute('x'));
                y = parseFloat(preview.getAttribute('y'));
                if (w > 5 && h > 5) createObjectFromRect({x, y, w, h});
                preview.remove();
            }
        }
        
        STATE.activePointerId = null; STATE.interactionType = null;
        try { e.target.releasePointerCapture(e.pointerId); } catch(err){}

        if (wasInteracting) {
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data) {
                if(data.type === 'text') {
                    const head = findChainHead(data);
                    updateTextChain(head);
                } else {
                    renderElement(data);
                }
                renderUi();
            }
        }
    }

    // --- Link Logic ---
    function connectBlocks(sourceId, targetId) {
        const source = STATE.elements.find(e => e.id === sourceId);
        const target = STATE.elements.find(e => e.id === targetId);
        if (!source || !target || source.type !== 'text' || target.type !== 'text') return;
        
        if (target.next) return; 
        if (target.prev) return; 
        
        let curr = source;
        while(curr) {
            if (curr.id === targetId) return; 
            if (curr.prev) curr = STATE.elements.find(e => e.id === curr.prev);
            else break;
        }

        source.next = targetId;
        target.prev = sourceId;
        
        const head = findChainHead(source);
        updateTextChain(head);
    }

    function disconnectBlock(sourceId) {
        const source = STATE.elements.find(e => e.id === sourceId);
        if (!source || !source.next) return;
        
        const nextId = source.next;
        const nextEl = STATE.elements.find(e => e.id === nextId);
        
        source.next = null;
        if (nextEl) {
            nextEl.prev = null;
            delete nextEl._renderedText;
            if (!nextEl.text) nextEl.text = "æ–°è¦è¨˜äº‹";
            renderElement(nextEl);
        }
        
        const head = findChainHead(source);
        updateTextChain(head);
        renderUi();
    }

    function findChainHead(block) {
        let curr = block;
        while (curr.prev) {
            const prev = STATE.elements.find(e => e.id === curr.prev);
            if (!prev) { curr.prev = null; break; } 
            curr = prev;
        }
        return curr;
    }

    function updateTextChain(head) {
        if (!head || head.type !== 'text') return;
        
        let curr = head;
        let remainingText = head.text; 
        
        while(curr) {
            const res = measureCapacity(curr, remainingText);
            curr._renderedText = res.fitted; 
            remainingText = res.remaining;
            
            renderElement(curr);
            
            if (curr.next) {
                const next = STATE.elements.find(e => e.id === curr.next);
                if (!next) { curr.next = null; break; }
                curr = next;
            } else {
                curr = null;
            }
        }
    }

    // Internal Column Logic Helper
    function getIntersectingDans(data) {
        const cGrid = STATE.grid.computed;
        if (!STATE.grid.show || !cGrid.danPitch) {
            return [{ yOffset: 0, height: data.height, localY: 0 }];
        }

        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const boxTop = data.y;
        const boxBottom = data.y + data.height;
        
        const segments = [];
        const epsilon = 1.0; 

        for (let i = 0; i < STATE.grid.dan; i++) {
            const danTop = mt + (i * cGrid.danPitch);
            const danBottom = danTop + cGrid.danHeight;
            
            const start = Math.max(boxTop, danTop - epsilon);
            const end = Math.min(boxBottom, danBottom + epsilon);

            if (end > start + 5) {
                 const localY = danTop - boxTop;
                 segments.push({
                     danIndex: i,
                     danTop: danTop,
                     localY: localY, 
                     height: cGrid.danHeight
                 });
            }
        }
        
        if (segments.length === 0) return [{ yOffset: 0, height: data.height, localY: 0 }];
        
        return segments;
    }

    function getLayoutMetrics(data, forcedHeight) {
        const cGrid = STATE.grid.computed;
        let fontSize, charHeight, pitchX;
        
        if (cGrid.charSizeW > 0 && STATE.grid.show) { 
            fontSize = cGrid.charSizeW;
            charHeight = cGrid.charSizeH;
            pitchX = cGrid.pitchX;
        } else {
            fontSize = data.fontSize;
            charHeight = data.fontSize;
            pitchX = data.fontSize * data.lineHeight;
        }

        const w = data.width;
        const h = forcedHeight !== undefined ? forcedHeight : data.height;
        
        const charsPerLine = Math.max(1, Math.floor((h + 0.5) / charHeight));
        
        let maxLines = 1;
        if (w >= fontSize) {
            maxLines = 1 + Math.floor((w - fontSize + 0.5) / pitchX);
        } else {
            maxLines = 0;
        }

        return { fontSize, charHeight, pitchX, charsPerLine, maxLines };
    }

    function measureCapacity(data, text) {
        if (!text) return { fitted: "", remaining: "" };

        let segments;
        const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
        if (useSnapMode) {
              segments = getIntersectingDans(data);
        } else {
              segments = [{ height: data.height, localY: 0 }];
        }
        
        let splitIndex = 0;
        let charIndex = 0;
        
        for (const seg of segments) {
            const metrics = getLayoutMetrics(data, seg.height);
            const { charsPerLine, maxLines } = metrics;
            
            let currentLine = 1;
            let currentCharInLine = 0;
            
            while (charIndex < text.length) {
                const char = text[charIndex];
                charIndex++;
                
                if (char === '\n') {
                    currentLine++;
                    currentCharInLine = 0;
                } else {
                    currentCharInLine++;
                    if (currentCharInLine > charsPerLine) {
                        currentLine++;
                        currentCharInLine = 1;
                    }
                }
                
                if (currentLine > maxLines) {
                    charIndex--; 
                    break;
                }
            }
            splitIndex = charIndex;
            if (splitIndex >= text.length) break;
        }

        return {
            fitted: text.substring(0, splitIndex),
            remaining: text.substring(splitIndex)
        };
    }

    // --- Helper Snaps ---
    function getColumnIndexAt(rawX) {
        const cGrid = STATE.grid.computed;
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        const w_px = STATE.canvas.width * PX_PER_MM;
        const rightEdge = w_px - mr;
        const center0 = rightEdge - (cGrid.charSizeW / 2);
        return Math.round((center0 - rawX) / cGrid.pitchX);
    }

    function getClosestColumnRightEdge(rawX) {
        const cGrid = STATE.grid.computed;
        const col = getColumnIndexAt(rawX);
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        const w_px = STATE.canvas.width * PX_PER_MM;
        const rightEdge = w_px - mr; 
        return rightEdge - (col * cGrid.pitchX);
    }

    function getClosestColumnLeftEdge(rawX) {
        const cGrid = STATE.grid.computed;
        return getClosestColumnRightEdge(rawX) - cGrid.charSizeW;
    }
    
    // å·¦å³ã©ã¡ã‚‰ã‹è¿‘ã„æ–¹ã®åˆ—ã‚°ãƒªãƒƒãƒ‰ç·šã‚’å–å¾—
    function getClosestColumnGridLine(rawX) {
        const cGrid = STATE.grid.computed;
        const col = getColumnIndexAt(rawX);
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        const w_px = STATE.canvas.width * PX_PER_MM;
        const rightEdgeBase = w_px - mr; 
        const rEdge = rightEdgeBase - (col * cGrid.pitchX);
        const lEdge = rEdge - cGrid.charSizeW;
        return Math.abs(rawX - rEdge) < Math.abs(rawX - lEdge) ? rEdge : lEdge;
    }
    
    // ãƒ‰ãƒ©ãƒƒã‚°é€²è¡Œæ–¹å‘ã«ã‚ã‚‹ã€æœ€ã‚‚è¿‘ã„æœ‰åŠ¹ãªåˆ—å¢ƒç•Œç·šã‚’å–å¾—
    function getSnapEdgeX(rawX, diffX) {
        const cGrid = STATE.grid.computed;
        // ... (snap logic used implicitly in resize)
        return getClosestColumnLeftEdge(rawX); // Simplified
    }

    // --- Gapå›é¿ã‚¹ãƒŠãƒƒãƒ—é–¢æ•° (New) ---
    function snapY_StrictGap(rawY) {
        const cGrid = STATE.grid.computed;
        if (!cGrid.danHeight || cGrid.charSizeH <= 0) return rawY;

        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const relY = rawY - mt;

        // ã©ã®æ®µã®ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ï¼ˆGapå«ã‚€ï¼‰
        const danPitch = cGrid.danPitch;
        const danIndex = Math.floor(relY / danPitch);
        const offsetInDan = relY % danPitch; // æ®µTopã‹ã‚‰ã®è·é›¢

        // ç¯„å›²å¤–ï¼ˆä¸Šç«¯ã‚ˆã‚Šä¸Šã€æœ€çµ‚æ®µã‚ˆã‚Šä¸‹ï¼‰ã®ã‚¬ãƒ¼ãƒ‰
        if (danIndex < 0) return mt;
        if (danIndex >= STATE.grid.dan) return mt + (STATE.grid.dan * danPitch) - (danPitch - cGrid.danHeight);

        // Gapåˆ¤å®š
        if (offsetInDan > cGrid.danHeight) {
            // Gapã®ä¸­ã«ã„ã‚‹ -> æ¬¡ã®æ®µã®ä¸Šç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
            return mt + ((danIndex + 1) * danPitch);
        } else {
            // æ®µã®ä¸­ã«ã„ã‚‹ -> ã“ã®æ®µã®ä¸Šç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
            return mt + (danIndex * danPitch);
        }
    }

    // ä¸‹ç«¯ãƒªã‚µã‚¤ã‚ºç”¨: æ®µã®ä¸‹ç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
    function snapY_StrictGap_Bottom(rawY) {
        const cGrid = STATE.grid.computed;
        if (!cGrid.danHeight || cGrid.charSizeH <= 0) return rawY;

        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const relY = rawY - mt;

        // ã©ã®æ®µã®ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ï¼ˆGapå«ã‚€ï¼‰
        const danPitch = cGrid.danPitch;
        const danIndex = Math.floor(relY / danPitch);
        const offsetInDan = relY % danPitch; // æ®µTopã‹ã‚‰ã®è·é›¢

        // ç¯„å›²å¤–ï¼ˆä¸Šç«¯ã‚ˆã‚Šä¸Šã€æœ€çµ‚æ®µã‚ˆã‚Šä¸‹ï¼‰ã®ã‚¬ãƒ¼ãƒ‰
        if (danIndex < 0) return mt;
        if (danIndex >= STATE.grid.dan) return mt + (STATE.grid.dan * danPitch) - (danPitch - cGrid.danHeight);

        // Gapåˆ¤å®š
        if (offsetInDan > cGrid.danHeight) {
            // Gapã®ä¸­ã«ã„ã‚‹ -> æ¬¡ã®æ®µã®ä¸‹ç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
            return mt + ((danIndex + 1) * danPitch) + cGrid.danHeight;
        } else {
            // æ®µã®ä¸­ã«ã„ã‚‹ -> ã“ã®æ®µã®ä¸‹ç«¯ã«ã‚¹ãƒŠãƒƒãƒ—
            return mt + (danIndex * danPitch) + cGrid.danHeight;
        }
    }

    function snapY(rawY, isTopEdge) {
        const cGrid = STATE.grid.computed; if (cGrid.charSizeH <= 0) return rawY;
        const mt = STATE.canvas.margin.top * PX_PER_MM; const relY = rawY - mt;
        const danIndex = Math.floor(relY / cGrid.danPitch); const danStart = mt + (danIndex * cGrid.danPitch);
        const charIndex = Math.round((rawY - danStart) / cGrid.charSizeH);
        return danStart + (charIndex * cGrid.charSizeH);
    }
    
    function snapY_Dan(rawY) { return snapY_DanTop(rawY); }

    function snapY_DanTop(rawY) {
        const cGrid = STATE.grid.computed;
        if (!cGrid.danHeight) return rawY;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        let candidates = [];
        for(let i=0; i<STATE.grid.dan; i++) {
            candidates.push(mt + (i * cGrid.danPitch));
        }
        return candidates.reduce((prev, curr) => Math.abs(curr - rawY) < Math.abs(prev - rawY) ? curr : prev);
    }

    function snapY_DanBottom(rawY) {
        const cGrid = STATE.grid.computed;
        if (!cGrid.danHeight) return rawY;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        let candidates = [];
        for(let i=0; i<STATE.grid.dan; i++) {
            candidates.push(mt + (i * cGrid.danPitch) + cGrid.danHeight);
        }
        return candidates.reduce((prev, curr) => Math.abs(curr - rawY) < Math.abs(prev - rawY) ? curr : prev);
    }
    
    // --- Touch (Pinch Zoom) ---
    function onTouchStart(e) {
        if (e.touches.length === 2) {
            e.preventDefault(); STATE.activePointerId = null; STATE.interactionType = null;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            STATE.touchStartDist = Math.sqrt(dx * dx + dy * dy);
            const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            STATE.viewStart = { ...STATE.view };
            const rect = viewport.getBoundingClientRect();
            const vx = cx - rect.left; const vy = cy - rect.top;
            STATE.pinchStartCanvas = { x: (vx - STATE.viewStart.x) / STATE.viewStart.scale, y: (vy - STATE.viewStart.y) / STATE.viewStart.scale };
        }
    }
    function onTouchMove(e) {
        if (e.touches.length === 2 && STATE.touchStartDist > 0) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const zoomFactor = Math.sqrt(dx * dx + dy * dy) / STATE.touchStartDist;
            let newScale = Math.max(0.1, Math.min(STATE.viewStart.scale * zoomFactor, 10.0));
            const rect = viewport.getBoundingClientRect();
            const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            const vx = cx - rect.left; const vy = cy - rect.top;
            STATE.view.scale = newScale;
            STATE.view.x = vx - (STATE.pinchStartCanvas.x * newScale);
            STATE.view.y = vy - (STATE.pinchStartCanvas.y * newScale);
            updateTransform();
        }
    }
    function onTouchEnd(e) { if (e.touches.length < 2) STATE.touchStartDist = 0; }
    function onWheel(e) {
        e.preventDefault();
        if (e.altKey || e.ctrlKey) {
            const delta = -Math.sign(e.deltaY);
            let newScale = Math.max(0.1, Math.min(STATE.view.scale * (1 + delta * 0.05), 10.0));
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            STATE.view.x = mouseX - (mouseX - STATE.view.x) * (newScale / STATE.view.scale);
            STATE.view.y = mouseY - (mouseY - STATE.view.y) * (newScale / STATE.view.scale);
            STATE.view.scale = newScale;
        } else { STATE.view.x -= e.deltaX; STATE.view.y -= e.deltaY; }
        updateTransform();
    }

    // --- Core Logic ---
    function setMode(mode) {
        STATE.mode = mode;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if(mode === 'select') document.getElementById('btn-select').classList.add('active');
        if(mode === 'text') document.getElementById('btn-text').classList.add('active');
        if(mode === 'heading') document.getElementById('btn-heading').classList.add('active');
        if(mode === 'masthead') document.getElementById('btn-masthead').classList.add('active');
        if(mode === 'rect') document.getElementById('btn-rect').classList.add('active');
        if(mode === 'image') document.getElementById('btn-image').classList.add('active');

        viewport.className = 'viewport';
        // ãƒãƒ³ãƒ‰ãƒ„ãƒ¼ãƒ«ç”¨ã®ã‚¯ãƒ©ã‚¹ä»˜ä¸
        if(mode === 'select') viewport.classList.add('mode-select');
        else viewport.classList.add('mode-create');
    }

    function updateSnapMode() {
        const cbNone = document.getElementById('inp-snap-article');
        const cbText = document.getElementById('inp-snap-article-txt');

        // é¸æŠä¸­ã®è¨˜äº‹ãƒœãƒƒã‚¯ã‚¹ãŒã‚ã‚‹å ´åˆã¯ã€ãã®ãƒœãƒƒã‚¯ã‚¹ã®snapModeã‚’æ›´æ–°
        if (STATE.selectedId) {
            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data && data.type === 'text') {
                if (document.activeElement === cbText) {
                    data.snapMode = cbText.checked;
                    cbNone.checked = cbText.checked; // åŒæœŸ
                    STATE.articleSnapMode = cbText.checked; // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚‚æ›´æ–°
                }

                // é¸æŠä¸­ã®ãƒœãƒƒã‚¯ã‚¹ã®ãƒã‚§ãƒ¼ãƒ³ã‚’å†è¨ˆç®—
                const head = findChainHead(data);
                updateTextChain(head);
                renderUi();
                return;
            }
        }

        // é¸æŠä¸­ã®ãƒœãƒƒã‚¯ã‚¹ãŒãªã„å ´åˆã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã®ã¿æ›´æ–°
        if (document.activeElement === cbNone) {
            STATE.articleSnapMode = cbNone.checked;
            cbText.checked = STATE.articleSnapMode;
        } else if (document.activeElement === cbText) {
            STATE.articleSnapMode = cbText.checked;
            cbNone.checked = STATE.articleSnapMode;
        } else {
            STATE.articleSnapMode = cbNone.checked;
        }
    }

    function createObjectFromRect(rect) {
        const id = 'el_' + Math.random().toString(36).substr(2, 9);
        const cGrid = STATE.grid.computed;
        const initFontSize = cGrid.charSizeW > 0 ? cGrid.charSizeW : 24;
        const initLineHeight = cGrid.charSizeW > 0 ? (cGrid.lineGap / cGrid.charSizeW) + 1 : 1.5;
        let data;

        if (STATE.mode === 'text') {
            data = {
                id, type: 'text', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                text: "æ–°è¦è¨˜äº‹", fontSize: initFontSize, lineHeight: initLineHeight,
                writingMode: 'vertical-rl', fontFamily: '"BIZ UDMincho", serif', charScale: 85, showGrid: false,
                snapMode: STATE.articleSnapMode // å€‹åˆ¥ã®è¨˜äº‹é…ç½®ãƒ¢ãƒ¼ãƒ‰è¨­å®š
            };
        } else if (STATE.mode === 'heading') {
            data = {
                id, type: 'heading', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                text: "è¦‹å‡ºã—", paddingV: 5, paddingH: 5, fontFamily: '"Noto Sans JP", sans-serif',
                inverted: false
            };
        } else if (STATE.mode === 'masthead') {
            data = {
                id, type: 'masthead', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                text: "æ–°èé¡Œå­—", fontFamily: '"Noto Serif JP", serif',
                borderWidthOuter: 1.0, borderWidthInner: 0.3, patternLineHeight: 0.4,
                paddingH: 0, paddingV: 0, textStrokeWidth: 4, inverted: false
            };
        } else if (STATE.mode === 'image') {
            data = {
                id, type: 'image', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                imageUrl: null, 
                imageScale: 1.0,
                imageOffsetX: 0,
                imageOffsetY: 0
            };
        } else if (STATE.mode === 'freetext') {
            data = {
                id, type: 'freetext', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                text: "è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆ",
                direction: 'vertical',
                align: 'start-start',
                fontFamily: '"BIZ UDMincho", serif',
                fontSize: 12 
            };
        } else {
            data = {
                id, type: 'rect', x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                fillMode: 'paper', 
                borderStyle: 'none', 
                borderWidth: 0.5 
            };
        }
        STATE.elements.push(data);
        renderElement(data);
        selectElement(id);
    }
    
    function updateElementTransform(data) {
        const group = document.getElementById(data.id);
        if(!group) return;
        
        let trans = `translate(${data.x}, ${data.y})`;
        if (data.type === 'text') {
            const scaleVal = (data.charScale || 85) / 100;
            trans += (data.writingMode === 'vertical-rl') ? ` scale(1, ${scaleVal})` : ` scale(${scaleVal}, 1)`;
        } 
        if (data.type === 'heading' || data.type === 'masthead') {
            renderElement(data); 
            return;
        }
        group.setAttribute('transform', trans);
        const hitRect = group.querySelector('.hit-rect');
        if (hitRect) {
            let effW = data.width; let effH = data.height;
            if (data.type === 'text' && data.writingMode === 'vertical-rl') effH = data.height / ((data.charScale||85)/100);
            hitRect.setAttribute('width', effW); hitRect.setAttribute('height', effH);
        }
    }

    function renderElement(data) {
        let group = document.getElementById(data.id);
        if (!group) {
            group = document.createElementNS(SVG_NS, 'g');
            group.id = data.id;
            layerContent.appendChild(group);
        }
        group.innerHTML = '';

        if (data.type === 'text') {
            const scaleVal = (data.charScale || 85) / 100;
            // The main group handles the top-left positioning and scaling
            let trans = `translate(${data.x}, ${data.y})`;
            trans += (data.writingMode === 'vertical-rl') ? ` scale(1, ${scaleVal})` : ` scale(${scaleVal}, 1)`;
            group.setAttribute('transform', trans);

            const contentToRender = (data.prev !== undefined && data.prev !== null) ? (data._renderedText || "") : (data._renderedText !== undefined ? data._renderedText : data.text);
            
            // --- Multi-Dan Internal Rendering ---
            let segments;
            const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
            if (useSnapMode) {
                segments = getIntersectingDans(data);
            } else {
                segments = [{ height: data.height, localY: 0 }];
            }

            let charCursor = 0;
            const gap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;

            // Render each segment
            for (const seg of segments) {
                let segRenderHeight = seg.height;
                if (data.writingMode === 'vertical-rl') segRenderHeight = seg.height / scaleVal;

                const segGroup = document.createElementNS(SVG_NS, 'g');
                const segY = seg.localY / scaleVal;
                segGroup.setAttribute('transform', `translate(0, ${segY})`);

                // 1. Background (only in Free Mode, per original logic, but now per segment)
                if (!useSnapMode) {
                    const bgRect = document.createElementNS(SVG_NS, 'rect');
                    bgRect.setAttribute('x', -gap);
                    bgRect.setAttribute('y', 0);
                    bgRect.setAttribute('width', data.width + gap * 2);
                    bgRect.setAttribute('height', segRenderHeight);
                    bgRect.setAttribute('class', 'paper-fill');
                    segGroup.appendChild(bgRect);
                }

                // 2. Hit Rect (Segment specific)
                const hitRect = document.createElementNS(SVG_NS, 'rect');
                hitRect.setAttribute('class', 'hit-rect');
                hitRect.setAttribute('width', data.width); 
                hitRect.setAttribute('height', segRenderHeight);
                segGroup.appendChild(hitRect);

                // 3. Text Content
                if (charCursor < contentToRender.length) {
                    const metrics = getLayoutMetrics(data, seg.height);
                    const { fontSize, charHeight, pitchX, charsPerLine, maxLines } = metrics;
                    const renderCharHeight = charHeight / scaleVal; 
                    
                    const textEl = document.createElementNS(SVG_NS, 'text');
                    textEl.setAttribute('font-family', data.fontFamily);
                    textEl.setAttribute('font-size', fontSize);
                    textEl.setAttribute('writing-mode', data.writingMode);
                    textEl.setAttribute('dominant-baseline', 'central'); 
                    textEl.setAttribute('text-anchor', 'middle');
                    textEl.setAttribute('class', 'ink-fill'); 
                    textEl.style.fontFamily = data.fontFamily;

                    let currentLineIdx = 0;
                    let currentCharIdx = 0;
                    
                    while (charCursor < contentToRender.length) {
                        const char = contentToRender[charCursor];
                        charCursor++;

                        if (char === '\n') {
                            currentLineIdx++;
                            currentCharIdx = 0;
                            if (currentLineIdx >= maxLines) break; 
                            continue;
                        }

                        if (currentCharIdx >= charsPerLine) {
                            currentLineIdx++;
                            currentCharIdx = 0;
                        }
                        
                        if (currentLineIdx >= maxLines) {
                            charCursor--; 
                            break;
                        }

                        const centerX = data.width - (fontSize / 2) - (currentLineIdx * pitchX);
                        const centerY = (currentCharIdx * renderCharHeight) + (renderCharHeight / 2);

                        const tspan = document.createElementNS(SVG_NS, 'tspan');
                        tspan.textContent = char;
                        tspan.setAttribute('x', centerX); tspan.setAttribute('y', centerY);
                        textEl.appendChild(tspan);
                        
                        currentCharIdx++;
                    }
                    segGroup.appendChild(textEl);
                }
                group.appendChild(segGroup);
            }

        } else if (data.type === 'heading') {
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);
            
            const gap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;
            const shadowRect = document.createElementNS(SVG_NS, 'rect');
            shadowRect.setAttribute('x', -gap);
            shadowRect.setAttribute('y', 0);
            shadowRect.setAttribute('width', data.width + gap * 2);
            shadowRect.setAttribute('height', data.height);
            shadowRect.setAttribute('class', 'paper-fill');
            group.appendChild(shadowRect);

            const bgRect = document.createElementNS(SVG_NS, 'rect');
            bgRect.setAttribute('x', 0); bgRect.setAttribute('y', 0);
            bgRect.setAttribute('width', data.width); bgRect.setAttribute('height', data.height);
            if (data.inverted) bgRect.setAttribute('class', 'ink-fill'); 
            else bgRect.setAttribute('class', 'paper-fill');
            group.appendChild(bgRect);

            const isVertical = data.height > data.width;
            const glyphs = Array.from(data.text || '');
            const glyphCount = glyphs.length;
            const content = getHeadingContentBounds(data);

            if (content.width > 0 && content.height > 0 && glyphCount > 0) {
                const columns = isVertical ? 1 : glyphCount;
                const rows = isVertical ? glyphCount : 1;
                const cellWidth = columns > 0 ? content.width / columns : content.width;
                const cellHeight = rows > 0 ? content.height / rows : content.height;

                // ã‚»ãƒ«ã®ç¸¦æ¨ªã«åˆã‚ã›ã¦ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’æ±ºå®šï¼ˆå¹³ä½“ãƒ»é•·ä½“ã‚’å®Ÿç¾ï¼‰
                // åŸºæº–ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¯å°ã•ã„æ–¹ã®è¾ºã®90%
                const baseFontSize = Math.min(cellWidth, cellHeight) * 0.9;
                // ã‚¹ã‚±ãƒ¼ãƒ«ã§å¤§ãã„æ–¹ã®è¾ºã«ã‚‚å¯¾å¿œ
                const scaleX = (cellWidth * 0.9) / baseFontSize;
                const scaleY = (cellHeight * 0.9) / baseFontSize;

                for (let idx = 0; idx < glyphCount; idx++) {
                    const cellX = content.offsetX + (isVertical ? 0 : idx * cellWidth);
                    const cellY = content.offsetY + (isVertical ? idx * cellHeight : 0);
                    const centerX = cellX + cellWidth / 2;
                    const centerY = cellY + cellHeight / 2;

                    // 15%ä¸Šã«ãšã‚‰ã™
                    const verticalOffset = -baseFontSize * 0.075;
                    const adjustedY = isVertical ? centerY : centerY + verticalOffset;

                    const textEl = document.createElementNS(SVG_NS, 'text');
                    textEl.textContent = glyphs[idx];
                    textEl.setAttribute('font-family', data.fontFamily);
                    textEl.setAttribute('font-weight', '900');
                    textEl.setAttribute('font-size', baseFontSize);
                    textEl.setAttribute('x', centerX);
                    textEl.setAttribute('y', adjustedY);
                    textEl.setAttribute('dominant-baseline', 'central');
                    textEl.setAttribute('text-anchor', 'middle');
                    textEl.setAttribute('writing-mode', isVertical ? 'vertical-rl' : 'horizontal-tb');
                    textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                    textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                    textEl.setAttribute('class', data.inverted ? 'paper-fill' : 'ink-fill');
                    textEl.style.fontFamily = data.fontFamily;

                    group.appendChild(textEl);
                }
            }

            const hitRect = document.createElementNS(SVG_NS, 'rect');
            hitRect.setAttribute('class', 'hit-rect');
            hitRect.setAttribute('width', data.width); hitRect.setAttribute('height', data.height);
            group.appendChild(hitRect);

        } else if (data.type === 'masthead') {
            // Masthead Rendering
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);
            
            const bo = parseFloat(data.borderWidthOuter) * PX_PER_MM;
            const gap = bo; // UPDATED: Gap equals outer border width
            const bi = parseFloat(data.borderWidthInner) * PX_PER_MM;
            const pl = parseFloat(data.patternLineHeight) * PX_PER_MM;
            
            // 1. Background (White)
            const bg = document.createElementNS(SVG_NS, 'rect');
            bg.setAttribute('width', data.width); bg.setAttribute('height', data.height);
            bg.setAttribute('class', 'paper-fill');
            group.appendChild(bg);

            // 2. Outer Border (Ink)
            const outerRect = document.createElementNS(SVG_NS, 'rect');
            const oOffset = bo / 2;
            outerRect.setAttribute('x', oOffset); outerRect.setAttribute('y', oOffset);
            outerRect.setAttribute('width', Math.max(0, data.width - bo));
            outerRect.setAttribute('height', Math.max(0, data.height - bo));
            outerRect.setAttribute('fill', 'none');
            outerRect.setAttribute('class', 'ink-stroke');
            outerRect.setAttribute('stroke-width', bo);
            outerRect.setAttribute('stroke-linejoin', 'miter'); 
            group.appendChild(outerRect);

            // 3. Inner Border (Ink)
            const innerRect = document.createElementNS(SVG_NS, 'rect');
            const iOffset = bo + gap + (bi / 2);
            innerRect.setAttribute('x', iOffset); innerRect.setAttribute('y', iOffset);
            innerRect.setAttribute('width', Math.max(0, data.width - iOffset * 2));
            innerRect.setAttribute('height', Math.max(0, data.height - iOffset * 2));
            innerRect.setAttribute('fill', 'none');
            innerRect.setAttribute('class', 'ink-stroke');
            innerRect.setAttribute('stroke-width', bi);
            innerRect.setAttribute('stroke-linejoin', 'round');
            group.appendChild(innerRect);

            // 4. Pattern Fill (Inside Inner Border)
            const patternId = 'pat-' + data.id;
            const patternSize = pl * 4; 
            
            let defs = mainSvg.querySelector('defs');
            let pattern = document.getElementById(patternId);
            if (pattern) pattern.remove();
            
            pattern = document.createElementNS(SVG_NS, 'pattern');
            pattern.setAttribute('id', patternId);
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            pattern.setAttribute('width', patternSize); pattern.setAttribute('height', patternSize);
            // æ¨ªç·šãƒ‘ã‚¿ãƒ¼ãƒ³
            const line = document.createElementNS(SVG_NS, 'line');
            line.setAttribute('x1', 0); line.setAttribute('y1', patternSize/2);
            line.setAttribute('x2', patternSize); line.setAttribute('y2', patternSize/2);
            line.setAttribute('class', 'ink-stroke');
            line.setAttribute('stroke-width', pl);
            pattern.appendChild(line);
            defs.appendChild(pattern);

            const patternRect = document.createElementNS(SVG_NS, 'rect');
            const pOffset = bo + gap + bi; // å†…æ ã®ã•ã‚‰ã«å†…å´
            patternRect.setAttribute('x', pOffset); patternRect.setAttribute('y', pOffset);
            patternRect.setAttribute('width', Math.max(0, data.width - pOffset * 2));
            patternRect.setAttribute('height', Math.max(0, data.height - pOffset * 2));
            patternRect.setAttribute('fill', `url(#${patternId})`);
            group.appendChild(patternRect);

            const isVertical = data.height > data.width;
            const glyphs = Array.from(data.text || '');
            const glyphCount = glyphs.length;
            const content = getHeadingContentBounds(data);

            // Define ClipPath (Fix: Clip region should be static relative to the group)
            const clipId = 'clip-' + data.id;
            let clipPath = document.getElementById(clipId);
            if (clipPath) clipPath.remove();

            clipPath = document.createElementNS(SVG_NS, 'clipPath');
            clipPath.setAttribute('id', clipId);
            const clipRect = document.createElementNS(SVG_NS, 'rect');
            clipRect.setAttribute('x', pOffset);
            clipRect.setAttribute('y', pOffset);
            clipRect.setAttribute('width', Math.max(0, data.width - pOffset * 2));
            clipRect.setAttribute('height', Math.max(0, data.height - pOffset * 2));
            clipPath.appendChild(clipRect);
            defs.appendChild(clipPath);

            const textGroup = document.createElementNS(SVG_NS, 'g');
            textGroup.setAttribute('clip-path', `url(#${clipId})`);
            group.appendChild(textGroup);

            if (content.width > 0 && content.height > 0 && glyphCount > 0) {
                const columns = isVertical ? 1 : glyphCount;
                const rows = isVertical ? glyphCount : 1;
                const cellWidth = columns > 0 ? content.width / columns : content.width;
                const cellHeight = rows > 0 ? content.height / rows : content.height;

                // ã‚»ãƒ«ã®ç¸¦æ¨ªã«åˆã‚ã›ã¦ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’æ±ºå®šï¼ˆå¹³ä½“ãƒ»é•·ä½“ã‚’å®Ÿç¾ï¼‰
                // åŸºæº–ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¯å°ã•ã„æ–¹ã®è¾ºã®90%
                const baseFontSize = Math.min(cellWidth, cellHeight) * 0.9;
                // ã‚¹ã‚±ãƒ¼ãƒ«ã§å¤§ãã„æ–¹ã®è¾ºã«ã‚‚å¯¾å¿œ
                const scaleX = (cellWidth * 0.9) / baseFontSize;
                const scaleY = (cellHeight * 0.9) / baseFontSize;

                for (let idx = 0; idx < glyphCount; idx++) {
                    const cellX = content.offsetX + (isVertical ? 0 : idx * cellWidth);
                    const cellY = content.offsetY + (isVertical ? idx * cellHeight : 0);
                    const centerX = cellX + cellWidth / 2;
                    const centerY = cellY + cellHeight / 2;

                    // 15%ä¸Šã«ãšã‚‰ã™
                    const verticalOffset = -baseFontSize * 0.075;
                    const adjustedY = isVertical ? centerY : centerY + verticalOffset;

                    const textEl = document.createElementNS(SVG_NS, 'text');
                    textEl.textContent = glyphs[idx];
                    textEl.setAttribute('font-family', data.fontFamily);
                    textEl.setAttribute('font-weight', '900');
                    textEl.setAttribute('font-size', baseFontSize);
                    textEl.setAttribute('x', centerX);
                    textEl.setAttribute('y', adjustedY);
                    textEl.setAttribute('dominant-baseline', 'central');
                    textEl.setAttribute('text-anchor', 'middle');
                    textEl.setAttribute('writing-mode', isVertical ? 'vertical-rl' : 'horizontal-tb');
                    textEl.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                    textEl.setAttribute('transform-origin', `${centerX} ${centerY}`);
                    textEl.setAttribute('class', data.inverted ? 'paper-fill' : 'ink-fill');
                    textEl.style.fontFamily = data.fontFamily;

                    const strokeColor = data.inverted ? STATE.canvas.colors.ink : STATE.canvas.colors.paper;
                    textEl.setAttribute('stroke', strokeColor);
                    textEl.setAttribute('stroke-width', (data.textStrokeWidth || 4) + 'px');
                    textEl.setAttribute('stroke-linejoin', 'round');
                    textEl.setAttribute('stroke-linecap', 'round');
                    textEl.setAttribute('paint-order', 'stroke fill');

                    textGroup.appendChild(textEl);
                }
            }

            const hitRect = document.createElementNS(SVG_NS, 'rect');
            hitRect.setAttribute('class', 'hit-rect');
            hitRect.setAttribute('width', data.width); hitRect.setAttribute('height', data.height);
            group.appendChild(hitRect);

        } else if (data.type === 'image') {
            // ç”»åƒãƒœãƒƒã‚¯ã‚¹
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

            // è¡Œé–“å¹…ã‚’å–å¾—ï¼ˆãƒœãƒƒã‚¯ã‚¹ã‚·ãƒ£ãƒ‰ã‚¦ç”¨ï¼‰
            const gap = (STATE.grid.computed.lineGap && STATE.grid.computed.lineGap > 0) ? STATE.grid.computed.lineGap : 5;

            // 1. ãƒœãƒƒã‚¯ã‚¹ã‚·ãƒ£ãƒ‰ã‚¦ï¼ˆç´™è‰²ã®ä½™ç™½ã€å·¦å³ã®ã¿ï¼‰
            const shadowRect = document.createElementNS(SVG_NS, 'rect');
            shadowRect.setAttribute('x', -gap);
            shadowRect.setAttribute('y', 0);
            shadowRect.setAttribute('width', data.width + gap * 2);
            shadowRect.setAttribute('height', data.height);
            shadowRect.setAttribute('class', 'paper-fill');
            group.appendChild(shadowRect);

            // 2. ç”»åƒè¡¨ç¤ºé ˜åŸŸï¼ˆã‚¯ãƒªãƒƒãƒ—ãƒ‘ã‚¹ç”¨ï¼‰
            const clipId = `clip-${data.id}`;
            const clipPath = document.createElementNS(SVG_NS, 'clipPath');
            clipPath.setAttribute('id', clipId);
            const clipRect = document.createElementNS(SVG_NS, 'rect');
            clipRect.setAttribute('width', data.width);
            clipRect.setAttribute('height', data.height);
            clipPath.appendChild(clipRect);
            group.appendChild(clipPath);

            // 3. ç”»åƒï¼ˆã‚¹ã‚±ãƒ¼ãƒ« + ã‚ªãƒ•ã‚»ãƒƒãƒˆæ–¹å¼ï¼‰
            if (data.imageUrl) {
                const imgGroup = document.createElementNS(SVG_NS, 'g');
                imgGroup.setAttribute('clip-path', `url(#${clipId})`);
                imgGroup.id = `img-content-${data.id}`; // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã«ã™ã‚‹ãŸã‚ã®ID

                const img = document.createElementNS(SVG_NS, 'image');
                img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', data.imageUrl);

                // ã‚«ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒˆè¨ˆç®—ï¼ˆåŸºæº–ã‚µã‚¤ã‚ºï¼‰
                if (data._imageAspect) {
                    const boxAspect = data.width / data.height;
                    const imgAspect = data._imageAspect;

                    let baseW, baseH, baseX, baseY;
                    if (imgAspect > boxAspect) {
                        baseH = data.height;
                        baseW = baseH * imgAspect;
                        baseX = (data.width - baseW) / 2;
                        baseY = 0;
                    } else {
                        baseW = data.width;
                        baseH = baseW / imgAspect;
                        baseX = 0;
                        baseY = (data.height - baseH) / 2;
                    }

                    const scale = data.imageScale || 1.0;
                    const offsetX = data.imageOffsetX || 0;
                    const offsetY = data.imageOffsetY || 0;

                    const finalW = baseW * scale;
                    const finalH = baseH * scale;
                    const finalX = baseX + (baseW - finalW) / 2 + offsetX;
                    const finalY = baseY + (baseH - finalH) / 2 + offsetY;

                    img.setAttribute('x', finalX);
                    img.setAttribute('y', finalY);
                    img.setAttribute('width', finalW);
                    img.setAttribute('height', finalH);
                } else {
                    img.setAttribute('width', data.width);
                    img.setAttribute('height', data.height);
                }

                imgGroup.appendChild(img);
                group.appendChild(imgGroup);
            }

            // 4. Hit Rectï¼ˆæ“ä½œç”¨ï¼‰
            const hitRect = document.createElementNS(SVG_NS, 'rect');
            hitRect.setAttribute('width', data.width);
            hitRect.setAttribute('height', data.height);
            hitRect.setAttribute('class', 'hit-rect');
            group.appendChild(hitRect);

        } else if (data.type === 'freetext') {
            // è‡ªç”±ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);

            const fontSize = (data.fontSize || 12) * PX_PER_MM;
            const isVertical = data.direction === 'vertical';
            const [alignX, alignY] = (data.align || 'start-start').split('-');

            const lines = [];
            const chars = data.text.split('');
            let currentLine = [];

            for (const char of chars) {
                if (char === '\n') {
                    lines.push(currentLine.join(''));
                    currentLine = [];
                    continue;
                }

                currentLine.push(char);

                if (isVertical) {
                    const currentHeight = currentLine.length * fontSize;
                    if (currentHeight > data.height) {
                        currentLine.pop();
                        lines.push(currentLine.join(''));
                        currentLine = [char];
                    }
                } else {
                    const tempText = document.createElementNS(SVG_NS, 'text');
                    tempText.setAttribute('font-family', data.fontFamily);
                    tempText.setAttribute('font-size', fontSize);
                    tempText.textContent = currentLine.join('');
                    group.appendChild(tempText);
                    const textWidth = tempText.getBBox().width;
                    group.removeChild(tempText);

                    if (textWidth > data.width) {
                        currentLine.pop();
                        lines.push(currentLine.join(''));
                        currentLine = [char];
                    }
                }
            }
            if (currentLine.length > 0) {
                lines.push(currentLine.join(''));
            }

            const textEl = document.createElementNS(SVG_NS, 'text');
            textEl.setAttribute('font-family', data.fontFamily);
            textEl.setAttribute('font-size', fontSize);
            textEl.setAttribute('class', 'ink-fill');

            if (isVertical) {
                textEl.setAttribute('writing-mode', 'vertical-rl');
                textEl.setAttribute('dominant-baseline', 'central');
                textEl.setAttribute('text-anchor', 'middle');

                let startX;
                if (alignX === 'start') startX = data.width - fontSize / 2;
                else if (alignX === 'center') startX = data.width / 2 - (lines.length * fontSize - fontSize) / 2;
                else startX = fontSize / 2 + (lines.length - 1) * fontSize;

                lines.forEach((line, i) => {
                    const tspan = document.createElementNS(SVG_NS, 'tspan');
                    tspan.textContent = line;
                    tspan.setAttribute('x', startX - i * fontSize);

                    let y;
                    const lineHeight = line.length * fontSize;
                    if (alignY === 'start') y = lineHeight / 2;
                    else if (alignY === 'center') y = data.height / 2 - lineHeight / 2 + lineHeight / 2;
                    else y = data.height - lineHeight / 2;

                    tspan.setAttribute('y', y);
                    textEl.appendChild(tspan);
                });

            } else {
                textEl.setAttribute('writing-mode', 'horizontal-tb');
                textEl.setAttribute('dominant-baseline', 'alphabetic');

                let textAnchor;
                if (alignX === 'start') textAnchor = 'start';
                else if (alignX === 'center') textAnchor = 'middle';
                else textAnchor = 'end';
                textEl.setAttribute('text-anchor', textAnchor);

                // ãƒ•ã‚©ãƒ³ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ
                const tempText = document.createElementNS(SVG_NS, 'text');
                tempText.setAttribute('font-family', data.fontFamily);
                tempText.setAttribute('font-size', fontSize);
                tempText.setAttribute('dominant-baseline', 'alphabetic');
                tempText.textContent = 'ã‚';
                tempText.setAttribute('x', 0);
                tempText.setAttribute('y', 0);
                group.appendChild(tempText);
                const bbox = tempText.getBBox();
                group.removeChild(tempText);

                // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‹ã‚‰ã®å®Ÿéš›ã®é«˜ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                const actualHeight = bbox.height;
                const baselineOffset = -bbox.y; // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‹ã‚‰ä¸Šç«¯ã¾ã§ã®è·é›¢

                // 15%ä¸Šã«ãšã‚‰ã™
                const verticalOffset = -fontSize * 0.075;

                let startY;
                if (alignY === 'start') startY = baselineOffset + verticalOffset;
                else if (alignY === 'center') startY = (data.height - lines.length * fontSize) / 2 + baselineOffset + verticalOffset;
                else startY = data.height - lines.length * fontSize + baselineOffset + verticalOffset;

                lines.forEach((line, i) => {
                    const tspan = document.createElementNS(SVG_NS, 'tspan');
                    tspan.textContent = line;

                    let x;
                    if (alignX === 'start') x = 0;
                    else if (alignX === 'center') x = data.width / 2;
                    else x = data.width;

                    tspan.setAttribute('x', x);
                    tspan.setAttribute('y', startY + i * fontSize);
                    textEl.appendChild(tspan);
                });
            }

            group.appendChild(textEl);
            const freeHitRect = document.createElementNS(SVG_NS, 'rect');
            freeHitRect.setAttribute('width', data.width);
            freeHitRect.setAttribute('height', data.height);
            freeHitRect.setAttribute('class', 'hit-rect');
            group.appendChild(freeHitRect);

        } else if (data.type === 'rect') {
            // Rect (Fill)
            group.setAttribute('transform', `translate(${data.x}, ${data.y})`);
            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('width', data.width); rect.setAttribute('height', data.height);

            if (data.fillMode === 'ink') {
                 rect.setAttribute('class', 'ink-fill');
            } else {
                 rect.setAttribute('class', 'paper-fill');
            }
            rect.setAttribute('stroke', 'none');
            rect.style.fillOpacity = '1';
            
            const borderStyle = data.borderStyle || 'none';
            const borderWidth = parseFloat(data.borderWidth || 0.5) * PX_PER_MM;
            const isInkMode = (data.fillMode === 'ink');
            
            const borderG = document.createElementNS(SVG_NS, 'g');
            
            if (borderStyle !== 'none') {
                let strokeClass = isInkMode ? 'paper-stroke' : 'ink-stroke';
                let designOffset = isInkMode ? 1 * PX_PER_MM : 0;
                let totalStrokeWidth = (borderStyle === 'double') ? borderWidth * 3 : borderWidth;
                let strokeRadius = totalStrokeWidth / 2;
                let finalOffset = designOffset + strokeRadius;
                
                const borderRect = document.createElementNS(SVG_NS, 'rect');
                borderRect.setAttribute('x', finalOffset);
                borderRect.setAttribute('y', finalOffset);
                borderRect.setAttribute('width', Math.max(0, data.width - finalOffset * 2));
                borderRect.setAttribute('height', Math.max(0, data.height - finalOffset * 2));
                borderRect.setAttribute('fill', 'none');
                borderRect.setAttribute('class', strokeClass);
                borderRect.setAttribute('stroke-width', totalStrokeWidth);
                
                if (borderStyle === 'dotted') {
                    borderRect.setAttribute('stroke-dasharray', `${totalStrokeWidth}, ${totalStrokeWidth}`);
                }
                
                borderG.appendChild(borderRect);
                
                if (borderStyle === 'double') {
                    const innerRect = document.createElementNS(SVG_NS, 'rect');
                    innerRect.setAttribute('x', finalOffset);
                    innerRect.setAttribute('y', finalOffset);
                    innerRect.setAttribute('width', Math.max(0, data.width - finalOffset * 2));
                    innerRect.setAttribute('height', Math.max(0, data.height - finalOffset * 2));
                    innerRect.setAttribute('fill', 'none');
                    innerRect.setAttribute('class', isInkMode ? 'ink-stroke' : 'paper-stroke');
                    innerRect.setAttribute('stroke-width', borderWidth);
                    
                    borderG.appendChild(innerRect);
                }
            }
            
            group.appendChild(rect);
            group.appendChild(borderG);
            
            const rectHitRect = document.createElementNS(SVG_NS, 'rect');
            rectHitRect.setAttribute('width', data.width);
            rectHitRect.setAttribute('height', data.height);
            rectHitRect.setAttribute('class', 'hit-rect');
            group.appendChild(rectHitRect);
        }
    }

    // --- Heading Helpers ---
    function getHeadingContentBounds(data) {
        // ãƒœãƒ¼ãƒ€ãƒ¼ã¨ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è€ƒæ…®ã—ãŸæç”»é ˜åŸŸã‚’è¨ˆç®—
        let extraP = 0;
        if (data.type === 'masthead') {
            const bo = parseFloat(data.borderWidthOuter) * PX_PER_MM;
            const gap = bo;
            const bi = parseFloat(data.borderWidthInner) * PX_PER_MM;
            extraP = bo + gap + bi + (2 * PX_PER_MM);
        }

        // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ 
        const paddingH = parseFloat(data.paddingH || 0) * PX_PER_MM;
        const paddingV = parseFloat(data.paddingV || 0) * PX_PER_MM;

        const totalOffsetX = extraP + paddingH;
        const totalOffsetY = extraP + paddingV;

        const contentW = Math.max(0, data.width - (totalOffsetX * 2));
        const contentH = Math.max(0, data.height - (totalOffsetY * 2));

        return {
            offsetX: totalOffsetX,
            offsetY: totalOffsetY,
            width: contentW,
            height: contentH
        };
    }

    // --- Border Rendering ---
    function renderBorder() {
        const layerBorder = document.getElementById('layer-border');
        const layerDanLines = document.getElementById('layer-dan-lines');
        if(!layerBorder) return;
        layerBorder.innerHTML = '';
        if(layerDanLines) layerDanLines.innerHTML = '';

        const m = STATE.canvas.margin;
        const w = STATE.canvas.width;
        const h = STATE.canvas.height;
        const offset = 3; // mm

        // ç‰ˆé¢ã‚µã‚¤ã‚º
        const contentX = m.left;
        const contentY = m.top;
        const contentW = w - m.left - m.right;
        const contentH = h - m.top - m.bottom;

        // æ ç·šåº§æ¨™ (ç‰ˆé¢ã‹ã‚‰å¤–å´ã¸3mm)
        const x = (contentX - offset) * PX_PER_MM;
        const y = (contentY - offset) * PX_PER_MM;
        const width = (contentW + offset * 2) * PX_PER_MM;
        const height = (contentH + offset * 2) * PX_PER_MM;

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        rect.setAttribute('fill', 'none');
        rect.setAttribute('class', 'ink-stroke');
        const strokeWidth = 0.4 * PX_PER_MM; // æ ç·šã®å¤ªã•
        rect.setAttribute('stroke-width', strokeWidth);
        rect.setAttribute('stroke-linejoin', 'miter');
        rect.setAttribute('pointer-events', 'none');

        layerBorder.appendChild(rect);

        // --- è¿½åŠ : æ®µé–“ç½«ç·š (Separator Lines) ---
        if (layerDanLines && STATE.grid.dan > 1 && STATE.grid.computed && STATE.grid.computed.danPitch) {
            const danPitch = STATE.grid.computed.danPitch;
            const danHeight = STATE.grid.computed.danHeight;
            const mt = STATE.canvas.margin.top * PX_PER_MM;

            const gap = danPitch - danHeight;
            const lineX1 = contentX * PX_PER_MM;
            const lineX2 = (contentX + contentW) * PX_PER_MM;

            for (let i = 0; i < STATE.grid.dan - 1; i++) {
                const lineY = mt + (i * danPitch) + danHeight + (gap / 2);

                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', lineX1);
                line.setAttribute('y1', lineY);
                line.setAttribute('x2', lineX2);
                line.setAttribute('y2', lineY);
                line.setAttribute('class', 'ink-stroke');
                line.setAttribute('stroke-width', strokeWidth); 
                line.setAttribute('pointer-events', 'none');
                layerDanLines.appendChild(line);
            }
        }
    }

    // --- Character Count Info ---
    function calculateMaxCapacity(data) {
        const useSnapMode = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;
        let segments;
        if (useSnapMode) {
            segments = getIntersectingDans(data);
        } else {
            segments = [{ height: data.height, localY: 0 }];
        }

        let totalCapacity = 0;
        for (const seg of segments) {
            const metrics = getLayoutMetrics(data, seg.height);
            const { charsPerLine, maxLines } = metrics;
            totalCapacity += charsPerLine * maxLines;
        }
        return totalCapacity;
    }

    function updateCharInfo(data) {
        if (data.type !== 'text') return;

        const charCurrentEl = document.getElementById('char-current');
        const charCapacityEl = document.getElementById('char-capacity');
        const charOverflowEl = document.getElementById('char-overflow');

        const head = findChainHead(data);
        const fullText = head.text || "";
        const currentCount = fullText.length;

        let totalCapacity = 0;
        let curr = head;
        while (curr) {
            totalCapacity += calculateMaxCapacity(curr);
            curr = curr.next ? STATE.elements.find(el => el.id === curr.next) : null;
        }

        const overflow = Math.max(0, currentCount - totalCapacity);

        charCurrentEl.textContent = currentCount;
        charCapacityEl.textContent = totalCapacity;
        charOverflowEl.textContent = overflow;

        if (overflow > 0) {
            charOverflowEl.style.color = '#f44336';
            charOverflowEl.style.fontWeight = 'bold';
        } else {
            charOverflowEl.style.color = '#666';
            charOverflowEl.style.fontWeight = 'normal';
        }
    }

    // --- UI/Updates ---
    function renderUi() {
        if (STATE.interactionType === 'resize' || STATE.interactionType === 'drag') {
            if(STATE.selectedId) {
                const data = STATE.elements.find(e => e.id === STATE.selectedId);
                if(data) updateUiPositions(data);
            }
            return;
        }
        layerUi.innerHTML = ''; renderMarginGuide();
        document.getElementById('prop-panel-none').style.display = 'none';
        document.getElementById('prop-panel-text').style.display = 'none';
        document.getElementById('prop-panel-heading').style.display = 'none';
        document.getElementById('prop-panel-masthead').style.display = 'none';
        document.getElementById('prop-panel-rect').style.display = 'none';
        document.getElementById('prop-panel-image').style.display = 'none';
        document.getElementById('prop-panel-freetext').style.display = 'none';

        if (!STATE.selectedId) { document.getElementById('prop-panel-none').style.display = 'block'; return; }
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if (!data) return;

        if (data.type === 'text') {
            document.getElementById('prop-panel-text').style.display = 'block';
            
            const isChild = (data.prev !== undefined && data.prev !== null);
            const infoEl = document.getElementById('text-link-info');
            const txtArea = document.getElementById('inp-text');
            
            if (isChild) {
                infoEl.style.display = 'block';
                txtArea.disabled = true;
                txtArea.value = "(ãƒªãƒ³ã‚¯å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºä¸­)";
            } else {
                infoEl.style.display = 'none';
                txtArea.disabled = false;
                if (document.activeElement.id !== 'inp-text') txtArea.value = data.text;
            }
            
            document.getElementById('inp-fontfamily').value = data.fontFamily;
            document.getElementById('inp-snap-article-txt').checked = data.snapMode !== undefined ? data.snapMode : STATE.articleSnapMode;

            updateCharInfo(data);
        } else if (data.type === 'heading') {
            document.getElementById('prop-panel-heading').style.display = 'block';
            if (document.activeElement.id !== 'inp-heading-text') document.getElementById('inp-heading-text').value = data.text;
            document.getElementById('inp-heading-font').value = data.fontFamily;
            document.getElementById('inp-heading-pv').value = data.paddingV;
            document.getElementById('inp-heading-pv-slider').value = data.paddingV;
            document.getElementById('inp-heading-ph').value = data.paddingH;
            document.getElementById('inp-heading-ph-slider').value = data.paddingH;
            document.getElementById('inp-heading-inverted').checked = data.inverted || false;
        } else if (data.type === 'masthead') {
            document.getElementById('prop-panel-masthead').style.display = 'block';
            if (document.activeElement.id !== 'inp-masthead-text') document.getElementById('inp-masthead-text').value = data.text;
            document.getElementById('inp-masthead-font').value = data.fontFamily;
            document.getElementById('inp-masthead-inverted').checked = data.inverted || false; 
            
            document.getElementById('inp-masthead-bo').value = data.borderWidthOuter;
            document.getElementById('inp-masthead-bo-slider').value = data.borderWidthOuter;
            
            document.getElementById('inp-masthead-bi').value = data.borderWidthInner;
            document.getElementById('inp-masthead-bi-slider').value = data.borderWidthInner;
            
            document.getElementById('inp-masthead-pl').value = data.patternLineHeight;
            document.getElementById('inp-masthead-pl-slider').value = data.patternLineHeight;
            
            document.getElementById('inp-masthead-ph').value = data.paddingH;
            document.getElementById('inp-masthead-ph-slider').value = data.paddingH;
            
            document.getElementById('inp-masthead-pv').value = data.paddingV;
            document.getElementById('inp-masthead-pv-slider').value = data.paddingV;
            
            document.getElementById('inp-masthead-ts').value = data.textStrokeWidth;
            document.getElementById('inp-masthead-ts-slider').value = data.textStrokeWidth;
        } else if (data.type === 'rect') {
            document.getElementById('prop-panel-rect').style.display = 'block';
            document.getElementById('inp-rect-ink').checked = (data.fillMode === 'ink');
            document.getElementById('inp-rect-border-style').value = data.borderStyle || 'none';
            document.getElementById('inp-rect-border-w').value = data.borderWidth || 0.5;
            document.getElementById('inp-rect-border-w-slider').value = data.borderWidth || 0.5;
        } else if (data.type === 'image') {
            document.getElementById('prop-panel-image').style.display = 'block';

            const infoEl = document.getElementById('image-info');
            if (data.imageUrl) {
                const widthPx = Math.ceil(data.width);
                const heightPx = Math.ceil(data.height);
                infoEl.textContent = `ç”»åƒãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ (${widthPx}pxÃ—${heightPx}px)`;
            } else {
                infoEl.textContent = 'ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„';
            }

            if (STATE.cropMode && data.imageUrl && data._imageAspect) {
                const boxAspect = data.width / data.height;
                const imgAspect = data._imageAspect;

                let baseW, baseH, baseX, baseY;
                if (imgAspect > boxAspect) {
                    baseH = data.height;
                    baseW = baseH * imgAspect;
                    baseX = (data.width - baseW) / 2;
                    baseY = 0;
                } else {
                    baseW = data.width;
                    baseH = baseW / imgAspect;
                    baseX = 0;
                    baseY = (data.height - baseH) / 2;
                }

                const scale = data.imageScale || 1.0;
                const offsetX = data.imageOffsetX || 0;
                const offsetY = data.imageOffsetY || 0;

                const imgW = baseW * scale;
                const imgH = baseH * scale;
                const imgX = data.x + baseX + (baseW - imgW) / 2 + offsetX;
                const imgY = data.y + baseY + (baseH - imgH) / 2 + offsetY;

                const boxFrame = document.createElementNS(SVG_NS, 'rect');
                boxFrame.setAttribute('x', data.x);
                boxFrame.setAttribute('y', data.y);
                boxFrame.setAttribute('width', data.width);
                boxFrame.setAttribute('height', data.height);
                boxFrame.setAttribute('fill', 'none');
                boxFrame.setAttribute('stroke', '#00ff00');
                boxFrame.setAttribute('stroke-width', '2');
                boxFrame.setAttribute('stroke-dasharray', '5,5');
                layerUi.appendChild(boxFrame);

                const imgFrame = document.createElementNS(SVG_NS, 'rect');
                imgFrame.setAttribute('x', imgX);
                imgFrame.setAttribute('y', imgY);
                imgFrame.setAttribute('width', imgW);
                imgFrame.setAttribute('height', imgH);
                imgFrame.setAttribute('fill', 'none');
                imgFrame.setAttribute('stroke', '#ff00ff');
                imgFrame.setAttribute('stroke-width', '2');
                imgFrame.setAttribute('cursor', 'move');
                imgFrame.classList.add('image-drag-area');
                layerUi.appendChild(imgFrame);

                const handleSize = 10;
                const createScaleHandle = (x, y, corner) => {
                    const handle = document.createElementNS(SVG_NS, 'rect');
                    handle.setAttribute('x', x - handleSize/2);
                    handle.setAttribute('y', y - handleSize/2);
                    handle.setAttribute('width', handleSize);
                    handle.setAttribute('height', handleSize);
                    handle.setAttribute('fill', '#ff00ff');
                    handle.setAttribute('stroke', 'white');
                    handle.setAttribute('stroke-width', '1');
                    handle.setAttribute('cursor', corner === 'nw' || corner === 'se' ? 'nwse-resize' : 'nesw-resize');
                    handle.setAttribute('data-scale-corner', corner);
                    handle.classList.add('image-scale-handle');
                    layerUi.appendChild(handle);
                };

                createScaleHandle(imgX, imgY, 'nw');
                createScaleHandle(imgX + imgW, imgY, 'ne');
                createScaleHandle(imgX, imgY + imgH, 'sw');
                createScaleHandle(imgX + imgW, imgY + imgH, 'se');

                return;
            }
        } else if (data.type === 'freetext') {
            document.getElementById('prop-panel-freetext').style.display = 'block';
            if (document.activeElement.id !== 'inp-freetext') document.getElementById('inp-freetext').value = data.text;
            document.getElementById('inp-freetext-font').value = data.fontFamily;
            document.getElementById('inp-freetext-size').value = data.fontSize;
            document.getElementById('inp-freetext-size-slider').value = data.fontSize;

            const directionRadios = document.getElementsByName('freetext-direction');
            for (const radio of directionRadios) {
                radio.checked = (radio.value === data.direction);
            }

            const alignRadios = document.getElementsByName('freetext-align');
            for (const radio of alignRadios) {
                radio.checked = (radio.value === data.align);
            }
        }

        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.id = 'ui-selection-rect';
        rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
        rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);

        let selClass = 'selection-rect';
        if (data.type === 'heading') selClass += ' heading-select';
        if (data.type === 'masthead') selClass += ' masthead-select';
        rect.setAttribute('class', selClass);
        layerUi.appendChild(rect);

        const isHeading = (data.type === 'heading');
        const isMasthead = (data.type === 'masthead');
        createHandle(data.x, data.y, 'nw', isHeading, isMasthead);
        createHandle(data.x + data.width, data.y, 'ne', isHeading, isMasthead);
        createHandle(data.x, data.y + data.height, 'sw', isHeading, isMasthead);
        createHandle(data.x + data.width, data.y + data.height, 'se', isHeading, isMasthead);
        
        if (data.type === 'text') {
            createLinkHandle(data);
        }
    }
    
    function createLinkHandle(data) {
        const size = 10;
        const x = data.x + data.width / 2 - size / 2;
        const y = data.y + data.height; // Bottom center
        
        const g = document.createElementNS(SVG_NS, 'g');
        
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', x); rect.setAttribute('y', y);
        rect.setAttribute('width', size); rect.setAttribute('height', size);
        rect.setAttribute('class', 'link-handle-rect' + (data.next ? ' connected' : ''));
        
        const hit = document.createElementNS(SVG_NS, 'rect');
        hit.setAttribute('x', x - 5); hit.setAttribute('y', y - 5);
        hit.setAttribute('width', size + 10); hit.setAttribute('height', size + 10);
        hit.setAttribute('class', 'link-handle-hit');
        
        g.appendChild(rect);
        g.appendChild(hit);
        layerUi.appendChild(g);
    }

    // æ¥ç¶šå¯èƒ½ãªå€™è£œã‚’å…¨ã¦ç·šæ è¡¨ç¤ºã™ã‚‹
    function showLinkCandidates(sourceId) {
        STATE.elements.forEach(el => {
            if (el.id === sourceId) return;
            if (el.type !== 'text') return;
            if (el.next || el.prev) return;
            
            const group = document.getElementById(el.id);
            if (group) group.classList.add('link-candidate');
        });
    }

    function clearLinkCandidates() {
        document.querySelectorAll('.link-candidate').forEach(el => el.classList.remove('link-candidate'));
        document.querySelectorAll('.highlight-target').forEach(el => el.classList.remove('highlight-target'));
    }

    function updateLinkHighlight(targetId) {
        const highlights = document.querySelectorAll('.highlight-target');
        highlights.forEach(el => el.classList.remove('highlight-target'));
        
        if (targetId) {
            const group = document.getElementById(targetId);
            if (group) group.classList.add('highlight-target');
        }
    }

    function updateUiPositions(data) {
        const rect = document.getElementById('ui-selection-rect');
        if(rect) {
            rect.setAttribute('x', data.x - 2); rect.setAttribute('y', data.y - 2);
            rect.setAttribute('width', data.width + 4); rect.setAttribute('height', data.height + 4);
        }
        const setPos = (sel, x, y) => {
            const group = layerUi.querySelector(sel);
            if(group) group.querySelectorAll('circle').forEach(c => { c.setAttribute('cx', x); c.setAttribute('cy', y); });
        };
        setPos('.cursor-nw', data.x, data.y); setPos('.cursor-ne', data.x + data.width, data.y);
        setPos('.cursor-sw', data.x, data.y + data.height); setPos('.cursor-se', data.x + data.width, data.y + data.height);
        
        const linkHandle = layerUi.querySelector('.link-handle-rect');
        const linkHit = layerUi.querySelector('.link-handle-hit');
        if (linkHandle && linkHit) {
            const size = 10;
            const lx = data.x + data.width / 2 - size / 2;
            const ly = data.y + data.height;
            linkHandle.setAttribute('x', lx); linkHandle.setAttribute('y', ly);
            linkHit.setAttribute('x', lx - 5); linkHit.setAttribute('y', ly - 5);
        }
    }

    function createHandle(x, y, dir, isHeading, isMasthead) {
        const group = document.createElementNS(SVG_NS, 'g');
        let classes = `handle-group cursor-${dir}`;
        if (isHeading) classes += ' heading-handle';
        if (isMasthead) classes += ' masthead-handle';
        
        group.setAttribute('class', classes);
        const hitArea = document.createElementNS(SVG_NS, 'circle');
        hitArea.setAttribute('cx', x); hitArea.setAttribute('cy', y); hitArea.setAttribute('r', 30); 
        hitArea.setAttribute('class', 'resize-handle-hit');
        const visible = document.createElementNS(SVG_NS, 'circle');
        visible.setAttribute('cx', x); visible.setAttribute('cy', y); visible.setAttribute('r', 6); 
        visible.setAttribute('class', 'resize-handle-visual');
        group.appendChild(visible); group.appendChild(hitArea); 
        layerUi.appendChild(group);
    }
    
    function selectElement(id) { STATE.selectedId = id; renderUi(); }
    function deleteSelected() { 
        if (!STATE.selectedId) return; 
        const id = STATE.selectedId;
        const data = STATE.elements.find(e => e.id === id);
        if (data && data.type === 'text') {
             if (data.next) {
                 const next = STATE.elements.find(e => e.id === data.next);
                 if(next) { 
                     next.prev = null; 
                     delete next._renderedText; 
                     if (!next.text) next.text = "æ–°è¦è¨˜äº‹"; 
                     renderElement(next); 
                 }
             }
             if (data.prev) {
                 const prev = STATE.elements.find(e => e.id === data.prev);
                 if(prev) { 
                     prev.next = null; 
                     const head = findChainHead(prev);
                     updateTextChain(head);
                 } 
             }
        }
        
        const pattern = document.getElementById('pat-' + id);
        if(pattern) pattern.remove();
        const clip = document.getElementById('clip-' + id);
        if(clip) clip.remove();

        document.getElementById(id).remove(); 
        STATE.elements = STATE.elements.filter(e => e.id !== id); 
        STATE.selectedId = null; renderUi(); 
    }
    
    function updateSelectedText() {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if(data && data.type === 'text') {
            if (!data.prev) {
                data.text = document.getElementById('inp-text').value;
                updateTextChain(data);
                updateCharInfo(data);
            }
        }
    }
    function updateSelectedStyle() {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if(data && data.type === 'text') {
            data.fontFamily = document.getElementById('inp-fontfamily').value;
            const head = findChainHead(data);
            updateTextChain(head);
            updateUiPositions(data);
        }
    }

    function updateHeadingProp(key, subKey, val) {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if(!data || data.type !== 'heading') return;
        
        if (key === 'text') data.text = document.getElementById('inp-heading-text').value;
        if (key === 'fontFamily') data.fontFamily = document.getElementById('inp-heading-font').value;
        if (key === 'inverted') data.inverted = document.getElementById('inp-heading-inverted').checked;
        
        if (key === 'padding') {
            const numVal = parseFloat(val);
            if (subKey === 'h') {
                data.paddingH = numVal;
                document.getElementById('inp-heading-ph').value = numVal;
                document.getElementById('inp-heading-ph-slider').value = numVal;
            } else if (subKey === 'v') {
                data.paddingV = numVal;
                document.getElementById('inp-heading-pv').value = numVal;
                document.getElementById('inp-heading-pv-slider').value = numVal;
            }
        }
        renderElement(data);
    }

    function updateMastheadProp(key, val) {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if(!data || data.type !== 'masthead') return;
        
        if (key === 'text') data.text = document.getElementById('inp-masthead-text').value;
        if (key === 'fontFamily') data.fontFamily = document.getElementById('inp-masthead-font').value;
        if (key === 'inverted') data.inverted = document.getElementById('inp-masthead-inverted').checked;

        if (key === 'borderWidthOuter') {
            data.borderWidthOuter = val;
            document.getElementById('inp-masthead-bo').value = val;
            document.getElementById('inp-masthead-bo-slider').value = val;
        }
        if (key === 'borderWidthInner') {
            data.borderWidthInner = val;
            document.getElementById('inp-masthead-bi').value = val;
            document.getElementById('inp-masthead-bi-slider').value = val;
        }
        if (key === 'patternLineHeight') {
            data.patternLineHeight = val;
            document.getElementById('inp-masthead-pl').value = val;
            document.getElementById('inp-masthead-pl-slider').value = val;
        }
        
        if (key === 'paddingH') {
            data.paddingH = val;
            document.getElementById('inp-masthead-ph').value = val;
            document.getElementById('inp-masthead-ph-slider').value = val;
        }
        if (key === 'paddingV') {
            data.paddingV = val;
            document.getElementById('inp-masthead-pv').value = val;
            document.getElementById('inp-masthead-pv-slider').value = val;
        }
        if (key === 'textStrokeWidth') {
            data.textStrokeWidth = val;
            document.getElementById('inp-masthead-ts').value = val;
            document.getElementById('inp-masthead-ts-slider').value = val;
        }
        
        renderElement(data);
    }

    function updateRectProp(key, val) {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if(!data || data.type !== 'rect') return;

        const isInk = document.getElementById('inp-rect-ink').checked;
        data.fillMode = isInk ? 'ink' : 'paper';

        data.borderStyle = document.getElementById('inp-rect-border-style').value;

        if (key === 'width') {
            const w = parseFloat(val);
            data.borderWidth = w;
            document.getElementById('inp-rect-border-w').value = w;
            document.getElementById('inp-rect-border-w-slider').value = w;
        }

        renderElement(data);
    }

    function updateFreeTextProp(prop) {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if (!data || data.type !== 'freetext') return;

        if (prop === 'text') {
            data.text = document.getElementById('inp-freetext').value;
        } else if (prop === 'direction') {
            const directionRadios = document.getElementsByName('freetext-direction');
            for (const radio of directionRadios) {
                if (radio.checked) {
                    data.direction = radio.value;
                    break;
                }
            }
        } else if (prop === 'align') {
            const alignRadios = document.getElementsByName('freetext-align');
            for (const radio of alignRadios) {
                if (radio.checked) {
                    data.align = radio.value;
                    break;
                }
            }
        } else if (prop === 'fontFamily') {
            data.fontFamily = document.getElementById('inp-freetext-font').value;
        } else if (prop === 'fontSize') {
            const size = parseFloat(document.activeElement.value);
            data.fontSize = size;
            document.getElementById('inp-freetext-size').value = size;
            document.getElementById('inp-freetext-size-slider').value = size;
        }

        renderElement(data);
    }

    function toggleCropMode() {
        STATE.cropMode = !STATE.cropMode;
        const btn = document.getElementById('btn-crop-mode');
        if (STATE.cropMode) {
            btn.textContent = 'ãƒˆãƒªãƒŸãƒ³ã‚°å®Œäº†';
            btn.style.backgroundColor = '#4CAF50';
        } else {
            btn.textContent = 'ãƒˆãƒªãƒŸãƒ³ã‚°èª¿æ•´';
            btn.style.backgroundColor = '';
        }
        renderUi();
    }

    function loadImageFile(input) {
        const data = STATE.elements.find(e => e.id === STATE.selectedId);
        if(!data || data.type !== 'image') return;

        const file = input.files[0];
        if (!file) return;

        loadImageToElement(file, data);
    }

    // --- Export & Utils ---
    function fitView() {
        const vw = viewport.clientWidth; const vh = viewport.clientHeight;
        const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
        const margin = 40;
        const scale = Math.min((vw - margin*2) / w_px, (vh - margin*2) / h_px);
        STATE.view.scale = Math.max(0.1, Math.min(scale, 5.0));
        STATE.view.x = (vw - w_px * STATE.view.scale) / 2; STATE.view.y = (vh - h_px * STATE.view.scale) / 2;
        updateTransform();
    }
    function updateTransform() { canvasContainer.style.transform = `translate(${STATE.view.x}px, ${STATE.view.y}px) scale(${STATE.view.scale})`; }
    
    function updateCanvasSize() {
        const w = parseFloat(document.getElementById('inp-canvas-w').value);
        const h = parseFloat(document.getElementById('inp-canvas-h').value);
        STATE.canvas.width = w; STATE.canvas.height = h;
        mainSvg.setAttribute('width', w * PX_PER_MM); mainSvg.setAttribute('height', h * PX_PER_MM);
        mainSvg.setAttribute('viewBox', `0 0 ${w * PX_PER_MM} ${h * PX_PER_MM}`);
        updateGridSettings(); renderMarginGuide(); renderBorder();
    }
    function updateGridSettings() { 
        STATE.grid.show = document.getElementById('inp-layout-show').checked;
        STATE.grid.dan = parseInt(document.getElementById('inp-layout-dan').value);
        STATE.grid.charsPerDan = parseInt(document.getElementById('inp-layout-chars').value);
        STATE.grid.totalLines = parseInt(document.getElementById('inp-layout-lines').value);
        renderPaperGrid(); 
    }
    function renderMarginGuide() {
        const old = document.getElementById('margin-guide-rect'); if(old) old.remove();
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const ml = STATE.canvas.margin.left * PX_PER_MM;
        const w = STATE.canvas.width * PX_PER_MM;
        const h = STATE.canvas.height * PX_PER_MM;
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.id = 'margin-guide-rect';
        rect.setAttribute('x', ml); rect.setAttribute('y', mt);
        rect.setAttribute('width', w - ml - STATE.canvas.margin.right*PX_PER_MM);
        rect.setAttribute('height', h - mt - STATE.canvas.margin.bottom*PX_PER_MM);
        rect.setAttribute('class', 'margin-guide');
        layerUi.appendChild(rect);
    }
    function renderPaperGrid() {
        layerPaperGrid.innerHTML = '';
        if(!STATE.grid.show) return;
        const mt = STATE.canvas.margin.top * PX_PER_MM;
        const w_px = STATE.canvas.width * PX_PER_MM; const h_px = STATE.canvas.height * PX_PER_MM;
        const validH = h_px - mt - STATE.canvas.margin.bottom * PX_PER_MM;
        const validW = w_px - STATE.canvas.margin.left * PX_PER_MM - STATE.canvas.margin.right * PX_PER_MM;
        const totalHUnits = (STATE.grid.charsPerDan * STATE.grid.dan) + (STATE.grid.dan - 1);
        const unitH = validH / totalHUnits;
        const danPitch = (STATE.grid.charsPerDan * unitH) + unitH;
        const fontSizeW = unitH / CHAR_SCALE_RATIO;
        const pitchX = fontSizeW + (STATE.grid.totalLines > 1 ? (validW - fontSizeW * STATE.grid.totalLines) / (STATE.grid.totalLines - 1) : 0);
        STATE.grid.computed = { charSizeW: fontSizeW, charSizeH: unitH, danHeight: unitH * STATE.grid.charsPerDan, danPitch, pitchX, lineGap: (pitchX - fontSizeW) };
        document.getElementById('grid-info').innerHTML = `æ–‡å­—ã‚µã‚¤ã‚º: ${(fontSizeW / PX_PER_MM).toFixed(2)}mm`;
        const mr = STATE.canvas.margin.right * PX_PER_MM;
        for(let l=0; l<STATE.grid.totalLines; l++) {
            const lineX = (w_px - mr) - fontSizeW - (l * STATE.grid.computed.pitchX);
            for(let d=0; d<STATE.grid.dan; d++) {
                const startY = mt + (d * danPitch);
                for(let c=0; c<STATE.grid.charsPerDan; c++) {
                    const rect = document.createElementNS(SVG_NS, 'rect');
                    rect.setAttribute('x', lineX); rect.setAttribute('y', startY + (c * unitH));
                    rect.setAttribute('width', fontSizeW); rect.setAttribute('height', unitH);
                    rect.setAttribute('class', 'grid-rect');
                    layerPaperGrid.appendChild(rect);
                }
            }
        }
    }
    function updateColors() { 
        const paperC = document.getElementById('inp-paper-color').value;
        const inkC = document.getElementById('inp-ink-color').value;
        STATE.canvas.colors.paper = paperC; STATE.canvas.colors.ink = inkC;
        svgStyle.textContent = `
            .hit-rect { fill: #ffffff; fill-opacity: 0; pointer-events: all; }
            .ink-fill { fill: ${inkC}; } .ink-stroke { stroke: ${inkC}; } 
            .paper-fill { fill: ${paperC}; } .paper-stroke { stroke: ${paperC}; } 
            text { fill: ${inkC}; }
        `;
        renderBorder();
    }
    
    async function urlToBase64(url) {
        try { const res = await fetch(url); const blob = await res.blob();
            return new Promise(r => { const reader = new FileReader(); reader.onloadend = () => r(reader.result); reader.readAsDataURL(blob); });
        } catch { return null; }
    }
    async function getEmbeddableFontCss(cssUrl) {
        try { const res = await fetch(cssUrl); let cssText = await res.text();
            const urlRegex = /url\((['"]?)(https:\/\/[^'"\)]+)\1\)/g; let match; const replacements = [];
            while ((match = urlRegex.exec(cssText)) !== null) replacements.push({ original: match[0], url: match[2] });
            const uniqueUrls = [...new Set(replacements.map(r => r.url))];
            const base64Map = {};
            await Promise.all(uniqueUrls.map(async (url) => { const b64 = await urlToBase64(url); if(b64) base64Map[url] = b64; }));
            for (const rep of replacements) if (base64Map[rep.url]) cssText = cssText.split(rep.original).join(`url("${base64Map[rep.url]}")`);
            return cssText;
        } catch { return ''; }
    }
    async function exportCanvas(isRetry = false) {
        const btn = document.getElementById('btn-export');
        const originalText = btn.textContent;
        btn.textContent = "å‡¦ç†ä¸­..."; btn.disabled = true;
        layerUi.style.display = 'none'; layerPaperGrid.style.display = 'none';

        try {
            // ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ä½œæˆã—ã€ä¸è¦ãªUIè¦ç´ ã‚’å‰Šé™¤
            const svgClone = mainSvg.cloneNode(true);
            svgClone.querySelectorAll('.hit-rect, #margin-guide-rect').forEach(el => el.remove());

            // font-familyå±æ€§ã‚’ç°¡ç´ åŒ–ï¼ˆã‚¯ã‚©ãƒ¼ãƒˆå‰Šé™¤ï¼‰
            svgClone.querySelectorAll('[font-family]').forEach(el => {
                let ff = el.getAttribute('font-family');
                if (ff) {
                    ff = ff.replace(/['"]/g, '').split(',')[0].trim();
                    el.setAttribute('font-family', ff);
                    // styleå±æ€§ã‚‚ã‚ã‚Œã°æ›´æ–°
                    if (el.style.fontFamily) {
                        el.style.fontFamily = ff;
                    }
                }
            });

            // å‹•çš„ãªã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆè‰²ãªã©ï¼‰ã‚’ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§åŸ‹ã‚è¾¼ã‚€
            const inkC = STATE.canvas.colors.ink;
            const paperC = STATE.canvas.colors.paper;
            const dynamicCss = `
                .ink-fill { fill: ${inkC} !important; }
                .ink-stroke { stroke: ${inkC} !important; }
                .paper-fill { fill: ${paperC} !important; }
                .paper-stroke { stroke: ${paperC} !important; }
                text { fill: ${inkC} !important; }
            `;
            const dynamicStyleEl = document.createElementNS(SVG_NS, 'style');
            dynamicStyleEl.textContent = dynamicCss;
            svgClone.querySelector('defs').appendChild(dynamicStyleEl);

            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = () => {
                // åˆå›ã¯æ›¸ãå‡ºã—ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã€2å›ç›®ã‚’è‡ªå‹•å®Ÿè¡Œ
                if (!isRetry) {
                    URL.revokeObjectURL(url);
                    // å°‘ã—å¾…ã£ã¦ã‹ã‚‰2å›ç›®ã‚’å®Ÿè¡Œ
                    setTimeout(() => {
                        exportCanvas(true);
                    }, 100);
                    return;
                }

                // 2å›ç›®ã¯å®Ÿéš›ã«æ›¸ãå‡ºã—
                const currentW = parseFloat(mainSvg.getAttribute('width'));
                const currentH = parseFloat(mainSvg.getAttribute('height'));
                const canvas = document.createElement('canvas');
                const scale = 4; // é«˜è§£åƒåº¦åŒ–
                canvas.width = currentW * scale;
                canvas.height = currentH * scale;
                const ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);

                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = 'newspaper.png';
                a.click();

                URL.revokeObjectURL(url);
                btn.textContent = originalText;
                btn.disabled = false;
                layerUi.style.display = 'block';
                layerPaperGrid.style.display = 'block';
            };
            img.onerror = () => {
                console.error("Image loading for export failed.");
                URL.revokeObjectURL(url);
                btn.textContent = "ã‚¨ãƒ©ãƒ¼";
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
                layerUi.style.display = 'block';
                layerPaperGrid.style.display = 'block';
            };
            img.src = url;

        } catch (e) {
            console.error("Export failed:", e);
            btn.textContent = originalText;
            btn.disabled = false;
            layerUi.style.display = 'block';
            layerPaperGrid.style.display = 'block';
        }
    }

    function setCanvasPreset(w, h) { document.getElementById('inp-canvas-w').value = w; document.getElementById('inp-canvas-h').value = h; updateCanvasSize(); fitView(); }
    function swapCanvasSize() { const w = document.getElementById('inp-canvas-w'); const h = document.getElementById('inp-canvas-h'); [w.value, h.value] = [h.value, w.value]; updateCanvasSize(); }
    function getSvgPoint(clientX, clientY) {
        const vpRect = viewport.getBoundingClientRect();
        return { x: (clientX - vpRect.left - STATE.view.x) / STATE.view.scale, y: (clientY - vpRect.top - STATE.view.y) / STATE.view.scale };
    }
    
    // --- åˆæœŸåŒ–å‡¦ç† ---
    window.addEventListener('load', async () => {
        // åŸºæœ¬UIã®åˆæœŸåŒ–
        updateCanvasSize(); 
        updateGridSettings(); 
        updateColors(); 
        fitView();
        
        // ãƒ•ã‚©ãƒ³ãƒˆã‚’éåŒæœŸã§å–å¾—ã—ã€SVGã«åŸ‹ã‚è¾¼ã‚€
        try {
            const fontCssUrl = 'https://fonts.googleapis.com/css2?family=BIZ+UDMincho&family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@400;700;900&family=Yuji+Syuku&display=block';
            const embeddedCss = await getEmbeddableFontCss(fontCssUrl);
            
            if (embeddedCss) {
                // æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ«ã«è¿½è¨˜ã™ã‚‹
                svgStyle.textContent += '\n' + embeddedCss;
            }
        } catch(e) {
            console.error("Failed to embed fonts:", e);
        } finally {
            // ãƒ•ã‚©ãƒ³ãƒˆã®æº–å‚™ãŒã§ããŸå¾Œã«è¦ç´ ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            if (document.fonts) {
                await document.fonts.ready;
            }
            STATE.elements.forEach(renderElement);
            if(STATE.selectedId) renderUi();
        }
        
        setupImageDragAndDrop();
    });

    // ç”»åƒãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    function setupImageDragAndDrop() {
        // SVGã‚­ãƒ£ãƒ³ãƒã‚¹ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—
        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (!file || !file.type.startsWith('image/')) return;

            // ãƒã‚¦ã‚¹åº§æ¨™ã‹ã‚‰SVGåº§æ¨™ã‚’å–å¾—
            const rect = mainSvg.getBoundingClientRect();
            const svgX = (e.clientX - rect.left) / STATE.view.scale;
            const svgY = (e.clientY - rect.top) / STATE.view.scale;

            // ãã®ä½ç½®ã«ã‚ã‚‹ç”»åƒãƒœãƒƒã‚¯ã‚¹ã‚’æ¢ã™
            let targetImage = null;
            for (let i = STATE.elements.length - 1; i >= 0; i--) {
                const el = STATE.elements[i];
                if (el.type === 'image' &&
                    svgX >= el.x && svgX <= el.x + el.width &&
                    svgY >= el.y && svgY <= el.y + el.height) {
                    targetImage = el;
                    break;
                }
            }

            if (targetImage) {
                loadImageToElement(file, targetImage);
            }
        });

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—
        const propPanel = document.getElementById('prop-panel-image');
        propPanel.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        propPanel.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (!file || !file.type.startsWith('image/')) return;

            const data = STATE.elements.find(el => el.id === STATE.selectedId);
            if (data && data.type === 'image') {
                loadImageToElement(file, data);
            }
        });
    }

    // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¦ç´ ã«èª­ã¿è¾¼ã‚€å…±é€šé–¢æ•°
    function loadImageToElement(file, data) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
                data._imageAspect = img.width / img.height;
                data.imageUrl = e.target.result;
                renderElement(data);
                if (STATE.selectedId === data.id) {
                    renderUi();
                }
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
</script>
</body>
</html>
